# 🗓️ 2025년 12월 8일 TIL - C언어

## 📌 오늘의 키워드

`그래프(Graph)` `인접 행렬(Adjacency Matrix)` `인접 리스트(Adjacency List)`
`메모리 효율성` `공간 복잡도` `그래프 표현 방식 비교`

---

## 1️⃣ 그래프 표현 방식 개요

그래프는 **정점(Vertex)** 과 **간선(Edge)** 의 집합으로 구성된 자료구조이다.
그래프를 구현하는 대표적인 방법은 다음 두 가지다.

1. **인접 행렬 (Adjacency Matrix)**
2. **인접 리스트 (Adjacency List)**

각 방식은 **메모리 사용량**, **탐색 속도**, **구현 난이도**가 다르다.

---

## 2️⃣ 인접 행렬 (Adjacency Matrix)

### 💡 개념

* **2차원 배열(matrix)** 을 사용하여 정점 간의 연결 여부를 표현한다.
* `adj_mat[i][j] = 1` → i번 정점과 j번 정점이 연결되어 있다는 의미
* 무방향 그래프에서는 **대각선을 기준으로 대칭**이다.

  ```
  adj[i][j] == adj[j][i]
  ```

---

### 💻 주요 코드 요약

```c
typedef struct {
    int n; // 정점 개수
    int adj_mat[MAX_VERTICES][MAX_VERTICES];
} GraphMatrix;

void insert_edge(GraphMatrix* g, int start, int end) {
    g->adj_mat[start][end] = 1;
    g->adj_mat[end][start] = 1; // 무방향 그래프
}
```

---

### ✅ 특징

| 항목         | 설명                             |
| ---------- | ------------------------------ |
| **공간 복잡도** | O(V²) — 간선 수와 무관하게 모든 정점 쌍을 저장 |
| **탐색 속도**  | O(1) — 두 정점 연결 여부 즉시 확인 가능     |
| **장점**     | 빠른 접근, 단순한 구현                  |
| **단점**     | 메모리 낭비 (특히 간선이 적은 그래프에서)       |

---

## 3️⃣ 인접 리스트 (Adjacency List)

### 💡 개념

* 각 정점마다 **인접한 정점의 목록(Linked List)** 을 별도로 저장.
* 정점 개수만큼의 포인터 배열을 두고,
  각 배열의 요소가 해당 정점의 **연결 리스트의 시작 주소**를 가리킨다.

---

### 💻 주요 코드 요약

```c
typedef struct GraphNode {
    int vertex;
    struct GraphNode* link;
} GraphNode;

typedef struct {
    int n;
    GraphNode* adj_list[MAX_VERTICES];
} GraphList;

void insert_edge(GraphList* g, int start, int end) {
    GraphNode* node = (GraphNode*)malloc(sizeof(GraphNode));
    node1->vertex = end;
    node1->link = g->adj_list[start];
    g->adj_list[start] = node;
}
```

---

### ✅ 특징

| 항목         | 설명                                     |
| ---------- | -------------------------------------- |
| **공간 복잡도** | O(V + E) — 실제 존재하는 간선만 저장              |
| **탐색 속도**  | O(V) — 특정 정점과 연결된 노드 탐색 시 리스트 전체 탐색 필요 |
| **장점**     | 메모리 효율적, 간선 수가 적은 희소 그래프에 유리           |
| **단점**     | 두 정점이 연결되어 있는지 빠르게 확인하기 어려움            |

---

## 4️⃣ 인접 행렬 vs 인접 리스트 비교

| 구분             | 인접 행렬 (Matrix)      | 인접 리스트 (List)        |
| -------------- | ------------------- | -------------------- |
| **메모리 사용량**    | O(V²)               | O(V + E)             |
| **탐색 속도**      | 빠름 (O(1))           | 느림 (O(V))            |
| **구현 난이도**     | 쉬움                  | 중간                   |
| **간선이 적은 그래프** | 비효율적                | 효율적                  |
| **간선이 많은 그래프** | 효율적                 | 오히려 복잡해질 수 있음        |
| **적합한 경우**     | 밀집 그래프(Dense Graph) | 희소 그래프(Sparse Graph) |

---

## 5️⃣ 시각적 이해

**그래프 구조 예시**

```
        0
       / \
      1---2
      | \
      3--4
```

### 인접 행렬

```
0: 0 1 1 0 0
1: 1 0 1 1 1
2: 1 1 0 0 0
3: 0 1 0 0 1
4: 0 1 0 1 0
```

### 인접 리스트

```
0 → 2 → 1  
1 → 4 → 3 → 2 → 0  
2 → 1 → 0  
3 → 4 → 1  
4 → 3 → 1
```

---

## 🎯 최종 정리

| 개념          | 내용                        |
| ----------- | ------------------------- |
| **그래프 표현법** | 인접 행렬, 인접 리스트             |
| **행렬형**     | 빠른 탐색, 많은 메모리             |
| **리스트형**    | 메모리 절약, 탐색은 느림            |
| **공통점**     | 모두 정점과 간선의 연결 관계를 저장하는 구조 |
| **선택 기준**   | 간선 밀도, 성능 요구에 따라 선택       |

---

## 💬 오늘의 소감

오늘은 **그래프의 두 가지 주요 표현 방식**인
**인접 행렬(Adjacency Matrix)** 과 **인접 리스트(Adjacency List)** 를 비교하며 학습했다.
같은 그래프라도 표현 방법에 따라 **메모리 효율성과 탐색 성능이 크게 달라진다**는 점이 인상 깊었다.
특히 **희소 그래프(sparse graph)** 에서는 인접 리스트가 훨씬 효율적이며,
**밀집 그래프(dense graph)** 에서는 인접 행렬이 빠르다는 점을 명확히 이해할 수 있었다.
