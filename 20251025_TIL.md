# 🗓️ 2025년 10월 25일 TIL - WebSocket 세션 불일치 문제와 프론트엔드 연결 관리

## 오늘의 키워드
`WebSocket 연결 정리`, `세션 상태 불일치`, `페이지 새로고침`, `리소스 정리`, `cleanup 패턴`

---

## 문제 상황

퀴즈 대기방에서 방장이 새로고침(F5)을 하면:
1. "이미 시작된 방" alert 메시지 표시
2. 메인 페이지로 이동 후 다른 방 입장 시 "이미 다른 탭에서 게임 참여 중" 오류
3. 메인 페이지를 한 번 더 새로고침해야 정상 입장 가능

일반 참가자는 새로고침 시 문제없이 재참가 가능했던 반면, 방장만 이 문제가 발생했다.

---

## 기초 지식

### WebSocket 연결의 생명주기

WebSocket은 클라이언트와 서버 간 양방향 통신 채널이다. 
일반적인 HTTP 요청-응답과 달리, 한 번 연결되면 명시적으로 끊기 전까지 계속 유지된다.

```
연결 생성 → 메시지 송수신 → 연결 종료
   ↓            ↓              ↓
connect()    send()/on()   disconnect()
```

**주의할 점:**
- 페이지 이동 시 자동으로 끊기지 않을 수 있음
- 브라우저 새로고침 시 강제로 끊기지만, 타이밍 이슈 발생 가능
- 연결 상태를 클라이언트와 서버가 각각 관리함

### 세션(Session)이란?

세션은 클라이언트와 서버 간 "연결 상태"를 나타내는 개념이다.

**프론트엔드 세션:**
- WebSocket 연결 객체가 존재하는지 여부
- `websocketService.isConnected()` 같은 메서드로 확인

**백엔드 세션:**
- 서버 메모리에 저장된 사용자 연결 정보
- 사용자 ID, 방 ID, WebSocket 세션 ID 등을 매핑

### 세션 불일치 문제

프론트엔드와 백엔드의 세션 상태가 다를 때 발생한다:

| 상황 | 프론트엔드 | 백엔드 | 결과 |
|------|-----------|--------|------|
| 정상 | 연결됨 | 세션 있음 | ✅ 정상 동작 |
| 불일치 | 연결됨 | 세션 없음 | ❌ 새 방 입장 불가 |
| 불일치 | 연결 없음 | 세션 있음 | ❌ 메시지 수신 불가 |

### 페이지 새로고침 시 발생하는 일

```
1. 브라우저: 페이지 언로드 시작
   └─ JavaScript 실행 컨텍스트 소멸
   └─ WebSocket 연결 강제 종료

2. 서버: DISCONNECT 이벤트 수신
   └─ 세션 정리 로직 실행

3. 브라우저: 새 페이지 로드
   └─ JavaScript 재실행
   └─ React 컴포넌트 마운트

4. 프론트엔드: useEffect 실행
   └─ WebSocket 재연결 시도
```

**타이밍 이슈:**
- 2번과 4번 사이에 시간차 발생
- 서버는 이미 세션을 정리했는데, 프론트엔드는 재연결을 시도
- 방 상태가 이미 변경됨 (FINISHED)

---

## 문제 원인 분석

### 백엔드 검증 결과

백엔드 코드를 확인한 결과, **세션 정리는 정상 작동**하고 있었다:

```java
public boolean handleSessionDisconnect(Long userId, String sessionId) {
    try {
        if (!isActiveSession(userId, sessionId)) {
            return false;
        }
        handleRoomLeave(userId);
        return true;
    } finally {
        // 예외 발생 여부와 무관하게 항상 실행
        cleanupSession(userId, sessionId);
    }
}
```

방장이 나가면 방이 종료되고, 모든 참가자의 세션이 정리된다.

### 실제 문제: 프론트엔드 연결 정리 누락

문제의 핵심은 **프론트엔드 WebSocket 연결이 정리되지 않는 것**이었다:

```javascript
// 기존 코드 (문제 있음)
const handleError = useCallback((data) => {
  if (data.error === 'ROOM_ALREADY_STARTED') {
    alert('이미 시작된 방입니다.');
    navigate('/main');  // ❌ WebSocket 연결은 그대로!
  }
}, [navigate]);
```

### 정확한 시퀀스

```
[T1] 방장 새로고침
  ↓
[T2] WebSocket 연결 강제 종료 (브라우저)
  ↓
[T3] 백엔드 DISCONNECT 이벤트 수신
  ├─ 방 종료 처리
  ├─ 참가자들에게 알림
  └─ 세션 정리 완료 ✅
  ↓
[T4] 페이지 리로드 완료
  ↓
[T5] useWaitingRoomWebSocket 실행
  └─ WebSocket 재연결
  └─ ROOM_JOIN 메시지 전송
  ↓
[T6] 백엔드: 방이 FINISHED 상태
  └─ "ROOM_ALREADY_STARTED" 에러 반환
  ↓
[T7] handleError 실행
  └─ alert 표시
  └─ navigate('/main')
  └─ ❌ WebSocket 연결 정리 안됨!
  ↓
[T8] 메인 페이지
  └─ WebSocket 연결: 여전히 살아있음
  └─ 백엔드 세션: 이미 정리됨
  ↓
[T9] 다른 방 입장 시도
  └─ 프론트엔드: isConnected() = true
  └─ 백엔드: 세션 없음
  └─ ❌ "다른 탭에서 참여 중" 에러
```

---

## 해결 방법

### React의 cleanup 패턴

React에서 리소스를 정리하는 두 가지 방법:

**1. useEffect cleanup 함수:**
```javascript
useEffect(() => {
  // 설정 코드
  const connection = createConnection();
  
  return () => {
    // 정리 코드
    connection.disconnect();
  };
}, []);
```

**2. 명시적 정리:**
```javascript
const handleError = () => {
  websocketService.disconnect();  // 명시적으로 정리
  navigate('/main');
};
```

### 적용한 해결책

#### 1단계: 에러 핸들러에서 연결 정리

```javascript
const handleError = useCallback((data) => {
  console.error('📥 에러:', data);

  if (data.error === 'ROOM_ALREADY_STARTED' || 
      (data.message && data.message.includes('이미 시작된 방'))) {
    
    // ✅ WebSocket 연결 명시적으로 정리
    websocketService.disconnect();
    console.log('✅ WebSocket 연결 해제 완료');
    
    // ✅ 웹캠도 함께 정리
    if (isWebcamOn) {
      stopWebcam();
      console.log('✅ 웹캠 정리 완료');
    }
    
    // AlertModal로 UI 통일
    setShowRoomClosedAlert(true);
    return;
  }

  alert(data.message || '오류가 발생했습니다.');
}, [isWebcamOn, stopWebcam]);
```

#### 2단계: AlertModal 닫기 핸들러

```javascript
const handleRoomClosedAlertClose = useCallback(() => {
  // 리소스는 이미 정리됨
  // 페이지 이동만 수행
  navigate('/main');
}, [navigate]);
```

### 왜 이렇게 해야 하는가?

**정리 순서가 중요한 이유:**

```
❌ 잘못된 순서:
navigate('/main') → 컴포넌트 언마운트 → WebSocket 객체 소멸
→ disconnect() 호출 불가

✅ 올바른 순서:
disconnect() → 연결 정리 완료 → navigate('/main')
→ 깨끗한 상태에서 페이지 이동
```

---

## 추가 개선사항

### useWaitingRoomWebSocket 훅 개선

훅 레벨에서도 안전장치를 추가했다:

```javascript
useEffect(() => {
  // ... 연결 설정 ...

  const handleError = (data) => {
    // 치명적인 에러 시 자동으로 연결 정리
    if (data.error === 'ROOM_ALREADY_STARTED' || 
        data.error === 'ROOM_NOT_FOUND' ||
        data.error === 'UNAUTHORIZED') {
      console.log('🔌 에러로 인한 WebSocket 연결 해제');
      websocketService.disconnect();
    }
    
    if (onError) {
      onError(data);
    }
  };

  // cleanup: 언마운트 시 확실하게 정리
  return () => {
    if (!isNavigatingToGameRef.current) {
      console.log('🧹 cleanup - WebSocket 연결 해제');
      websocketService.disconnect();
    }
  };
}, [roomId, myUserId]);
```

### 세션 체크 로직 강화

다른 방 입장 시도 시, 프론트엔드 연결 상태도 확인:

```javascript
const handleRoomClick = async (roomId) => {
  // ✅ 프론트엔드 WebSocket 연결 확인
  if (websocketService.isConnected()) {
    console.log('🔌 기존 WebSocket 연결 정리');
    websocketService.disconnect();
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  // 백엔드 세션 체크
  const sessionStatus = await RoomService.checkWsSession();
  if (sessionStatus.active) {
    showAlert('이미 다른 탭에서 게임에 참여 중입니다.');
    return;
  }

  // 입장 허용
  navigate(`/quiz/waiting/${roomId}`);
};
```

---

## 학습 포인트

### 1. 양방향 상태 관리의 어려움

클라이언트-서버 간 실시간 통신에서는 양쪽 모두 상태를 관리한다. 한쪽만 정리하면 불일치가 발생한다.

**교훈:** 상태 변경 시 양쪽 모두 동기화해야 한다.

### 2. 리소스 정리의 중요성

WebSocket, 웹캠, 타이머 등은 명시적으로 정리하지 않으면 메모리 누수가 발생한다.

**교훈:** 사용한 리소스는 반드시 정리해야 한다.

### 3. 타이밍 이슈 디버깅

새로고침 같은 브라우저 이벤트는 여러 단계를 거치며, 각 단계마다 타이밍이 다르다.

**교훈:** 로그를 통해 정확한 시퀀스를 파악해야 한다.

### 4. 에러 핸들링의 책임

에러가 발생하면:
1. 원인 제거 (연결 정리)
2. 사용자 알림 (UI)
3. 상태 복구 (페이지 이동)

순서대로 처리해야 한다.

### 5. UI/UX 일관성

같은 상황(방 종료)에 대해:
- 일반 참가자: AlertModal
- 방장: window.alert

이렇게 다른 UI를 사용하면 혼란스럽다.

**교훈:** 일관된 컴포넌트를 사용해야 한다.

---

## 디버깅 팁

### 1. 연결 상태 로깅

```javascript
console.log('프론트엔드 연결:', websocketService.isConnected());
console.log('백엔드 세션:', await checkSession());
```

### 2. 시퀀스 다이어그램 그리기

문제가 발생하는 순서를 시간 순으로 나열하면 원인을 찾기 쉽다.

### 3. 양방향 검증

- 프론트엔드만 확인하지 말고
- 백엔드 로그도 함께 확인

### 4. 회귀 테스트

- 방장 시나리오
- 일반 참가자 시나리오
- 여러 참가자 시나리오

모두 테스트해야 한다.

---

## 최종 정리

오늘 겪은 문제는 **프론트엔드 WebSocket 연결 정리 누락**으로 인한 세션 불일치였다.
백엔드는 정상적으로 세션을 정리했지만, 프론트엔드는 연결을 유지하고 있어서 다음 방 입장 시 충돌이 발생했다.

핵심 해결책은 **에러 발생 시 페이지 이동 전에 WebSocket 연결을 명시적으로 정리**하는 것이었다.
또한 useEffect cleanup 함수를 통해 컴포넌트 언마운트 시에도 확실하게 정리되도록 개선했다.

이 경험을 통해 실시간 통신에서 **양방향 상태 동기화의 중요성**과 
**리소스 정리의 필수성**을 깊이 이해하게 되었다. 
특히 브라우저 이벤트(새로고침)와 React 생명주기, 서버 이벤트 처리가 
복잡하게 얽혀있는 상황에서는 정확한 시퀀스 파악과 단계별 로깅이 문제 해결의 핵심임을 배웠다.
