# 🗓️ 2025년 7월 30일 TIL

## 키워드
- CascadeType, flush(), clear(), Orphan Removal, N+1 문제, Fetch Join, 다대다 관계


CascadeType.REMOVE
- CascadeType
  * PERSIST : 부모가 갱신되면 자식도 같이 갱신된다.
  - 부모의 리스트에 자식을 추가하거나 제거하면
  데이터베이스에도 반영된다.

  * REMOVE : 부모가 제거되면 자식도 같이 제거된다.
  - ON DELETE CASCADE

  * ALL : 위의 내용을 전부 포함

CascadeType.REMOVE 테스트
```java
@Test
@DisplayName("부서가 제거되면 CASCADE REMOVE에 의해 해당 부서 사원이 모두 삭제된다")
void cascadeTest() {
    //given
    Long deptId = 1L;
    //when
    departmentRepository.deleteById(deptId);
    //then
}
```

CascadeType.PERSIST 테스트
```java
@Test
@DisplayName("양방향 매핑 리스트에서 사원을 추가하면 DB에도 INSERT된다")
void persistTest() {
    //given
    // 부서 조회
    Department department = departmentRepository.findById(2L).orElseThrow();
    // 새로운 사원 생성
    Employee employee = Employee.builder()
            .name("파이리")
//                .department(department)
            .build();
    //when
    // 사원을 생성할 때 부서 세팅을 생략했을 경우를 방지, 편의 메서드
    department.addEmployee(employee);
    
    em.flush();
    em.clear();

    //then
    Employee foundEmp = employeeRepository.findById(5L).orElseThrow();
    System.out.println("foundEmp = " + foundEmp);
    System.out.println("foundEmp.getDepartment() = " + foundEmp.getDepartment());
}

public class Department {
    // ...
    
    // 양방향 매핑 리스트에 사원을 추가할 때 사용할 편의 메서드
    public void addEmployee(Employee employee) {
        employee.setDepartment(this);
        this.employees.add(employee);
    }
}

```

em.flush()
- **영속성 컨텍스트(Persistence Context)**에 쌓여 있는 변경사항을 **DB에 즉시 반영(반영만!)**
- 트랜잭션을 커밋하지는 않아요. 즉, 데이터는 DB에 기록되지만 아직 확정(commit)은 아님
필요한 때
- 테스트 중간에 현재까지의 변경사항을 DB에 확실히 반영시키고 싶을 때

em.clear()
- **영속성 컨텍스트(1차 캐시)**를 완전히 초기화
- 지금까지 저장하거나 조회한 모든 객체를 `JPA`가 더 이상 추적하지 않게 만들어버림
필요한 때
- 캐시된 엔티티가 아닌, 진짜 DB에 있는 데이터를 다시 읽고 싶을 때
- 다음 조회 시 진짜 DB에서 SELECT 하게 만듦
- 엔티티를 **detach(분리)**시키는 효과 (JPA는 이 객체의 변화를 추적하지 않음)

---


고아 객체 삭제 (Orphan Removal)
- `@OneToMany`나 `@OneToOne` 어노테이션에 `orphanRemoval=true` 속성을 설정
- 부모 엔티티에서 자식 엔티티와의 관계를 끊기만 해도,
  자식 엔티티가 DB에서도 완전히 삭제되는 기능

```java
@Test
@DisplayName("양방향 매핑 리스트에서 사원을 제거하면 실제 DB에서 DELETE된다")
void orphanRemovalTest() {
    //given
    // 1번 부서 조회
    Department foundDept = departmentRepository.findById(1L).orElseThrow();

    // 1번 부서의 모든 사원 조회
    List<Employee> employees = foundDept.getEmployees();
    employees.forEach(System.out::println);

    // 1번 사원을 지우고 싶음
    employees.remove(0);

    //when

    //then
}

```

- 앞으로는 `@OneToMany` 애너테이션에는 아래와 같이 붙임.
- @OneToMany(mappedBy = "goods", cascade = CascadeType.ALL, orphanRemoval = true)

---

N+1 문제 및 Fetch Join


게시물과 게시물에 달린 댓글을 보고싶을때
`SQL`에서는 `LEFT OUTER JOIN`을 사용해서 데이터를 가져옴
게시물에 댓글이 3개 달려있으면 게시물도 3번 봐야하는 문제가 있음.
```sql
SELECT
  P.POST_ID,
  P.CONTENT,
  C.COMMENT_ID,
  C.COMMENT_TEXT
FROM POSTS P
LEFT JOIN COMMENTS C
ON P.POST_ID = C.POST_ID
ORDER BY P.POST_ID
;
```
이는 자바 입장에서 보자면 댓글 3개는 `List`로 처리하면 됨.


자바에선 게시물 목록부터 조회 - 조회 횟수 1회
```sql
SELECT
  P.POST_ID,
  P.CONTENT
FROM POSTS P
ORDER BY P.POST_ID
;
```

게시물 개수가 100개라면
각각의 게시물의 댓글을 조회하기 위해 100번의 조회가 실행되어야 함.
```sql
-- 1번 피드에 달린 댓글 조회
SELECT
  C.COMMENT_ID,
  C.COMMENT_TEXT
FROM COMMENTS C
WHERE C.POST_ID = 1
;
--- 다음은 2번, 3번, ...
```

결국 100 + 1, N + 1의 문제가 발생 (너무 많은 쿼리를 실행)

이를 해결하기 위해서 자바에서는 임의로 Fetch Join을 만들었음
Fetch Join은 JPQL로만 작성 가능

```java
public interface DepartmentRepository
    extends JpaRepository<Department, Long> {

    // N + 1 문제 해결을 위한 fetch join 사용
    @Query("SELECT d FROM Department d JOIN FETCH d.employees")
    List<Department> findAllByFetch();
}
```
- `Department` 엔티티와 `Employee` 엔티티를 `Join`하여,
- `Department` 엔티티를 로드하는 동시에 `Employee` 엔티티도 함께 로드
- 이로 인해 N + 1 쿼리 문제를 해결

```java
@Test
@DisplayName("N + 1 문제 해결을 위한 fetch join")
void fetchJoinTest() {
    //given

    //when
    List<Department> departments = departmentRepository.findAllByFetch();
    //then
    departments.forEach(d -> {
        System.out.println("d + d.getEmployees() = " + d + d.getEmployees());
    });
}
```

---


다대다 관계

    상품 N    :        M  회원

              1  주문 1

    - 다대다 관계는 이 관계를 1대 다와 다대 1로 풀어줄 
      중간테이블이 필요함

    1개의 상품(청소기)  여러명의 회원이 주문할 수 있음
    한명의 회원은  여러 상품을 주문할 수 있음

    [ 상품 ]
    상품번호        상품명        
       1            에어컨                
       2            청소기            
    [ 주문 ]
    상품번호       회원번호
        1              1
        1              2
        2              1

    [ 회원 ]
    회원번호        회원명    
       1            김철수         
       2            박영희         

```java
public class Goods {
    // ...
    @OneToMany(mappedBy = "goods", cascade = CascadeType.ALL, orphanRemoval = true)
    List<Purchase> purchases = new ArrayList<>();
}

public class User {
    // ...
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    List<Purchase> purchases = new ArrayList<>();
}

public class Purchase {
    // ...
  
    // 회원과 상품의 다대다관계 해소를 위해서
    // 중간테이블 Purchase는 회원과 1대N, 상품과 1대N으로 관계를 표현
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;
  
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "goods_id")
    private Goods goods;
}
```

