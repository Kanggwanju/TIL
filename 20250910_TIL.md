# 🗓️ 2025년 9월 10일 TIL



유저 엔티티
구글이나 카카오에서 제공해주는 Id
providerId를 통해 유저를 식별 자체로 만든 id는 사용하지 않는다.


복합 유니크 걸기, 유니크에 이름 붙이고 싶을 때 사용

```java
@Table(
        name = "users",
        uniqueConstraints = {
                @UniqueConstraint(name = "uk_user_email", columnNames = {"email"}),
                @UniqueConstraint(name = "uk_provider_provider_id", columnNames = {"provider", "provider_id"})
        }
)
```


이메일로 찾거나 구글 혹은 카카오가 제공해주는 id로 찾기
```java
Optional<User> findByEmail(String email);
Optional<User> findByProviderId(String providerId);
```


프론트는 자동으로 .env를 읽을 수 있음
근데 백엔드는 그냥 못읽음 그레이들에 종속성 추가
.env는 루트위치에 있어야 함. 거듭 강조하지만 깃허브에 올리면 안됨
```groovy
// Dotenv (.env 자동 로딩)
	implementation 'me.paulschwarz:spring-dotenv:4.0.0'
```


토큰을 변경하면 현재 로그인 한 사람들이 다시 로그인해야함.
변경할 때 조심

토큰은 Json 웹 토큰

토큰 생성에서 커스텀을 할 수 있는 옵션은 claims
- claims 커스텀 클레임(Access Token에 최소한으로 포함)

---

쿠키 관련 기능

지금까지의 로직
클라이언트가 로그인 요청을 하면 서버는 JWT 토큰을 발급해줬음
클라이언트는 그 토큰을 로컬 스토리지에 가지고 있다가 인증이 필요한
요청이 있을 때 JWT 토큰을 서버에 제출함.
근데, 토큰을 로컬 스토리지에 그대로 가지고 있는 것은 XSS 공격에 취약함



앞으로의 로직
쿠키에는 JWT 토큰이 담겨져 있음.
이젠 클라이언트에게 쿠키를 전달, 쿠키는 서버에 요청을 할 때 자동으로 포함됨.
그러므로 클라이언트 측에서 요청을 보낼 때 따로 추가할 필요가 없어짐
서버는 요청에서 쿠키를 파싱하기만 하면 된다.
쿠키는 JS로 가져올 수 없고, 그러므로 JWT 토큰이 안전함.

리프레시 토큰 7일
액세스 토큰 5분
자동로그인은 리프레시 토큰 기준
리프레시 토큰이 만료되면 자동로그인이 끊김


클라이언트에게 쿠키를 전송하는 법 - 쿠키는 서버에서 생성해서 응답메시지에 포함해서 보내야함

```java
@GetMapping("/")
public Map<String, Object> root(HttpServletResponse res) {
    Map<String, Object> response = new HashMap<>();
    response.put("message", "AI Study Mate API Server");
    response.put("status", "running");
    response.put("timestamp", LocalDateTime.now());

    // 클라이언트에게 쿠키를 전송하는 법 - 쿠키는 서버에서 생성해서 응답메시지에 포함해서 보내야함
    Cookie cookie = new Cookie("choco-cookie", "delicious");
    cookie.setDomain("http://localhost");
    cookie.setPath("/feeds"); // 이 쿠키를 어떤 요청에서 사용할지 /feeds를 쓰면 뒤에 ** 자동으로 붙음
    cookie.setMaxAge(30); // 30초의 수명, 보통은 액세스 토큰 만료시간과 맞춤
//        cookie.setHttpOnly(true); // https가 강제됨 나중에 배포할 때 사용

    res.addCookie(cookie); // 클라이언트에게 쿠키 전송

    return response;
}
```

---

쿠키를 삭제하는 방법은
maxAge를 0초로 설정해서 보내주면 된다.

---

SecurityConfig

// 시큐리티 인증 실패 시 401 Unauthorized 반환
// 원래는 403이며 보통 개발자들은 401로 보냄
.exceptionHandling(ex -> ex
    .authenticationEntryPoint((req, res, e) -> res.sendError(401))
);

클라이언트가 보내는 쿠키를 허용하겠다.
configuration.setAllowCredentials(true);

---


JWT 인증 필터
토큰 추출 우선순위:
1) Authorization 헤더의 Bearer 토큰
2) HTTP-Only 쿠키(ACCESS_TOKEN)

쿠키 뜯는건 모든 쿠키 다 가져와서 accessToken 이름과 같은걸 찾아야 함

시큐리티 필터 체인에 JWT 인증 필터 넣는건 파라미터로 주입 가능


프로필 변경하려면
yml 파일 dev 변경 
```yml
spring:
  application:
    name: ai-study-mate
  profiles:
    active: dev
```

build.gradle 파일 dev를 변경
```groovy
// 개발 환경 설정
bootRun {
	args = ['--spring.profiles.active=dev']
}

```

---






카카오 로그인
- https://developers.kakao.com/ 접속해서 API 문서 읽기
- https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api
- Service Client: 내가 만든 리액트 앱
- Service Server: Spring 서버
- Kakao Auth Server: 카카오 서버

리다이렉트 URI: http://localhost:9005/login/oauth2/code/kakao
클라이언트 시크릿 발급, 백업
개인정보 동의항목 필수 설정
REST API 키, 백업
웹플랫폼 등록: http://localhost:9005

yml 설정
```yml
sns:
  appKey: ${KAKAO_CLIENT_ID}
  redirect: http://localhost:9005/login/oauth2/code/kakao
```



## Step 1: 인가 코드 요청
1. Service Client에 카카오 로그인 버튼 배치, 사용자가 클릭, 스프링에 카카오 로그인 요청 날림
2. Spring이 요청 받아서 카카오 서버에 GET 요청

```java
@Controller
@Slf4j
@RequiredArgsConstructor
public class SnsController {

    @Value("${sns.appKey}")
    private String appKey;
    @Value("${sns.redirect}")
    private String redirectUri;

    // 카카오 로그인 인가코드 발급 요청
    @GetMapping("/oauth2/kakao")
    public String kakao() {
        // 카카오 서버로 인가코드 발급 통신을 진행
        String uri = "https://kauth.kakao.com/oauth/authorize";
        uri += "?client_id=" + appKey;
        uri += "&redirect_uri=" + redirectUri;
        uri += "&response_type=code";

        return "redirect:" + uri;
    }
}
```
- 리다이렉트는 그냥 컨트롤러로 해야함
- 카카오 로그인 페이지로 리다이렉트 시켜줌

3. 카카오 서버가 리액트 앱에 로그인 요청 화면 띄워줌
4. 사용자가 카카오 계정 로그인, 동의화면 출력되면 동의

5. 카카오 서버에서 Redirect URI로 인가 코드가 전달 됨(스프링)
설정 된 리다이렉트 URI: http://localhost:9005/login/oauth2/code/kakao
```java
// 인가코드를 전달받는 엔드포인트
@GetMapping("/login/oauth2/code/kakao")
public String kakaoCode(@RequestParam String code) {
    log.info("카카오가 전달한 인가코드 : {}", code);

    return "redirect:/";
}
```

6. 카카오 서버에서 전달받은 인가 코드를 통해 토큰 발급 요청

- Controller에서 Service로 토큰 발급 요청
```java
// 인가코드를 전달받는 엔드포인트
@GetMapping("/login/oauth2/code/kakao")
public String kakaoCode(@RequestParam String code) {
    log.info("카카오가 전달한 인가코드 : {}", code);

    // 토큰 발급 요청하기
    service.kakaoLogin(Map.of(
            "client_id", appKey,
            "redirect_uri", redirectUri,
            "code", code
    ));

    return "redirect:/";
}
```

Service 비즈니스 로직, 토큰 발급
- 시크릿 활성화 해서 `client_secret` 필수
```java
@Service
@Slf4j
@RequiredArgsConstructor
public class SnsService {

    // 카카오로그인 처리 서비스 로직
    public void kakaoLogin(Map<String, Object> params) {

        // 1. 토큰 발급 요청
        String accessToken = getKakaoToken(params);

    }

    // 인가코드로 토큰 발급 요청
    private String getKakaoToken(Map<String, Object> params) {

        // 요청 URI
        String uri = "https://kauth.kakao.com/oauth/token";

        // 요청 헤더 설정
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");

        // 카카오 서버로 POST 요청 보내기 (Server To Server)
        /**
         - RestTemplate 객체가 REST API 통신을 위한 API인데 (자바스크립트 fetch역할)
         - 서버에 통신을 보내면서 응답을 받을 수 있는 메서드가 exchange

         param1: 요청 URL
         param2: 요청 방식 (get, post, put, patch, delete...)
         param3: 요청 헤더와 요청 바디 정보 - HttpEntity로 포장해서 줘야 함
         param4: 응답결과(JSON)를 어떤 타입으로 받아낼 것인지 (ex: DTO로 받을건지 Map으로 받을건지)
         */
        RestTemplate template = new RestTemplate();

        // 요청 파라미터 만들기
        LinkedMultiValueMap<String, Object> valueMap = new LinkedMultiValueMap<>();
        valueMap.add("grant_type", "authorization_code");
        valueMap.add("client_id", params.get("client_id"));
        valueMap.add("redirect_uri", params.get("redirect_uri"));
        valueMap.add("code", params.get("code"));
        valueMap.add("client_secret", params.get("client_secret"));

        HttpEntity<Object> entity = new HttpEntity<>(valueMap, headers);

        ResponseEntity<Map> response
                = template.exchange(uri, HttpMethod.POST, entity, Map.class);

        log.info("response data: {}", response);

        Map<String, Object> responseBody = response.getBody();
        String accessToken = (String) responseBody.get("access_token");
        log.info("token: {}", accessToken);

        return accessToken;
    }
}
```

7. 발급한 토큰으로 사용자 정보 가져오기
```java
// 토큰으로 사용자 정보 조회
private void getKakaoUserInfo(String accessToken) {

    // request uri
    String requestUri = "https://kapi.kakao.com/v2/user/me";

    // 헤더 설정
    HttpHeaders headers = new HttpHeaders();
    headers.add("Authorization", "Bearer " + accessToken);
    headers.add("Content-type", "application/x-www-form-urlencoded;charset=utf-8");

    // 요청 보내기
    RestTemplate template = new RestTemplate();
    ResponseEntity<KaKaoUserDto> response = template.exchange(
            requestUri
            , HttpMethod.POST
            , new HttpEntity<>(headers)
            , KaKaoUserDto.class
    );

    KaKaoUserDto responseBody = response.getBody();
    log.info("user info: {}", responseBody);

    String nickname = responseBody.getProperties().getNickname();
    String profileImage = responseBody.getProperties().getProfileImage();

    // DB 저장

}
```