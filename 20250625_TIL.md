# 🗓️ 2025년 6월 25일 TIL


메서드

자바는 함수라는 개념이 없음
메서드: 객체가 가진 기능
메서드를 정의할 수 있는 위치는 클래스 내부, 메서드 외부

---

리턴되는 변수 타입을 메서드 이름 앞에 써줌
변수를 담을 때 쓸 타입을 생각하면 쉽게 생각 가능.
리턴이 없으면 void를 쓰면 된다.

바이트 + 바이트 = 인트
인트보다 작은 것들의 합은 인트가 된다는 걸 기억해야함.

파라미터에 int... numbers로 하면
배열로 받거나 여러가지 숫자를 전달 받으면
자기가 스스로 배열로 묶어줌.

하지만 배열 2개를 전달받을 때는 ...을 사용하면 안된다.

...은 배열 1개만 전달받을 때 사용.




여러개를 리턴하고 싶을 때는
`return new int[] { n1 + n2, n1 - n2 };`
배열로 묶어서 리턴해주고
메서드의 타입은 int[]가 된다.


배열 modify 메서드
1. 변경할 위치 인덱스와 문자열을 파라미터로 받음
2. 배열의 인덱스 범위에 해당하는지 확인(idx < 0 || idx >= 배열길이)하여 다르다면 return
3. tempArray의 인덱스번째 요소를 전달받은 문자열로 변경

배열 insert 메서드
1. 삽입할 위치 인덱스와 문자열을 파라미터로 받음
2. 배열의 인덱스 범위에 해당하는지 확인 (idx < 0 || idx >= 배열길이)하여 다르다면 return
3. 원본 배열의 길이보다 1이 큰 tempArr 생성
4. for 문을 통해 원본 배열의 내용을 tempArr에 복사
5. tempArr는 원본 배열보다 길이가 1이 크므로 삽입할 위치 인덱스 전까지 for 문을 통해 뒤로 한 칸씩 빼서 복사하는 과정을 거침
6. 삽입 위치 인덱스에 삽입 문자열을 넣어줌.
7. tempArr의 주소를 원본 배열에 전달함.

배열 pop 메서드
1. 메서드를 적용할 배열의 길이가 0이라면 제거 할 수 없음을 알리며 return null
2. String deleted에 배열의 가장 끝 요소를 넣어줌
3. 원본 배열보다 길이가 1이 작은 tempArr 생성
4. tempArr의 길이만큼 for 문을 돌려서 원본 배열의 값들을 넣어줌
5. tempArr의 주소를 원본 배열에 전달함.
6. return deleted;

배열 push 메서드
1. `String... items`를 파라미터로 받음 (여러 문자열을 한번에 받기 위함)
2. 원본 배열보다 길이가 items.length 만큼 더 큰 tempArr 생성
3. for 문을 통해 원본 내용을 tempArr에 복사
4. tempArr의 맨 끝에 items의 데이터 추가
5. 주소값 이전 (tempArr의 주소를 원본 배열에 전달)

배열 indexOf 메서드
1. 인덱스를 찾을 문자열을 파라미터로 받음
2. 원본 배열의 길이만큼 for 문을 진행하는데, 만약 for 문에서 원본 배열의 i 번째 데이터가 파라미터와 같다면 i를 리턴함
3. for 문이 끝나도 return이 되지 않는다면 return -1;

include 메서드
1. 포함되어있는지 찾을 문자열을 파라미터로 받음
2. indexOf에 파라미터로 받은 문자열을 넣어서 실행함.
3. indexOf의 값이 -1 아니면 true, -1이면 false를 반환

배열 remove 메서드
1. 삭제할 문자열을 파라미터(String targetItem)로 받음
2. if 문을 통해 조건으로 !include(targetItem)을 넣어서 if문이 실행되면 return;
3. 2번을 다시 말하자면, targetItem이 없다면 return 함.
4. for 문을 진행, int i = indexOf(targetItem); i < foods.length - 1; i++로 원본 배열[i] = 원본 배열[i + 1];을 해줌.
5. 4번을 풀어서 말하면 targetItem의 인덱스에서 시작해서 원본 배열의 길이 - 1 까지 한 칸씩 앞으로 당겨와서 targetItem을 배열에서 없애는 효과
6. pop 메서드 실행


오버로딩: 같은 이름의 메서드를 계속 만드는 행위
## 🧩 오버로딩 (Overloading)

> **같은 이름의 메서드를 매개변수를 다르게 하여 여러 개 정의하는 것**

| 구분     | 오버로딩 (Overloading)         |
| ------ | -------------------------- |
| 의미     | **같은 이름, 다른 매개변수의 메서드 정의** |
| 위치     | 같은 클래스 내 (또는 상속받은 클래스 내)   |
| 메서드 이름 | 같아야 함                      |
| 매개변수   | **개수나 타입이 달라야 함**          |
| 반환 타입  | 달라도 상관없음                   |
| 대표 예시  | 코드의 편의성 향상                 |


### ✅ 왜 쓸까?

비슷한 기능인데 **입력값이 다를 때**, 같은 이름으로 코드를 깔끔하게 관리하려고 사용

### ✅ 조건

* 메서드 이름은 같아야 함
* 매개변수의 **개수, 타입, 순서 중 하나 이상이 달라야 함**
* 반환 타입은 달라도 되지만, **반환 타입만 다른 것은 오버로딩이 아님**

### ✅ 예시

```java
class Calculator {
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }
}
```

---

```java
public static void main(String[] args) {
    remove("치킨");
    remove(0);
}

static void remove(int idx) {
    //...내용
}

static void remove(String menu) {
    //...내용
}
```



객체와 클래스

class: 객체를 찍어내는 틀(설계도)
설계도 클래스들은 main 메서드를 만들지 않음.
설계도를 실행 시켜봤자 의미가 없기 때문.
dancer 클래스
`public class Dancer{ }`

객체의 속성과 기능

속성(필드): 객체를 명사적으로 표현하는 데이터
변수 아님. 객체의 속성(필드)이다.
```java
String dancerName; // 댄서 이름
String crewName; // 소속 크루 이름
String[] genres; // 장르
int danceLevel; // 0: 초보, 1: 아마추어, 2: 프로
```

기능(메서드): 객체를 동사적으로 표현하는 함수
설계도에 있는 함수는 static을 붙이지 않음

```java
// 춤추는 기능
void dance() {
    System.out.printf("%s 댄서가 %s춤을 춥니다.\n", dancerName, genres[0]);
}

// 자기소개 기능
void introduce() {
    System.out.println("이름: " + dancerName);
    System.out.println("팀명: " + crewName);
    System.out.println("장르: " + Arrays.toString(genres));
    System.out.println("레벨: " + danceLevel);
}
```




데이터 타입: 데이터를 담는 그릇
기본 데이터 타입: byte, short, int, long...

설계도(class)를 가져와서 객체(instance)를 찍어낸다.
클래스 이름을 타입 그대로 사용
객체 생성 코드
`Dancer park = new Dancer();`

생성자
- 클래스 내부에 클래스 이름과 완벽히 동일하게 작성
- 객체가 생성될 때 자동 실행되는 특수 메서드
- 하는 일: 객체의 초기값을 세팅
- 무조건 주소값 자동 리턴 그래서 안써도됨
```java
Dancer() {
    System.out.println("댄서의 1번 생성자 호출!");
    dancerName = "무명의댄서";
    crewName = "잡크루";
    genres = new String[] {};
    danceLevel = 1;
}
```

생성자 오버로딩
- 생성자는 여러개 만들 수 있음
- 규칙: 파라미터가 달라야 함.

```java
Dancer(String dName) {
    System.out.println("2번 생성자 호출!");
    dancerName = dName;
    crewName = "똥크루";
    genres = new String[] {"힙합"};
    danceLevel = 0;
}

// 파라미터를 받을 때 ...은 항상 제일 뒤에 있어야 한다.
Dancer(String dName, String cName, int dLevel, String... settingGenres) {
    System.out.println("5번 생성자 호출!");
    dancerName = dName;
    crewName = cName;
    genres = settingGenres; // ...하면 알아서 배열로 처리됨
    danceLevel = dLevel;
}
```
```java
public static void main(String[] args) {
    Dancer stephanie = new Dancer("천무스테파니", "춤신춤왕", 2, "스트릿", "힙합");
    /*
        const stephanie = {
            dancerName: "천무스테파니",
            crewName: "춤신춤왕",
            genres: ["스트릿", "힙합"],
            danceLevel: 2,
            introduce: () => {}
        };
     */
}
```




소멸자는 없음.
