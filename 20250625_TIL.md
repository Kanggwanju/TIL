# 🗓️ 2025년 6월 25일 TIL


메서드

자바는 함수라는 개념이 없음
메서드: 객체가 가진 기능
메서드를 정의할 수 있는 위치는 클래스 내부, 메서드 외부

---

리턴되는 변수 타입을 메서드 이름 앞에 써줌
변수를 담을 때 쓸 타입을 생각하면 쉽게 생각 가능.
리턴이 없으면 void를 쓰면 된다.

바이트 + 바이트 = 인트
인트보다 작은 것들의 합은 인트가 된다는 걸 기억해야함.

파라미터에 int... numbers로 하면
배열로 받거나 여러가지 숫자를 전달 받으면
자기가 스스로 배열로 묶어줌.

하지만 배열 2개를 전달받을 때는 ...을 사용하면 안된다.

...은 배열 1개만 전달받을 때 사용.




여러개를 리턴하고 싶을 때는
`return new int[] { n1 + n2, n1 - n2 };`
배열로 묶어서 리턴해주고
메서드의 타입은 int[]가 된다.


배열 modify 메서드
1. 변경할 위치 인덱스와 문자열을 파라미터로 받음
2. 배열의 인덱스 범위에 해당하는지 확인(idx < 0 || idx >= 배열길이)하여 다르다면 return
3. tempArray의 인덱스번째 요소를 전달받은 문자열로 변경

배열 insert 메서드
1. 삽입할 위치 인덱스와 문자열을 파라미터로 받음
2. 배열의 인덱스 범위에 해당하는지 확인 (idx < 0 || idx >= 배열길이)하여 다르다면 return
3. 원본 배열의 길이보다 1이 큰 tempArr 생성
4. for 문을 통해 원본 배열의 내용을 tempArr에 복사
5. tempArr는 원본 배열보다 길이가 1이 크므로 삽입할 위치 인덱스 전까지 for 문을 통해 뒤로 한 칸씩 빼서 복사하는 과정을 거침
6. 삽입 위치 인덱스에 삽입 문자열을 넣어줌.
7. tempArr의 주소를 원본 배열에 전달함.

배열 pop 메서드
1. 메서드를 적용할 배열의 길이가 0이라면 제거 할 수 없음을 알리며 return null
2. String deleted에 배열의 가장 끝 요소를 넣어줌
3. 원본 배열보다 길이가 1이 작은 tempArr 생성
4. tempArr의 길이만큼 for 문을 돌려서 원본 배열의 값들을 넣어줌
5. tempArr의 주소를 원본 배열에 전달함.
6. return deleted;

배열 push 메서드
1. `String... items`를 파라미터로 받음 (여러 문자열을 한번에 받기 위함)
2. 원본 배열보다 길이가 items.length 만큼 더 큰 tempArr 생성
3. for 문을 통해 원본 내용을 tempArr에 복사
4. tempArr의 맨 끝에 items의 데이터 추가
5. 주소값 이전 (tempArr의 주소를 원본 배열에 전달)

배열 indexOf 메서드
1. 인덱스를 찾을 문자열을 파라미터로 받음
2. 원본 배열의 길이만큼 for 문을 진행하는데, 만약 for 문에서 원본 배열의 i 번째 데이터가 파라미터와 같다면 i를 리턴함
3. for 문이 끝나도 return이 되지 않는다면 return -1;

include 메서드
1. 포함되어있는지 찾을 문자열을 파라미터로 받음
2. indexOf에 파라미터로 받은 문자열을 넣어서 실행함.
3. indexOf의 값이 -1 아니면 true, -1이면 false를 반환

배열 remove 메서드
1. 삭제할 문자열을 파라미터(String targetItem)로 받음
2. if 문을 통해 조건으로 !include(targetItem)을 넣어서 if문이 실행되면 return;
3. 2번을 다시 말하자면, targetItem이 없다면 return 함.
4. for 문을 진행, int i = indexOf(targetItem); i < foods.length - 1; i++로 원본 배열[i] = 원본 배열[i + 1];을 해줌.
5. 4번을 풀어서 말하면 targetItem의 인덱스에서 시작해서 원본 배열의 길이 - 1 까지 한 칸씩 앞으로 당겨와서 targetItem을 배열에서 없애는 효과
6. pop(); 실행


오버로딩: 같은 이름의 메서드를 계속 만드는 행위
```java
remove("치킨");
remove(0);

static void remove(int idx) {
    //...내용
}

static void remove(String menu) {
    //...내용
}
```


dancer
설계도 클래스들은 main 메서드를 만들지 않음.
설계도를 실행 시켜봤자 의미가 없기 때문.


객체의 속성과 기능
속성(필드): 객체를 명사적으로 표현하는 데이터
```java
// 변수 아님. 객체의 속성(필드)이다.
String dancerName; // 댄서 이름

// 메서드
void foo() {
    // 메서드 내부 변수
    String dancerName;
}
```





데이터 타입: 데이터를 담는 그릇
기본 데이터 타입: byte, short, int, long...

설계도(class)를 가져와서 객체(instance)를 찍어낸다.
클래스 이름을 타입 그대로 사용
객체 생성 코드
`Dancer park = new Dancer();`

생성자
- 클래스 내부에 클래스 이름과 완벽히 동일하게 작성
- 객체가 생성될 때 자동 실행되는 특수 메서드
- 하는 일: 객체의 초기값을 세팅
- 무조건 주소값 자동 리턴 그래서 안써도됨
```java
Dancer() {
    System.out.println("댄서의 1번 생성자 호출!");
    dancerName = "무명의댄서";
    crewName = "잡크루";
    genres = new String[] {};
    danceLevel = 1;
}
```

생성자 오버로딩
- 생성자는 여러개 만들 수 있음
- 규칙: 파라미터가 달라야 함.

파라미터를 받을 때 ...은 항상 제일 뒤에 있어야 한다.
Dancer(String dName, String cName, int dLevel, String... settingGenres)

소멸자는 없음.
