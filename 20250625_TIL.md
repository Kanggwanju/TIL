# 🗓️ 2025년 6월 25일 TIL

리턴되는 변수 타입을 함수 이름 앞에 써줌
변수를 담을 때 쓸 타입을 생각하면 쉽게 생각 가능.
리턴이 없으면 void를 쓰면 된다.

바이트 + 바이트 = 인트
인트보다 작은 것들의 합은 인트가 된다.

파라미터에 int... numbers로 하면
배열로 받거나 여러가지 숫자를 전달 받으면
자기가 스스로 배열로 묶어줌.

하지만 배열 2개를 전달받을 때는 ...을 사용하면 안된다.

...은 배열 1개만 전달받을 때 사용.




여러개를 리턴하고 싶을 때는
`return new int[] { n1 + n2, n1 - n2 };`
배열로 묶어서 리턴해주고
함수의 타입은 int[]가 된다.


오버로딩: 같은 이름의 메서드를 계속 만드는 행위
```java
remove("치킨");
remove(0);

static void remove(int idx) {
    //...내용
}

static void remove(String menu) {
    //...내용
}
```


dancer
설계도 클래스들은 main 메서드를 만들지 않음.
설계도를 실행 시켜봤자 의미가 없기 때문.


객체의 속성과 기능
속성(필드): 객체를 명사적으로 표현하는 데이터
```java
// 변수 아님. 객체의 속성(필드)이다.
String dancerName; // 댄서 이름

// 메서드
void foo() {
    // 메서드 내부 변수
    String dancerName;
}
```





데이터 타입: 데이터를 담는 그릇
기본 데이터 타입: byte, short, int, long...

설계도(class)를 가져와서 객체(instance)를 찍어낸다.
클래스 이름을 타입 그대로 사용
객체 생성 코드
`Dancer park = new Dancer();`

생성자
- 클래스 내부에 클래스 이름과 완벽히 동일하게 작성
- 객체가 생성될 때 자동 실행되는 특수 메서드
- 하는 일: 객체의 초기값을 세팅
- 무조건 주소값 자동 리턴 그래서 안써도됨
```java
Dancer() {
    System.out.println("댄서의 1번 생성자 호출!");
    dancerName = "무명의댄서";
    crewName = "잡크루";
    genres = new String[] {};
    danceLevel = 1;
}
```

생성자 오버로딩
- 생성자는 여러개 만들 수 있음
- 규칙: 파라미터가 달라야 함.

파라미터를 받을 때 ...은 항상 제일 뒤에 있어야 한다.
Dancer(String dName, String cName, int dLevel, String... settingGenres)

소멸자는 없음.
