# 🗓️ 2025년 7월 29일 TIL

## 📌 오늘의 키워드

* `@Query` (JPQL / Native SQL)
* JPA 연관관계 (`@OneToOne`, `@OneToMany`, `@ManyToOne`)
* 연관관계의 주인 개념
* 단방향 vs 양방향 매핑
* Lazy Loading vs Eager Loading
* 양방향 매핑 시 편의 메서드와 동기화 처리


## 📌 Spring Data JPA - `@Query` 어노테이션

### 🔹 `@Query`란?

* **복잡한 쿼리**를 직접 작성하고 싶을 때 사용
* `JPQL` 또는 `Native SQL`을 사용할 수 있음

---

### 📘 JPQL 사용

* **JPQL(Java Persistence Query Language)**: SQL과 비슷하지만, **엔티티 기준으로 동작**
* `@Query` 어노테이션으로 직접 작성 가능
* 엔티티 클래스와 필드를 직접 참조하여 쿼리를 작성 가능

```java
public interface StudentRepository extends JpaRepository<Student, String> {
    // 도시 이름으로 학생 조회하기
    @Query(value = "SELECT s FROM Student s WHERE s.city = ?1")
    List<Student> getStudentByCity(String city);
}
```

🔹 특징

* `SELECT *` → `SELECT s`
* `FROM` 뒤에는 **엔티티 이름** 사용, **별칭(alias)** 필수
* `WHERE` 조건은 `?1`, `?2`처럼 **파라미터 순서**로 지정

---

### 📗 Native SQL 사용

* 복잡하거나 DB에 특화된 쿼리를 사용할 때
* `@Query`에 `nativeQuery = true` 설정

```java
@Query(value = """
    SELECT *
    FROM tbl_student
    WHERE city = ?1
      AND stu_name = ?2
""", nativeQuery = true)
List<Student> getStudents(String city, String name);
```

---

## 🔗 JPA 연관관계 매핑

### 📍 1:1 - `@OneToOne`

```java
@Entity
public class User {
    @OneToOne
    private Profile profile;
}
```

---

### 📍 1\:N - `@OneToMany`

```java
@Entity
public class Department {
    @OneToMany(mappedBy = "department")
    private List<Employee> employees = new ArrayList<>();
}
```

---

### 📍 N:1 - `@ManyToOne`

```java
@Entity
public class Employee {
    @ManyToOne
    @JoinColumn(name = "dept_id") // FK를 포함시키는건 DB 패러다임에 맞춰야함
    private Department department; // 부서정보 통째로 포함
}
```

---

## 🔄 단방향 vs 양방향 연관관계

### 🔹 단방향

한 쪽만 참조 (ex: `Post` → `User`)

```java
@Entity
public class Post {
    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
}
```

---

### 🔹 양방향

양쪽 모두 참조 (ex: `User` ↔ `Post`)

```java
@Entity
public class User {
    @OneToMany(mappedBy = "user")
    private List<Post> posts;
}

@Entity
public class Post {
    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
}
```

✔️ **연관관계의 주인**: 외래 키가 있는 쪽 (`Post`가 주인)
✔️ `mappedBy` 속성 없이 어노테이션을 선언하는 쪽이 주인
✔️ `mappedBy`는 **반대쪽 필드명**을 지정

---

## 💤 지연 로딩(Lazy Loading) vs 즉시 로딩(Eager Loading)

### Lazy Loading
- 연관된 엔티티를 실제로 사용할 때까지 로드를 지연시키는 방식
- 연관된 엔티티가 필요하지 않은 경우 불필요한 데이터베이스 접근을 방지

### Eager Loading
- 연관된 엔티티를 부모 엔티티가 로드되는 시점에 함께 로드하는 방식
- 성능 저하 가능성 있음

```java
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "dept_id")
private Department department;
```
- `FetchType.LAZY`: 필요없을 때는 조인을 하지 않는 전략
- `@ManyToOne`, 양방향 매핑은 무조건 LAZY를 거는게 좋음


⚠️ **ToString 순환참조 주의**

```java
@ToString(exclude = {"department"})
```
- `ToString`에서 department 정보 안찍음
- exclude가 없는 상태에서 Employee 객체를 toString()으로 찍으면
- 데이터베이스에 접근하여 정보를 가져올 때 `department` 때문에 join을 하게됨
- 연관 관계 필드는 순환참조 방지를 위해 제외해야 함

---

## 🔄 양방향 매핑

- 양방향 매핑은 데이터베이스와 달리 객체지향 시스템에서 가능한 방법으로
  1대N관계에서 1쪽에 N데이터를 포함시킬 수 있는 방법이다.

- 양방향 매핑에서 1쪽은 상대방 엔터티 갱신에 관여 할 수 없고
  (리스트에서 사원을 지운다고 실제 디비에서 사원이 삭제되지는 않는다는 말)
  단순히 읽기전용 (조회전용)으로만 사용하는 것이다.

- mappedBy에는 상대방 엔터티에 @ManyToOne에 대응되는 필드명을 꼭 적어야 함

- 필드 초기화를 안 해주므로, 직접 초기화 해줘야 한다.

```java
@ToString(exclude = {"employees"})
@Entity
@Table(name = "tbl_dept")
public class Department {
    @OneToMany(mappedBy = "department")
    private List<Employee> employees = new ArrayList<>();
}
```
@ToString(exclude = {"employees"})
- 연관관계 필드는 순환참조 방지를 위해 제외해야 함

@OneToMany(mappedBy = "department")
- @OneToMany는 기본이 Lazy Loading
- mappedBy에는 상대방 엔터티에 @ManyToOne에 대응되는 필드명을 꼭 적어야 함

private List<Employee> employees = new ArrayList<>();
- 필드 초기화를 안 해주므로, 직접 초기화


---

## ✍️ 양방향 연관관계 설정에서 UPDATE문 처리시 주의사항

`JPA`에서 엔티티 수정 방법
- 수정하려는 엔티티를 찾음
- 해당 엔티티의 속성을 변경한 다음 `save()` 메서드를 호출
- `JPA`는 트랜잭션이 종료될 때 변경된 내용을 데이터베이스에 반영

- 하지만 양방향 연관관계에서는 한 쪽 엔티티만 변경하면 다른 쪽은 변경되지 않음
- 이러한 현상을 객체와 데이터베이스 간의 `불일치 문제`라고 함.

### 예시: 사원의 부서를 변경

```java
@Test
void changeTest() {
    // 목표: 3번 사원의 부서를 2번 부서에서 1번 부서로 수정
    // 3번 사원 조회
    Employee foundEmp = employeeRepository.findById(3L).orElseThrow();
    // 1번 부서 조회
    Department foundDept = departmentRepository.findById(1L).orElseThrow();
    // 사원쪽에서 부서정보 변경
    // + 양방향에서는 반대편에서도 수동으로 변경처리가 진행되어야 함.
    // 연관관계 양방향 수정 편의메서드
    foundEmp.changeDepartment(foundDept);
    
    employeeRepository.save(foundEmp);
}
```
```java
public class Employee {
    // 부서 변경 편의 메서드
    public void changeDepartment(Department department) {
        // ManyToOne 필드가 변경이 일어나면 반대편쪽의 OneToMany도 같이 갱신
        this.department = department;
        if (department != null) {
            department.getEmployees().add(this);
        }
    }
}
```

✔️ 연관관계 양쪽을 모두 수동으로 변경해주는 **편의 메서드**는 꼭 만들어두면 좋아요!

---

## 🧠 요약

| 주제              | 핵심 요약                            |
| --------------- | -------------------------------- |
| `@Query`        | JPQL 또는 Native SQL로 복잡한 쿼리 작성 가능 |
| 연관관계 주인         | 외래 키를 가진 쪽 (예: `@ManyToOne`)     |
| 양방향 매핑          | `mappedBy` 설정 필수, 편의 메서드로 양쪽 동기화 |
| Lazy 로딩         | 필요할 때만 로드 → 성능상 이점               |
| `ToString` 순환참조 | `@ToString(exclude = ...)` 필수    |

