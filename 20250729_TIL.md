# 🗓️ 2025년 7월 29일 TIL


Spring Data JPA @Query 어노테이션
- @Query 어노테이션을 사용하여 Repository 인터페이스에 복잡한 쿼리를 직접 작성할 수 있음
- @Query 어노테이션에는 JPQL (Java Persistence Query Language) 또는 Native SQL을 사용할 수 있음

@Query와 JPQL
- JPQL은 SQL을 기반으로 하되, 엔티티 객체를 대상으로 하는 쿼리 언어
- 엔티티 클래스와 필드를 직접 참조하여 쿼리를 작성 가능

JPQL 예시
```java
public interface StudentRepository extends JpaRepository<Student, String> {
    // 도시 이름으로 학생 조회하기
    @Query(value = "SELECT s FROM Student s WHERE s.city = ?1")
    List<Student> getStudentByCity(String city);
}
```
FROM 뒤에 엔티티 이름을 적어주어야 하며, 반드시 별칭을 정해줘야한다.
WHERE 절의 조건을 걸 때는 ?뒤에 파라미터의 순번대로 넣어줌
SQL 문법에서 `SELECT *` = JPQL의 `SELECT s`
---

@Query와 Native SQL
- 데이터베이스에 특화된 복잡하고 최적화된 쿼리를 작성
- `@Query` 어노테이션에 `nativeQuery` 속성을 `true`로 설정

Native SQL 사용 예시
```java
public interface StudentRepository extends JpaRepository<Student, String> {
    // 도시 AND 이름으로 학생 조회하기
    @Query(value = """
            SELECT *
            FROM tbl_student
            WHERE city = ?1
                AND stu_name = ?2
            """, nativeQuery = true)
    List<Student> getStudents(String city, String name);
}
```
- 파라미터 순서에 따라 WHERE ?뒤 숫자 달라짐

---

## JPA 연관관계 설정
- 엔티티 간의 관계를 설정하여 데이터베이스의 관계형 모델을 객체 지향적으로 표현

@OneToOne
- 한 엔티티가 다른 엔티티와 1:1로 연결된 경우
```java
@Entity
public class User {
    @Id
    @GeneratedValue
    private Long id;

    @OneToOne
    private Profile profile;
}

```
---
@OneToMany
- 한 엔티티가 여러 엔티티와 연결된 경우
```java
@Entity
@Table(name = "tbl_dept")
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "dept_id")
    private Long id; // 부서번호

    @Column(name = "dept_name", nullable = false)
    private String name; // 부서명
    
    @OneToMany(mappedBy = "department")
    private List<Employee> employees = new ArrayList<>();
}
```
---
@ManyToOne
- 여러 엔티티가 한 엔티티와 연결된 경우
```java
@Entity
@Table(name = "tbl_emp")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "emp_id")
    private Long id; // 사원번호

    @Column(name = "emp_name", nullable = false)
    private String name; // 사원명
    
    @ManyToOne
    @JoinColumn(name = "dept_id") // FK를 포함시키는건 DB 패러다임에 맞춰야함
    private Department department; // 부서정보 통째로 포함
}
```
---

## JPA 연관 관계: 단방향, 양방향, 연관 관계의 주인

### 단방향 연관 관계
- 한 쪽 엔티티만 다른 쪽 엔티티를 참조하는 관계
- `User` 엔티티는 `Post` 엔티티를 참조할 수 없음.
```java
@Entity
public class Post {
    @Id
    @GeneratedValue
    private Long id;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
}
```

### 양방향 연관 관계
- 서로가 서로를 참조하는 관계
- 양쪽 엔티티 모두 관련된 엔티티를 조회할 수 있음
```java
@Entity
public class User {
    @Id
    @GeneratedValue
    private Long id;

    @OneToMany(mappedBy = "user")
    private List<Post> posts = new ArrayList<>();
}

@Entity
public class Post {
    @Id
    @GeneratedValue
    private Long id;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
}

```

### 연관 관계의 주인
- 양방향 연관 관계에서 JPA가 연관 관계를 관리하는 주체를 지정하는 것을 의미
- 외래 키가 있는 쪽을 연관 관계의 주인으로 설정
- `mappedBy` 속성 없이 어노테이션을 선언하는 쪽이 주인

---


## JPA Lazy Loading vs Eager Loading

### Lazy Loading
- 연관된 엔티티를 실제로 사용할 때까지 로드를 지연시키는 방식
- 연관된 엔티티가 필요하지 않은 경우 불필요한 데이터베이스 접근을 방지

### Eager Loading
- 연관된 엔티티를 부모 엔티티가 로드되는 시점에 함께 로드하는 방식

```java
@ToString(exclude = {"department"})
@Entity
@Table(name = "tbl_emp")
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "emp_id")
    private Long id; // 사원번호
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "dept_id") // FK를 포함시키는건 DB 패러다임에 맞춰야함
    private Department department; // 부서정보 통째로 포함
}
```

@ToString(exclude = {"department"})
- `ToString`에서 department 정보 안찍음
- exclude가 없는 상태에서 Employee 객체를 toString()으로 찍으면
- 데이터베이스에 접근하여 정보를 가져올 때 `department` 때문에 join을 하게됨
- 연관 관계 필드는 순환참조 방지를 위해 제외해야 함

@ManyToOne(fetch = FetchType.LAZY)
- `FetchType.LAZY`: 필요없을 때는 조인을 하지 않는 전략
- ManyToOne은 무조건 LAZY를 거는게 좋음

---

### 양방향 매핑

- 양방향 매핑은 데이터베이스와 달리 객체지향 시스템에서 가능한 방법으로
  1대N관계에서 1쪽에 N데이터를 포함시킬 수 있는 방법이다.

- 양방향 매핑에서 1쪽은 상대방 엔터티 갱신에 관여 할 수 없고
  (리스트에서 사원을 지운다고 실제 디비에서 사원이 삭제되지는 않는다는 말)
  단순히 읽기전용 (조회전용)으로만 사용하는 것이다.

- mappedBy에는 상대방 엔터티에 @ManyToOne에 대응되는 필드명을 꼭 적어야 함

- 필드 초기화를 안 해주므로, 직접 초기화 해줘야 한다.

```java
@ToString(exclude = {"employees"})
@Entity
@Table(name = "tbl_dept")
public class Department {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "dept_id")
    private Long id; // 부서번호

    @Column(name = "dept_name", nullable = false)
    private String name; // 부서명
    
    @OneToMany(mappedBy = "department")
    private List<Employee> employees = new ArrayList<>();
}

```
@ToString(exclude = {"employees"})
- 연관관계 필드는 순환참조 방지를 위해 제외해야 함

@OneToMany(mappedBy = "department")
- @OneToMany는 기본이 Lazy Loading
- mappedBy에는 상대방 엔터티에 @ManyToOne에 대응되는 필드명을 꼭 적어야 함

private List<Employee> employees = new ArrayList<>();
- 필드 초기화를 안 해주므로, 직접 초기화

---

### 양방향 연관관계 설정에서 UPDATE문 처리시 주의사항

`JPA`에서 엔티티 수정 방법
- 수정하려는 엔티티를 찾음
- 해당 엔티티의 속성을 변경한 다음 `save()` 메서드를 호출
- `JPA`는 트랜잭션이 종료될 때 변경된 내용을 데이터베이스에 반영

하지만 양방향 연관관계에서는 한 쪽 엔티티만 변경하면 다른 쪽은 변경되지 않음
이러한 현상을 객체와 데이터베이스 간의 `불일치 문제`라고 함.

```java
@Test
@DisplayName("양방향 매핑에서 데이터를 수정할 때 발생하는 문제")
void changeTest() {
    //given
    
    // 3번 사원의 부서를 2번 부서에서 1번 부서로 수정

    // 3번 사원 조회
    Employee foundEmp = employeeRepository.findById(3L).orElseThrow();

    // 1번 부서 조회
    Department foundDept = departmentRepository.findById(1L).orElseThrow();

    //when
    // 사원쪽에서 부서정보 변경
    // + 양방향에서는 반대편에서도 수동으로 변경처리가 진행되어야 함.
    // 연관관계 양방향 수정 편의메서드
    foundEmp.changeDepartment(foundDept);
    
    employeeRepository.save(foundEmp);
    
}
```
```java
public class Employee {
    // ...

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "dept_id")
    private Department department;
    
    // 부서 변경 편의 메서드
    public void changeDepartment(Department department) {
        // ManyToOne 필드가 변경이 일어나면 반대편쪽의 OneToMany도 같이 갱신
        this.department = department;
        if (department != null) {
            department.getEmployees().add(this);
        }
    }
}
```


