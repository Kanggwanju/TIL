# 🗓️ 2025년 10월 24일 TIL - Zustand 기반 인증 상태 관리 연동

## 📌 오늘의 키워드
`Zustand` `전역 상태 관리` `persist 미들웨어` `localStorage` `인증 상태` `hasCheckedAuth` `옵셔널 체이닝` `React 초기화` `비동기 복원` `useEffect 타이밍`

---

## 문제 상황

퀴즈 대기방(`QuizWaitingRoom.jsx`)에서 실제 로그인한 사용자 ID를 가져오는 로직이 구현되지 않아, 
임시로 마지막 참가자를 본인으로 설정하는 방식을 사용하고 있었다.

```javascript
// 기존 임시 코드
const [myUserId, setMyUserId] = useState(null);

// handleRoomJoin 함수 내부
const myId = roomData.participants[roomData.participants.length - 1].userId;
setMyUserId(myId); // 마지막 참가자를 나로 가정
```

이 방식은 다음과 같은 문제가 있었다:
- 실제 로그인 정보와 무관하게 동작
- 참가자 순서에 따라 본인 식별이 달라질 수 있음
- 새로고침 시 사용자 정보 유실
- 다른 컴포넌트와 인증 패턴이 불일치

---

## 해결 방안

팀원이 구현한 Zustand 기반 인증 상태 관리(`authStore.js`)를 활용하여 전역 상태에서 사용자 정보를 가져오도록 개선했다.

### authStore의 주요 기능

```javascript
// authStore.js의 주요 상태
{
  user: {
    userId: 1,
    nickname: "김코즈",
    profileImage: "https://...",
    totalScore: 0,
    requiredAgree: true
  },
  isAuthenticated: true,
  hasCheckedAuth: true,  // localStorage 복원 완료 여부
  loading: false,
  error: null
}
```

**특징**:
- `zustand/middleware`의 `persist`를 사용하여 localStorage에 상태 영속화
- HTTP-Only 쿠키 기반 인증과 클라이언트 상태 관리 병행
- `hasCheckedAuth` 플래그로 초기화 완료 여부 추적

---

## 구현 과정

### 1. Zustand authStore 연동

```javascript
// QuizWaitingRoom.jsx
import { useAuthStore } from '../../store/auth/authStore.js';

const QuizWaitingRoom = () => {
  const { user, isAuthenticated, hasCheckedAuth } = useAuthStore();
  const myUserId = user?.userId;
  
  // 기존 useState 제거
  // const [myUserId, setMyUserId] = useState(null);
```

**선택 고민**: `const myUserId = user?.userId` vs 직접 `user?.userId` 사용

최종적으로 변수로 추출하는 방식을 선택한 이유:
- 코드 가독성 향상 (`participant.userId === myUserId`가 의미가 명확함)
- 기존 코드에서 이미 `myUserId`라는 네이밍 컨벤션 사용 중
- 타이핑 편의성 (반복적으로 사용되는 값)
- 향후 리팩토링 용이성 (한 곳만 수정하면 됨)

### 2. 인증 체크 로직 추가

초기 구현 시 문제가 발생했다:

```javascript
// 문제가 있던 코드
useEffect(() => {
  if (!isAuthenticated || !myUserId) {
    alert('로그인이 필요합니다.');
    navigate('/main');
  }
}, [isAuthenticated, myUserId, navigate]);
```

**문제점**: 새로고침 시 localStorage에서 데이터를 복원하는 동안 `myUserId`가 일시적으로 `null`이 되어 즉시 리다이렉트됨

**해결 방법**: `hasCheckedAuth` 플래그를 활용하여 초기화 완료 대기

```javascript
useEffect(() => {
  // localStorage 복원이 완료될 때까지 대기
  if (!hasCheckedAuth) {
    console.log('⏳ 인증 상태 확인 중...');
    return;
  }

  // 인증 확인 후 로그인 안 되어 있으면 리다이렉트
  if (!isAuthenticated || !myUserId) {
    alert('로그인이 필요합니다.');
    navigate('/main');
  } else {
    console.log('✅ 인증 확인:', myUserId);
  }
}, [hasCheckedAuth, isAuthenticated, myUserId, navigate]);
```

**핵심**: Zustand의 `persist` 미들웨어가 localStorage에서 상태를 복원하는 시간이 필요하므로, 복원 완료 여부를 나타내는 플래그를 먼저 체크해야 한다.

### 3. 임시 로직 제거

```javascript
// handleRoomJoin 함수에서 제거
// const myId = roomData.participants[roomData.participants.length - 1].userId;
// setMyUserId(myId);

// 이제 myUserId는 Zustand에서 직접 가져옴
const formattedParticipants = roomData.participants.map(p => ({
  id: p.userId,
  userId: p.userId,
  nickname: p.nickname,
  profileImageUrl: p.profileImageUrl,
  score: 0,
  isMe: p.userId === myUserId,  // Zustand에서 가져온 값 사용
  isHost: p.host,
  isReady: p.ready,
  webcamStatus: 'off'
}));
```

### 4. 기존 로직과의 호환성 확인

`myUserId`를 사용하는 모든 부분이 정상 동작하는지 확인:
- Janus WebRTC 연결: `display: String(myUserId)` (line 140)
- 참가자 카드: `participant.userId === myUserId` (line 654, 679, 695)
- 참가자 이벤트: `isMe: newUser.userId === myUserId` (line 409)

---

## 학습 내용

### 1. Zustand persist 미들웨어의 동작 방식

```javascript
persist(
  (set, get) => ({
    // 상태 정의
  }),
  {
    name: 'auth',  // localStorage 키
    partialize: (state) => ({
      user: state.user,
      isAuthenticated: state.isAuthenticated
    }),  // 저장할 필드만 선택
    storage: {
      getItem: (name) => { /* ... */ },
      setItem: (name, value) => { /* ... */ },
      removeItem: (name) => { /* ... */ }
    }
  }
)
```

**중요 포인트**:
- `partialize`로 저장할 상태를 선택적으로 지정 가능
- localStorage에서 복원하는 과정이 비동기적으로 발생
- 복원 완료 여부를 추적하기 위한 플래그(`hasCheckedAuth`) 필요

### 2. React 컴포넌트 초기화 순서

1. 컴포넌트 마운트
2. useState/useRef 초기화
3. **Zustand 상태 구독** (localStorage 복원 시작)
4. useEffect 실행
5. localStorage 복원 완료
6. Zustand 상태 업데이트 → 컴포넌트 리렌더링

따라서 첫 렌더링 시점에는 아직 localStorage 복원이 완료되지 않았을 수 있다.

### 3. 전역 상태 관리의 장점

기존 방식 (로컬 상태):
```javascript
const [myUserId, setMyUserId] = useState(null);
// 매번 수동으로 설정 필요
setMyUserId(someValue);
```

Zustand 방식 (전역 상태):
```javascript
const myUserId = user?.userId;
// 자동으로 최신 값 반영
// 다른 컴포넌트에서도 동일한 값 사용
```

**이점**:
- 중복 코드 제거
- 일관된 사용자 정보 보장
- 새로고침 후에도 상태 유지
- 컴포넌트 간 상태 공유 용이

### 4. 옵셔널 체이닝의 활용

```javascript
const myUserId = user?.userId;
```

- `user`가 `null` 또는 `undefined`일 때 안전하게 처리
- 초기화 과정에서 `user`가 아직 없을 때를 대비
- 명시적인 null 체크보다 간결한 코드

---

## 테스트 결과

### 정상 동작 확인
- 로그인 후 대기방 입장 시 본인 정보 정확히 표시
- 새로고침 후에도 인증 상태 유지 및 리다이렉트 방지
- 비로그인 사용자 접근 시 `/main`으로 리다이렉트
- WebSocket/WebRTC 연결 시 정확한 userId 전달

### 콘솔 로그 흐름
```
⏳ 인증 상태 확인 중...
✅ 인증 확인: 1
✅ WebSocket 연결 성공!
🚪 방 1에 입장 시도
📥 방 입장 응답: {...}
✅ State 업데이트 완료
```

---

## 개선 가능성

### 1. PrivateRoute 컴포넌트 도입
현재는 각 컴포넌트에서 인증 체크를 하고 있지만, 라우팅 레벨에서 처리하는 것이 더 효율적일 수 있다.

```javascript
// Router.jsx
<Route path="/quiz/waiting/:roomId" element={
  <PrivateRoute>
    <QuizWaitingRoom />
  </PrivateRoute>
} />
```

### 2. 로딩 UI 추가
현재는 `hasCheckedAuth`가 `false`일 때 아무것도 표시하지 않는데, 로딩 인디케이터를 보여주면 사용자 경험이 개선될 수 있다.

```javascript
if (!hasCheckedAuth || loading) {
  return <LoadingSpinner />;
}

if (!isAuthenticated || !myUserId) {
  return null;  // 리다이렉트 중
}
```

### 3. refreshMeSilent() 활용
대기방 입장 시 서버에서 최신 사용자 정보(점수 등)를 동기화하면 더 정확한 정보를 보여줄 수 있다.

```javascript
useEffect(() => {
  if (isAuthenticated && myUserId) {
    const { refreshMeSilent } = useAuthStore.getState();
    refreshMeSilent();  // 최신 정보 갱신
  }
}, [isAuthenticated, myUserId]);
```

---

## 결론

Zustand를 활용한 전역 상태 관리로 사용자 인증 로직을 개선할 수 있었다. 
특히 `persist` 미들웨어의 비동기적 복원 과정을 이해하고 `hasCheckedAuth` 플래그를 활용하는 것이 핵심이었다.

이번 작업을 통해 다음을 배웠다:
- Zustand persist 미들웨어의 동작 원리
- React 컴포넌트 초기화와 상태 복원의 타이밍
- 전역 상태 관리의 실질적인 이점
- 옵셔널 체이닝을 활용한 안전한 상태 접근

앞으로 다른 컴포넌트에서도 동일한 패턴으로 인증 상태를 활용할 수 있을 것이다.

