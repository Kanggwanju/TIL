# 🗓️ 2025년 7월 8일 TIL

## 📌 학습 키워드

**입출력 (I/O), 내부클래스, 익명클래스, 람다식, 직렬화, 파일 스트림**

---

## 📁 입출력 (I/O) 기본 개념

* **출력(Output)**: CPU → HDD
* **입력(Input)**: HDD → CPU
* 세이브 파일을 만드는 건 출력, 세이브 파일에서 읽어오는 건 입력

### 💡 스트림(Stream)

> CPU와 저장장치(또는 키보드, 모니터 등)가 데이터를 주고받는 추상적인 통로

* 데이터의 흐름을 바이트 또는 문자 단위로 처리
* **바이트 스트림**: 1바이트 단위 (바이너리 데이터 처리)
* **문자 스트림**: 2바이트 유니코드 (텍스트 데이터 처리)

---

## 📂 파일 생성 흐름

```java
File rootDirectory = new File(ROOT_PATH); // 폴더 경로 객체화

if (!rootDirectory.exists()) {
    rootDirectory.mkdir(); // 폴더 생성
}
```

```java
File newFile = new File(ROOT_PATH + "/food.txt"); // 파일 객체화

if (!newFile.exists()) {
    try {
        newFile.createNewFile();
        System.out.println("파일이 생성되었습니다.");
    } catch (IOException e) {
        System.out.println("파일 생성에 실패했습니다.");
    }
}
```

> 📌 파일이나 폴더를 생성하는 작업은 HDD에 직접 접근하는 일이기 때문에 **예외처리 필수!**

---

## 📤 FileOutputStream / 📥 FileInputStream

### 📤 FileOutputStream (바이트 기반 출력 스트림)

```java
FileOutputStream fos = new FileOutputStream(FileExample.ROOT_PATH + "/pet.txt");
fos.write(new byte[] {99, 97, 116}); // 'c', 'a', 't'
```

### 📥 FileInputStream (바이트 기반 입력 스트림)

```java
FileInputStream fis = new FileInputStream(FileExample.ROOT_PATH + "/pet.txt");

int data = 0;
while ((data = fis.read()) != -1) {
    System.out.write(data); // 아스키 코드 문자 출력
}
System.out.flush(); // 출력 버퍼 비우기
```

> flush()는 **출력 버퍼에 남은 데이터를 강제로 비워 콘솔에 즉시 출력**할 때 사용

---

## 📝 FileWriter / FileReader

---

## 🔒 try-with-resources 문법

> 자바에서 리소스를 자동으로 닫아주는 문법
> `FileWriter`, `FileReader`, `BufferedReader`, `InputStream`, `OutputStream` 등은
> **사용이 끝나면 반드시 `close()` 해줘야** 리소스 누수(메모리 문제)가 생기지 않음!

기존에는 다음처럼 `finally`에서 직접 닫아줬어야 했음:

```java
FileWriter fw = null;
try {
    fw = new FileWriter("example.txt");
    fw.write("내용 작성");
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (fw != null) {
        try {
            fw.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

하지만 너무 번거롭고 실수하기 쉬움…

---

### ✅ 개선된 방식: try-with-resources

```java
try (FileWriter fw = new FileWriter("example.txt")) {
    fw.write("내용 작성");
} catch (IOException e) {
    e.printStackTrace();
}
```

> `()` 안에 선언된 객체는 try 블록이 끝날 때 **자동으로 `close()` 호출됨**
> 더 안전하고 코드도 간결해짐!

---

### 📌 사용 조건

* try 안에 선언되는 객체는 반드시 `AutoCloseable` 인터페이스를 구현해야 함
* 대부분의 입출력 관련 클래스는 이 인터페이스를 이미 구현하고 있음

---


### 🖋️ FileWriter (텍스트 출력)

```java
try (FileWriter fw = new FileWriter(FileExample.ROOT_PATH + "/hobbies.txt")) {
    String hobby = InputUtils.prompt("취미를 입력: ");
    fw.write("당신의 취미: " + hobby);
} catch (Exception e) {
    System.out.println("파일 저장 실패!");
}
```

### 📖 FileReader + BufferedReader (텍스트 입력 + 줄 단위 읽기)

```java
try (FileReader fr = new FileReader(FileExample.ROOT_PATH + "/artist.txt")) {
    BufferedReader br = new BufferedReader(fr);

    while (true) {
        String data = br.readLine();
        if (data == null) break;

        String[] split = data.split("-");
        Artist artist = new Artist(split[0]);

        String[] songList = split[1].split(",");
        for (String song : songList) {
            artist.addSong(song);
        }
        System.out.println("artist = " + artist);
    }

} catch (Exception e) {
    e.printStackTrace();
}
```

> 🔍 `Artist` 클래스는 `가수명(String)`과 `노래 목록(Set<String>)` 필드를 가지고 있으며,
> 파일 한 줄의 데이터를 `split()`을 활용해 파싱함.

---

## 🚀 버퍼 사용의 이유

* HDD와 CPU가 데이터를 1바이트씩 주고받을 경우 병목이 발생할 수 있음
* **버퍼**를 두고 데이터를 일정량 모은 뒤 한 번에 처리하면 효율 증가
* 단, 버퍼가 다 차지 않으면 전송이 안 되므로 `flush()`로 강제 전송 가능

---

## 🔧 클래스 제작 팁

* 자바 클래스는 아래 메서드들을 미리 작성해두면 편리함:

    * `@NoArgsConstructor`
    * `@AllArgsConstructor`
    * `getter/setter`
    * `toString()`
    * `equals()` / `hashCode()`

> 이런 구성요소들을 **보일러플레이트(boilerplate)** 라고 부름.

---

## 🗃️ 객체 저장과 불러오기 (직렬화)

### 📥 객체 저장 (Serialization)

```java
try (FileOutputStream fos = new FileOutputStream(FileExample.ROOT_PATH + "/snack.sav")) {
    ObjectOutputStream oos = new ObjectOutputStream(fos);
    oos.writeObject(snackList);
    System.out.println("객체 저장 성공!");
} catch (Exception e) {
    e.printStackTrace();
}
```

* `ObjectOutputStream`: 객체를 통째로 저장하는 보조 스트림
* `Snack` 클래스는 반드시 `implements Serializable` 해야 직렬화 가능

---

### 📤 객체 불러오기 (Deserialization)

```java
try (FileInputStream fis = new FileInputStream(FileExample.ROOT_PATH + "/snack.sav")) {
    ObjectInputStream ois = new ObjectInputStream(fis);

    List<Snack> snackList = (List<Snack>) ois.readObject();

    for (Snack snack : snackList) {
        System.out.println("snack = " + snack);
    }

} catch (Exception e) {
    e.printStackTrace();
}
```

> `readObject()`는 `Object` 타입으로 반환되므로 **원래 타입으로 명시적 캐스팅**, **역직렬화(deserialization)** 필요

---










내부클래스와 익명클래스





람다


이 인터페이스는 추상메서드가 딱 1개
이 인터페이스는 람다를 사용할 수 있음.

`@FunctionalInterface`
함수형 인터페이스 - 람다를 사용할 수 있는지 체크

default나 static 함수는 있어도 가능
```java
@FunctionalInterface
public interface Pet {
    void eat();

    default void foo() {}
    static void foo1() {}
}
```

오버라이드 할 추상 메서드가 단 한개 밖에 없을때 생략하여 표현 가능
익명 클래스 간소화, 람다

dog는 객체를 전달받는 것이고,
객체는 내부에 오버라이드 된 메서드를 가지고 있는 것.
```java
Pet dog = () -> System.out.println("강아지는 사료를 먹어요~");

```