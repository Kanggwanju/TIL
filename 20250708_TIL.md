# 🗓️ 2025년 7월 8일 TIL



입출력

출력
CPU -> HDD


입력
HDD -> CPU

프로그램이 세이브 파일을 만드는 것은 출력,
세이브 파일에서 프로그램으로 로드하는 것은 입력


CPU와 HDD, 모니터, 키보드는 입출력으로 상호작용하며,
입출력을 할 때 사용하는 통로는 `스트림`이라고 한다.

스트림
데이터의 흐름을 나타내는 추상화된 개념.
스트림은 연속된 데이터를 바이트 또는 문자 단위로 처리

데이터를 1바이트 단위로만 통신할수 있음.
데이터를 바이트로 변화시키는 것은 직렬화라고 함
강을 전송하면 'ㄱ' 'ㅏ' 'ㅇ' 1바이트 단위로 전송
이렇게 하는게 소요가 많기 때문에 문자(character) 단위로 처리

스트림은 크게 바이트, 문자 스트림으로 나뉜다.
바이트 스트림: 바이트 단위로 데이터 처리, 주로 바이너리 데이터 처리
문자 스트림: 2바이트 유니코드 문자 단위로 처리, 주로 텍스트 데이터 처리


파일 생성
1. 폴더 생성 명령
- 생성 할 폴더의 경로를 파일 객체로 매핑
```java
File rootDirectory = new File(ROOT_PATH);
```
2. 폴더 생성 명령
```java
if (!rootDirectory.exists()) {
   rootDirectory.mkdir();
}
```

3. 파일 생성하기
- 파일이 저장될 경로와 파일명을 함께 파일 객체로 매핑
```java
File newFile = new File(ROOT_PATH + "/food.txt");
```
- 파일 생성 (파일이나 폴더 생성은 하드디스크에 접근하는 행위이므로 예외처리를 해주어야함.)
```java
if (!newFile.exists()) {
    try {
        newFile.createNewFile();
        System.out.println("파일이 생성되었습니다.");
    } catch (IOException e) {
        System.out.println("파일 생성에 실패했습니다.");
    }
}
```

---

FileInputStream, FileOutputStream
- 바이트 기반 파일 입출력 클래스, 바이너리 데이터 처리에 사용


FileOutputStream
- 바이트 기반 출력 스트림, 1바이트 단위로 데이터 처리
- 주로 이미지, 영상같은 바이너리 데이터 처리에 적합

1. 경로와 파일명을 파라미터로, 출력 스트림 객체로 매핑
```java
FileOutputStream fos
    = new FileOutputStream(FileExample.ROOT_PATH + "/pet.txt");
```

2. 문자는 그냥 넣을 수 없기 때문에 99(c), 97(a), 116(t)로 fos에 write함.
`fos.write(new byte[] {99, 97, 116});`


FileInputStream
1. 경로와 파일명을 파라미터로, 입력 스트림 객체로 매핑
```java
FileInputStream fis
    = new FileInputStream(FileExample.ROOT_PATH + "/pet.txt");
```

2. 파일 내용 출력
- fis.read()는 한번 실행시 파일의 한 음절을 읽어내어 반환하고,
더이상 읽을 내용이 없으면 -1을 반환함.

```java
int data = 0;
while ((data = fis.read()) != -1) {
// 숫자가 나오므로 char 변환
//    System.out.print((char) data);

    // 숫자를 아스키로 변환해서 출력
    System.out.write(data);
}
```

3. 출력 버퍼 비우기
- 출력 버퍼에 쌓인 내용을 강제로 비워서 즉시 콘솔에 출력하기 위해 사용
- 버퍼에 남아있는 데이터가 유실되지 않도록 안전하게 출력
```java
System.out.flush();
```


FileWriter, FileReader
- 텍스트 기반 스트림: 오직 텍스트만을 2바이트 단위로 입출력


FileWriter
try ~ with ~ resources 명령
- 메모리 정리가 필요한 객체에 대해 자동 클로즈 처리
- try 문 내부에 리소스를 반납 해야되는 FileWriter를 넣어줌
```java
try (FileWriter fw = new FileWriter(FileExample.ROOT_PATH + "/hobbies.txt")) {
    String hobby = InputUtils.prompt("취미를 입력: ");

    // 파일 출력 명령
    fw.write("당신의 취미: " + hobby);

} catch (Exception e) {
    System.out.println("파일 저장 실패!");
}
```

FileReader

```java
try (FileReader fr = new FileReader(FileExample.ROOT_PATH + "/artist.txt")) {

    // 텍스트를 줄 단위로 읽어내는 보조 스트림
    BufferedReader br = new BufferedReader(fr);

    while (true) {
        String data = br.readLine();

        if (data == null) break;

        String[] split = data.split("-");
//                System.out.println(split[1]);

        Artist artist = new Artist(split[0]);

        // 노래목록 문자열에서 노래들을 분리
        String[] songList = split[1].split(",");
        for (String song : songList) {
            artist.addSong(song);
        }
        System.out.println("artist = " + artist);
    }

} catch (Exception e) {
    e.printStackTrace();
}
```
Artist 클래스의 필드는 String 가수이름과 Set<String> songList
줄단위로 읽어온 내용을 split을 통해 -의 앞쪽 내용은 가수 이름으로써
Artist 객체를 만들 때 생성자의 파라미터로 넣어주고
-의 뒤쪽 내용은 songList에 추가해줌.


버퍼 사용하기
HDD와 프로그램 사이에 스트림을 통해 1byte씩 주고받음
하지만 병목 현상이 일어나면 스트림이 막혀서 속도가 느려짐
이것을 스트림에 버퍼를 둬서 해결
스트림 대신 버퍼에 데이터를 쌓고 꽉차면 전송함.
근데 버퍼에 데이터가 덜 쌓이면 전송이 안 되므로
flush()를 통해 덜 찬 버퍼의 데이터를 전송



tip
자바 class 제작 팁 보일러 플레이트라 하여
NoArgsConstructor, AllArgsConstructor, getter, setter, toString,
equals, hashCode를 정의해주는게 좋다.


객체 save
```java
try(FileOutputStream fos = new FileOutputStream(FileExample.ROOT_PATH + "/snack.sav")) {
    ObjectOutputStream oos = new ObjectOutputStream(fos);
    oos.writeObject(snackList);
    System.out.println("객체 저장 성공!");
} catch (Exception e) {
    e.printStackTrace();
}
```

`ObjectOutputStream`: 객체를 통채로 저장하는 보조스트림

`oos.writeObject(snackList);`
- 객체가 스트림을 통과하려면 직렬화가 되어야 함.
- snack은 따로 제작한 클래스라 직렬화가 안 되어있음.
- 이를 해결하기 위해서는 Snack 클래스에 implements Serializable를 붙여주면 된다.


객체 load
```java
try (FileInputStream fis
                 = new FileInputStream(FileExample.ROOT_PATH + "/snack.sav")) {

    ObjectInputStream ois = new ObjectInputStream(fis);
    
    List<Snack> snackList = (List<Snack>) ois.readObject();

    for (Snack snack : snackList) {
        System.out.println("snack = " + snack);
    }

} catch (Exception e) {
    e.printStackTrace();
}
```

`List<Snack> snackList = (List<Snack>) ois.readObject();`
- 저장된 객체를 불러와서 역직렬화(deserialization)
- readObject() 메서드는 파일 등에서 직렬화된 객체 데이터를 읽어와서, 자바 객체로 복원
- readObject()는 Object 타입으로 리턴하기 때문에 명시적 타입 캐스팅을 해준다.










내부클래스와 익명클래스





람다


이 인터페이스는 추상메서드가 딱 1개
이 인터페이스는 람다를 사용할 수 있음.

`@FunctionalInterface`
함수형 인터페이스 - 람다를 사용할 수 있는지 체크

default나 static 함수는 있어도 가능
```java
@FunctionalInterface
public interface Pet {
    void eat();

    default void foo() {}
    static void foo1() {}
}
```

오버라이드 할 추상 메서드가 단 한개 밖에 없을때 생략하여 표현 가능
익명 클래스 간소화, 람다

dog는 객체를 전달받는 것이고,
객체는 내부에 오버라이드 된 메서드를 가지고 있는 것.
```java
Pet dog = () -> System.out.println("강아지는 사료를 먹어요~");

```