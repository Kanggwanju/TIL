# 🗓️ 2025년 8월 27일 TIL


## 📝 리액트 실습 정리 (목표설정 앱 수정)

### 1\. 폼(Form) 제출 이벤트 처리

* **이벤트 연결**: `<button>`의 `onClick` 대신,
  `<form>`에 `onSubmit` 이벤트를 연결하는 것이 더 안정적
  
* **새로고침 방지**: `onSubmit` 함수에서 **`e.preventDefault()`**를
  호출하여 기본 동작(새로고침)을 막습니다.

* **입력 상태 관리**: `useState` 훅과 `onInput` 이벤트를
  사용하여 입력 값을 실시간으로 관리

* **양방향 바인딩**: `value={상태변수}` 속성으로 입력 필드와 상태 변수를 동기화
  
* **상태 전달 및 초기화**: 부모 컴포넌트에 값을 전달한 후, **`setEnteredText('')`**로 입력창을 초기화

-----

## 2\. 목표 항목 삭제 로직

- React에서는 배열 상태를 업데이트할 때 \*\*불변성(Immutability)\*\*을 지키는 것이 매우 중요
- 즉, 원본 배열을 직접 수정하지 않고 새로운 배열을 만들어 사용해야 합니다.


### 2-1. 고차 함수(filter)를 사용한 방식 (권장)

- `Array.prototype.filter()` 함수는 특정 조건을 만족하는
  요소들만 모아 **새로운 배열을 반환**하는 고차 함수

- 이 방법은 코드가 매우 간결하고 가독성이 뛰어남

```jsx
const onDelete = (targetId) => {
  // 목표 ID가 targetId와 다른 항목들만 필터링하여 새로운 배열 생성
  setGoals(prev => prev.filter(goal => goal.id !== targetId));
}
```

### 2-2. 배열 탐색 및 수정 방식

- `for` 루프와 `Array.prototype.splice()` 메서드를 사용해 요소를 삭제
- 전통적인 배열 조작 방식, `filter`를 사용하는 것보다 코드가 복잡

```jsx
const onDelete = (targetId) => {
  // goals 배열 복사 (불변성 유지)
  const copyGoals = [...goals];
  let index = -1;
  for (let i = 0; i < copyGoals.length; i++) {
    if (copyGoals[i].id === targetId) {
      index = i;
      break; // 요소를 찾으면 루프 종료
    }
  }

  if (index !== -1) {
    // splice로 해당 인덱스에 있는 요소 1개 삭제
    copyGoals.splice(index, 1);
    setGoals(copyGoals); // 상태 업데이트
  }
}
```
---

## 동적 스타일 조작 방법 정리

- React에서 사용자 인터페이스의 상태에 따라 스타일을 변경하는 기술
- 일반적으로 두 가지 방법이 사용됨

## 1\. 동적 인라인 스타일 조작

**동적 인라인 스타일**은 HTML 요소에 직접 `style` 속성을 객체 형태로 추가하여,
  상태에 따라 스타일을 실시간으로 변경하는 방식

* **스타일 관리**: `isValid`와 같은 상태 변수를 사용하여 
  입력 값에 오류가 있는지 여부를 관리
* **스타일 적용**: `style` 속성 내부에 JavaScript 객체를 사용하여
  스타일을 정의
* 객체의 속성값(예: `background`, `borderColor`)에 조건부 렌더링을 적용하여
  상태에 따라 다른 스타일을 적용 가능
* 예를 들어, `isValid`가 `false`일 때만 배경색을 `salmon`으로,
  아닐 때는 `transparent`로 설정하는 방식


```jsx
// 입력값에 오류가 있는지 여부를 상태관리
const [isValid, setIsValid] = useState(null);

// JSX
<input
  type='text'
  onInput={goalInputHandler}
  value={enteredText}
  style={{
    background: isValid !== false ? 'transparent' : 'salmon',
    borderColor: isValid !== false ? 'black' : 'red'
  }}
/>
```

## 2\. 동적 클래스 조작 (권장)

**동적 클래스**는 상태에 따라 클래스 이름을 추가하거나 제거하는 방식

* **스타일 관리**: 인라인 스타일과 마찬가지로 `isValid` 상태를 사용
* **스타일 적용**: ES6의 템플릿 리터럴(` `)을 사용하여 조건에 따라
  클래스 이름을 동적으로 조합
* 기본 클래스(`form-control`)는 유지,
  `isValid`가 `false`일 때만 `invalid` 클래스를 추가

```jsx
// JSX
<div className={`form-control ${isValid === false ? 'invalid' : ''}`}>
  ...
</div>
```


---

## SCSS 핵심 개념 정리

* `SCSS란?`: CSS에 프로그래밍 요소를 추가한 `CSS 전처리기`
  - CSS를 효율적으로 작성하도록 도와줍니다.
* **패키지 설치**: `npm install sass react-icons`
  - SCSS, 리액트 아이콘 라이브러리 설치
* **변수 사용**: `$my-dark-gray: #343a40;`와 같이 변수를 사용하면 일관된 스타일링 가능

* **중첩(Nesting)**: HTML 구조와 유사하게 CSS 선택자를 중첩하여 작성

* **부모 선택자 `&`**: `&:hover`처럼 부모 선택자(&)를 사용하면 부모 클래스에 대한
  가상 선택자(`:hover`)나 추가 클래스(`.open`)를 간결하게 표현 가능

* **`@mixin` (믹스인)**: 반복적으로 사용되는 스타일 코드를
  `@mixin`으로 정의, `@include`로 불러와 재사용

-----

## React에서 SCSS 활용하기

React 프로젝트에서는 **CSS Modules**를 활용하여 SCSS의 장점을 극대화 가능

### 1\. CSS Modules 사용

파일명을 **`[이름].module.scss`** 형식으로 작성하면 React가 자동으로 CSS Modules로 인식

```jsx
// 파일명: TodoHeader.module.scss
```

### 2\. 컴포넌트에서 SCSS 불러오기

해당 SCSS 파일을 컴포넌트에 import 할 때,
아래와 같이 객체 형태로 불러옵니다.

```javascript
import styles from './scss/TodoHeader.module.scss';
```

이렇게 불러오면, SCSS 파일에 정의된 클래스 이름이
고유한 해시값으로 변환되어 다른 컴포넌트의 클래스명과 충돌하는 것을 방지합니다.

### 3\. 클래스 적용

HTML 요소에 클래스를 적용할 때는 불러온
`styles` 객체에 접근하는 방식(`styles.클래스명`)을 사용

```jsx
<h1 className={styles.title}>오늘의 할 일</h1>
<div className={styles['tasks-left']}></div>
```

### 4\. 동적 클래스 적용

특정 조건에 따라 클래스를 추가하고 싶을 때는 템플릿 리터럴을 활용

```jsx
<button
  className={`${styles['insert-btn']} ${isClicked ? styles.open : ''}`}
  onClick={clickHandler}
>
  ...
</button>
```

위 코드는 `isClicked` 상태가 `true`일 때만 `open` 클래스를 추가하여
동적으로 스타일을 변경하는 방식


