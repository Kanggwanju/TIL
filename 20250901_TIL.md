# 🗓️ 2025년 9월 1일 TIL

## 오늘의 키워드
- CORS (프론트-백엔드 서버 분리 환경에서 요청 허용 설정)
- Health Check (서버 상태 확인용 엔드포인트)
- React Router Loader (페이지 렌더링 전에 데이터 미리 가져오기)
- useNavigate (코드로 라우팅 제어)

---

# 📌 React ↔ Spring Boot 서버 요청 & CORS 설정

### 🔹 프론트/백엔드 분리

* 프론트: React
* 백엔드: Spring Boot
* 서버가 따로 존재하기 때문에, **프론트에서 백엔드로 요청 시 CORS 설정 필요**

---

## 🔹 CORS(Cross-Origin Resource Sharing) 설정

### 1) 전역 설정 클래스

```java
@Configuration
public class CorsConfig implements WebMvcConfigurer
```

### 2) 허용할 Origin 배열 관리

```java
private String[] permitUrls = {
    "http://localhost:5173",
    "http://localhost:5174",
    "http://localhost:5175",
};
```

### 3) CORS 매핑 등록

```java
@Override
public void addCorsMappings(CorsRegistry registry) {
    registry
        .addMapping("/api/**")          // 어떤 경로 허용?
        .allowedOrigins(permitUrls)     // 허용할 클라이언트 URL
        .allowedMethods("*")            // 허용할 요청 방식 (GET, POST, PUT, DELETE...)
        .allowedHeaders("*")            // 허용할 헤더
        .allowCredentials(true);        // 보안 쿠키 허용 여부
}
```

---

## 🔹 각 메서드 설명

* **`addMapping`** → 클라이언트가 접근할 수 있는 **백엔드 경로** 지정
* **`allowedOrigins`** → 허용할 클라이언트 **URL(origin)** 지정
* **`allowedMethods`** → 허용할 **HTTP 메서드** (예: `"GET"`, `"POST"`)
* **`allowedHeaders`** → 허용할 **HTTP 헤더**
* **`allowCredentials(true)`** → **보안 쿠키(세션, JWT 등)** 포함 여부

---

### 📝 핵심 요약:

* React 개발 서버(5173, 5174, 5175)에서 Spring Boot API(`/api/**`) 호출 가능하도록 허용.
* CORS는 **백엔드 서버가 클라이언트 요청을 받아들일지 여부를 정하는 규칙**.

---


# 📌 헬스 체크(Health Check) 엔드포인트

## 🔹 개념

* 배포된 API 서버가 **정상적으로 살아있는지, 응답 가능한지** 확인하기 위해 사용하는 엔드포인트

---

## 🔹 코드 예시

```java
@RestController
@Slf4j
public class HealthCheckController {

    @GetMapping("/status")
    public ResponseEntity<?> healthCheck() {
        return ResponseEntity.ok(
            Map.of(
                "healthy", true,
                "timestamp", LocalDateTime.now()
            )
        );
    }
}
```

### 👉 `/status`로 GET 요청 시 응답(JSON)

```json
{
  "healthy": true,
  "timestamp": "2025-09-01T12:34:56.789"
}
```

* `healthy: true` → 서버 정상 동작
* `timestamp` → 호출 시점 기록

---

## 🔹 실무에서의 쓰임새

1. **로드 밸런서 / 쿠버네티스**

   * ELB, Nginx, Kubernetes가 `/status`를 주기적으로 호출
   * 200 OK면 정상 → 트래픽 분배 유지
   * 실패 시 해당 인스턴스를 제외

2. **모니터링**

   * Prometheus, Grafana 등 모니터링 시스템에서 상태 수집
   * 응답 지연, 실패율, 가용성 체크

3. **개발/디버깅**

   * 로컬에서 간단히 확인 가능
   * `curl http://localhost:8080/status` → 서버가 정상 기동 중인지 확인

---

### 📝 **핵심 요약**

* 헬스 체크 = “서버 살아있나요?” 확인용 API
* `/status` 엔드포인트가 200 OK 응답을 주면 서버 상태 정상


---


# 📌 React Router Loader 정리

### 🔄 리액트 렌더링 기본 실행 순서

1. 렌더링 수행
2. 서버에서 데이터 페칭
3. 상태 변수 변경
4. 다시 렌더링 수행

👉 문제: **페이지가 렌더링되기 전에 데이터를 미리 가져오고 싶다**
👉 해결: **`loader` 함수 사용**

---

## 🔹 loader 함수

* `loader`는 라우터에서 작성한다.
* **언제 실행되나?**

   * 페이지가 라우팅될 때 **단 한 번** 트리거됨.

```jsx
{
  path: 'events',
  element: <EventLayout />,
  children: [
    {
      index: true,
      element: <EventPage />,
      loader: async () => {
        const response = await fetch('http://localhost:9000/api/events');
        return await response.json();
      }
    },
    {
      path: ':eventId',
      element: <EventDetailPage />
    }
  ]
}
```

---

## 🔹 useLoaderData()

* `loader`가 리턴한 데이터는 해당 페이지와 **그 하위 컴포넌트에서 언제든 사용 가능**하다.

```jsx
const eventList = useLoaderData();
```

---

## 🔹 loader 코드 분리 (아웃소싱)

* 라우터에 서버 통신 코드를 직접 쓰면 코드가 길어짐 → 별도 파일로 분리 권장
* `loader`가 `fetch` 결과를 바로 리턴하면, 알아서 `json` 추출까지 해준다.

```jsx
// route-config.jsx
import { eventDetailLoader } from '../loader/events-loader.js';

const router = createBrowserRouter([
  {
    path: ':eventId',
    element: <EventDetailPage />,
    loader: eventDetailLoader
  }
]);

// loader/events-loader.js
export const eventDetailLoader = async ({ params }) => {
  return await fetch(`http://localhost:9000/api/events/${params.eventId}`);
};
```

---

## 🔹 params 객체

* `params`에는 라우트 경로에서 정의한 **동적 파라미터 값**이 들어간다.
* 예시

   * path: `":eventId"`
   * URL: `"/events/123"`
   * 결과: `params = { eventId: "123" }`

👉 즉, `params`를 통해 **현재 URL이 가리키는 리소스의 id**를 가져올 수 있다.


---



# 📌 useNavigate

* `useNavigate`는 `react-router-dom`에서 제공하는 훅
* 코드에서 `라우팅`을 제어할 때 사용
* `useNavigate()`를 호출하면 `navigate` 함수를 반환
* `navigate("경로")`를 실행하면 해당 경로로 이동

### ✨ 주요 사용법

```jsx
import { useNavigate } from 'react-router-dom';

const Example = () => {
  const navigate = useNavigate();

  // 특정 경로 이동
  const goToHome = () => navigate('/');

  // 뒤로가기
  const goBack = () => navigate(-1);

  // 앞으로 가기
  const goForward = () => navigate(1);

  // replace 옵션: 뒤로가기 기록 남기지 않음
  const goToLogin = () => navigate('/login', { replace: true });

  // state 전달
  const goWithState = () => navigate('/events', { state: { from: 'mypage' } });

  return (
    <>
      <button onClick={goToHome}>홈</button>
      <button onClick={goBack}>뒤로</button>
      <button onClick={goToLogin}>로그인</button>
    </>
  );
}
```

### 📝 useNavigate 정리

* `navigate('/path')` → 지정한 경로로 이동
* `navigate(-1)` → 브라우저 뒤로가기
* `navigate('/path', { replace: true })` → 기록을 남기지 않고 이동
* `navigate('/path', { state: {...} })` → state를 함께 전달 가능

---

# ✅ 최종 정리
- **CORS**: 프론트와 백엔드가 분리된 환경에서, 어떤 클라이언트 요청을 허용할지 백엔드에서 설정 필요
- **Health Check**: `/status` 같은 단순 API로 서버 상태(Alive 여부)를 확인 → 로드밸런서, 모니터링, 디버깅에 활용
- **React Router Loader**: 라우팅 시점에 데이터를 미리 가져와 컴포넌트에서 바로 활용 가능 → `useLoaderData()`로 조회
- **useNavigate**: 코드로 라우팅을 제어하는 훅 → 경로 이동, 뒤로가기, replace 이동, state 전달 가능

  
