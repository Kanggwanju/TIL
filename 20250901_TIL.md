# 🗓️ 2025년 9월 1일 TIL



리액트 서버요청 학습을 위한 프로젝트 생성

프론트: React, 백엔드: Spring Boot
프론트와 백엔드 서버가 따로 존재하기 때문에
프론트에서 백엔드에 요청 넣음
-> `CORS` 설정 필요

전역 크로스오리진 설정 : 허용할 클라이언트를 지정
```java
@Configuration
public class CorsConfig implements WebMvcConfigurer
```

CORS 허용(origin) URL을 배열로 관리 
```java
private String[] permitUrls = {
        "http://localhost:5173",
        "http://localhost:5174",
        "http://localhost:5175",
};
```

```java
@Override
    public void addCorsMappings(CorsRegistry registry) {
        registry
                .addMapping("/api/**")
                .allowedOrigins(permitUrls)
                .allowedMethods("*")
                .allowedHeaders("*")
                .allowCredentials(true)
        ;

    }
```
- addMapping: 클라이언트의 어떤 요청을 허용할지
- allowedOrigins: 어떤 Url을 허용할지
- allowedMethods: 어떤 요청방식을 허용할지 "GET", "POST" 등
- allowedHeaders: 어떤 헤더를 허용할지
- allowCredentials(true): 보안쿠키를 허용할지

---

**헬스 체크(Health Check) 엔드포인트**
- 배포된 API 서버가 “살아있는지, 응답이 가능한지”를 확인할 때 사용
---

## 📌 코드 해석

```java
@RestController
@Slf4j
public class HealthCheckController {

    @GetMapping("/status")
    public ResponseEntity<?> healthCheck() {
        return ResponseEntity.ok(
            Map.of(
                "healthy", true,
                "timestamp", LocalDateTime.now()
            )
        );
    }
}
```

* `/status`로 GET 요청 시 JSON 응답:

  ```json
  {
    "healthy": true,
    "timestamp": "2025-09-01T12:34:56.789"
  }
  ```
* `healthy: true` → 서버가 정상적으로 작동 중임을 알림
* `timestamp` → 호출 시점 기록

---

## 📊 실무에서 쓰임새

1. **로드 밸런서 / 쿠버네티스**

    * ELB, Nginx, Kubernetes 같은 곳에서 주기적으로 `/status` 호출
    * 200 OK이면 헬스 상태 정상, 실패면 인스턴스를 뺌

2. **모니터링**

    * Prometheus, Grafana 같은 모니터링 시스템에 붙여서 서버 상태 체크
    * 응답 지연, 실패율 등을 감시

3. **개발/디버깅**

    * 간단히 `curl http://localhost:8080/status` 해서 서버가 뜨는지 바로 확인 가능


---


loader 함수

리액트 기본 실행 순서
1. 렌더링 수행
2. 서버에서 데이터 페칭
3. 상태 변수 변경
4. 다시 렌더링 수행

데이터를 먼저 가져오고 싶다 -> loader 함수 사용

loader는 라우터에서 작성
loader 함수는 언제 실행되냐?
- 페이지가 라우팅될 때 단 한 번만 트리거 됨

```jsx
{
  path: 'events',
    element: <EventLayout />,
    children: [
    {
      index: true,
      element: <EventPage />,
      loader: async () => {
        const response = await fetch('http://localhost:9000/api/events');
        return await response.json();
      }
    },
    {
      path: ':eventId',
      element: <EventDetailPage />
    }
  ]
}
```


useLoaderData()
loader가 리턴한 데이터는 라우팅된 페이지와
그 하위 컴포넌트에서 언제든 사용가능

```jsx
// loader가 리턴한 데이터 가져오기
const eventList = useLoaderData();
```

근데, 라우터에 서버 통신 코드를 쓰면 너무 길어짐.
통신 코드를 로더 아웃소싱 해주면 된다.
- loader는 fetch 결과를 바로 리턴하는 경우 알아서 json을 추출





