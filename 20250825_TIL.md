# 🗓️ 2025년 8월 25일 TIL

## 🔑 오늘의 키워드

* React 프로젝트 초기 세팅 (Vite, npm)
* JSX 문법 규칙
* Virtual DOM & Reconciliation
* 함수형 컴포넌트 & Props
* Props Destructuring / Children / Composition
* 이벤트 바인딩 (SyntheticEvent)
* 상태 관리 (useState)
* Checkbox 상태값 관리 실습

---

## 🚀 리액트 프로젝트 시작하기

* 프론트엔드와 백엔드가 분리된 구조
* 주소도 각각 다르게 동작

### 새 프로젝트 생성

1. Node.js 설치
2. 프로젝트 생성

   ```bash
   npm create vite@latest 프로젝트폴더명
   ```

    * Proceed(y) → React → JavaScript 선택
3. 프로젝트 실행

   ```bash
   cd 프로젝트폴더명
   npm install
   npm run dev
   ```

### 깃허브에서 클론한 프로젝트 실행

1. `git clone`
2. `npm install` ← 최초 1번
3. `npm run dev` ← 프론트엔드 서버 실행 (종료 시 `Ctrl + C`)

### 개발 환경 팁

* VSCode Extension: **ES7+ React/Redux/React-Native snippets** 설치 추천

---

## 🧩 JSX 문법 규칙
- 리액트에서 사용하는 특수한 js문법, 태그를 그대로 쓰면 알아서 변환

- 규칙 :
1. return안에있는 태그는 반드시 하나의 태그로 묶여야 함.
2. 빈 태그(닫는 태그가 없는)는 반드시 /> 로 마감
3. 태그의 class속성은 자바스크립트 키워드 class와 겹쳐서 className으로 표기
4. 의미없는 부모는 <React.Fragment>로 감싸면 됨 ex) <>
5. 변수값이나 함수를 출력할 때는 {}로 감싸면 됨.

👉 ES6 문법으로 작성된 코드는 Babel 등의 트랜스파일러를 통해 ES5로 변환됨

---

## 리액트 작동 방식

* Virtual DOM 기반으로 동작
* 상태가 변경되면 전체 UI를 Virtual DOM에 리렌더링
* 이전 Virtual DOM과 비교하여 변경된 부분만 실제 DOM에 반영 (**Reconciliation**)

---

## 🏗️ 컴포넌트

* **클래스 컴포넌트**: 옛날 방식
* **함수형 컴포넌트**: 최신 권장 방식 (화살표 함수도 가능)
* 파일명은 보통 대문자로 시작 (`ExpenseItem.jsx`)
* CSS는 동일 이름의 `.css` 파일을 붙여 관리

예시:

```jsx
import ExpenseItem from './ExpenseItem';

<ExpenseItem />
```

---

## 🔗 Props

* 부모 → 자식 간 데이터 전달 메커니즘
* 문자열은 중괄호 생략 가능, 나머지는 중괄호 필요

### 기본 사용

```jsx
<ExpenseItem title="닭강정" price={8000} />
```

```jsx
const ExpenseItem = (props) => <h2>{props.title}</h2>;
```
- 자식 컴포넌트는 props를 전달받아서 사용, props는 객체임

### 디스트럭처링

```jsx
const ExpenseItem = ({ title, price, date }) => <h2>{title}</h2>;
```

### 객체 전달

```jsx
<ExpenseItem expense={{ title: '닭강정', price: 8000, date: new Date(2025, 7, 13) }} />
```

```jsx
const ExpenseItem = ({ expense }) => {
  const { title, price, date } = expense;
};
```

### 배열 전달 + alias

```jsx
<ExpenseList expenses={expenseList} />

const ExpenseList = ({ expenses: expenseList }) => {};
```
* props.expenses라는 속성을 꺼내서
* 지역 변수 이름을 expenseList로 바꿔 쓰겠다!

### Props Children (컴포지션)

* **셀프 클로징 컴포넌트**

  ```jsx
  <ExpenseList expenses={expenseList} />
  ```
- props만 넘기고 바로 닫는 방식

* **Children 전달 (Composition)**

  ```jsx
  <Card className="expenses">
    <ExpenseItem expense={expenseList[0]} />
    <ExpenseItem expense={expenseList[1]} />
  </Card>
  ```
- <Card> ... </Card> 사이에 **자식 컴포넌트(children)**를 넣는 방식
- React에서는 **컴포지션(Composition)**이라고 부름
  (즉, 컴포넌트를 “합성해서” 더 큰 UI를 만드는 패턴)
- Card 컴포넌트 안에서 props.children으로 접근 가능

`Card` 컴포넌트 예시:

```jsx
const Card = ({ children, className = '' }) => {
  return (
    <div className={`card ${className}`}>
      {children}
    </div>
  );
};
```
- props 객체를 children, className(기본값: '')으로 나눠서 디스트럭쳐링
- className은 클래스 명을 짓는 데에 추가하고,
- children은 div 태그 사이에 넣어줌

---

## 🖱️ 이벤트 바인딩

* camelCase 네이밍 사용 (`onClick`, `onChange`)
* 함수 레퍼런스를 태그 속성에 전달
* 실제로는 인라인 방식처럼 보이지만, React 내부적으로 `addEventListener` 방식으로 처리됨
* 이벤트 객체는 **SyntheticEvent**

```jsx
function handleClick() {
  console.log('Button was clicked!');
}

<button onClick={handleClick}>버튼</button>
```

---

## 🌀 상태값과 useState Hook

* 상태(state): 컴포넌트 내부에서 관리되는 데이터
* 상태값이 변경되면 컴포넌트가 리렌더링됨
* `useState`는 \[state, setState] 배열을 반환

```jsx
const [myState, setMyState] = useState(initialValue);
setMyState(newValue);
```
- 리턴값은 배열
- 파라미터는 초기 값
- 첫번째 요소는 관리할 상태값의 초기값
- 두번째 요소는 해당 상태값을 변경할 때 사용하는 setter 함수

---

## 📝 상태값 관리 연습문제

**목표**

* input[checkbox]에 change 이벤트가 걸려서
* check 상태가 바뀔 때마다 상태변수를 논리값으로 업데이트하여
* label의 클래스를 유동적으로 변경해야함.

**동작 흐름**

1. 사용자가 체크박스를 클릭한다.
   → 브라우저가 `input`의 `checked` 속성을 `true`로 바꾼다.

2. `onChange` 이벤트가 발생하고, 이벤트 핸들러 `handleChange`가 실행된다.
   → 이때 `e.target.checked` 값은 **최신화된 값**이다.

3. `setStatus(e.target.checked)` 실행 → `status` 상태가 최신값으로 갱신된다.
   → (처음 클릭 시 `false → true`, 다시 클릭 시 `true → false`)

4. React가 리렌더링을 수행한다.

    * `<input checked={status}>` → 상태값에 맞춰 체크박스 UI 반영
    * `<label className={status ? 'checked' : 'unchecked'}>` → 라벨 클래스도 갱신됨

5. 최종 결과:

    * 처음엔 `unchecked`
    * 클릭 시 `checked`
    * 다시 클릭하면 다시 `unchecked`

**코드**

```jsx
const CheckBoxStyle = () => {
  const [status, setStatus] = useState(false);

  const handleChange = (e) => setStatus(e.target.checked);

  return (
    <div className="checkbox-container">
      <input
        type="checkbox"
        id="styled-checkbox"
        checked={status}
        onChange={handleChange}
      />
      <label
        className={status ? 'checked' : 'unchecked'}
        htmlFor="styled-checkbox"
      >
        Check me!
      </label>
    </div>
  );
};
```

**핵심 요약**

* `setState`는 비동기 → 직후엔 값이 반영되지 않음
* 하지만 `e.target.checked`는 최신 DOM 상태 → 안전하게 활용 가능
* `checked={status}`로 컨트롤드 컴포넌트 유지 → UI와 상태 일치
* 라벨 클래스도 `status` 값에 따라 안정적으로 반영 가능

---

## 📝 오늘의 정리

* 오늘은 React 기초 흐름(프로젝트 세팅 → JSX → 컴포넌트 → Props → 이벤트 바인딩 → 상태 관리)을
  전체적으로 복습
* 특히 **Props Children(컴포지션)**과 useState를 활용한 상태 관리를 실습하며 흐름을 더 잘 이해함
* 체크박스 상태 관리 연습을 통해 컨트롤드 컴포넌트 개념을 체득
