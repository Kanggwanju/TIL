# 🗓️ 2025년 8월 25일 TIL


리액트 프로젝트 시작하기

이제는 프론트와 백엔드가 분리되어 있음.
주소도 달라짐

## 리액트 앱 실행하기

1. nodejs 설치
2. `npm create vite@latest 프로젝트폴더명`
    - proceed(y) -> React -> Javascript 선택
3. `cd 프로젝트폴더명` -> `npm install` -> `npm run dev`

## 깃허브에서 클론한 리액트 프로젝트인 경우
1. `git clone`
2. `npm intall` <- 최초 1번
3. `npm run dev` <- 프론트엔드 서버 실행 (서버켤 때마다 실행)

- 서버 끌때는 터미널에서 Ctrl + C, Ctrl + Z

vsCode로 할려면 ES7+ React/Redux/React-Native snippets
Extension 다운로드하고 쓰면 됨.



jsx : 리액트에서 사용하는 특수한 js문법, 태그를 그대로 쓰면 알아서 변환
 - 규칙 :
 1. return안에있는 태그는 반드시 하나의 태그로 묶여야 함.
 2. 빈 태그(닫는 태그가 없는)는 반드시 /> 로 마감
 3. 태그의 class속성은 자바스크립트 키워드 class와 겹쳐서 className으로 표기
 4. 의미없는 부모는 <React.Fragment>로 감싸면 됨 ex) <>
 5. 변수값이나 함수를 출력할 때는 {}로 감싸면 됨.


ES6 문법으로 썼을 때 ES5로 Babel 같은 트랜스파일러를 통해 변환됨.


## 리액트의 작동 방식

리액트는 'Virtual DOM'이라는 개념을 도입함으로써 효율적으로 동작
- 애플리케이션의 상태가 변경될 때마다 전체 UI를 Virtual DOM에 리렌더링
- 이전 Virtual DOM과 비교하여 실제로 변화가 필요한 부분만 실제 DOM에 반영
- 이 과정을 '재조정(reconciliation)'이라고 함


리액트에서는 import 할 때 확장자 생략 가능, 바닐라에서는 안 됨.


## 컴포넌트
클래스 컴포넌트: 옛날 방식

함수형 컴포넌트 : 최신 방식
함수형으로 정의하므로 화살표 함수로 가능

일반적으로 파일 이름은 첫글자 대문자 이후 확장자는 .jsx로 주로 하고, .js도 가능

컴포넌트를 다른 곳에서 import 해서 적용하려면
ex) ExpenseItem.jsx -> <ExpenseItem />

보통 개별 컴포넌트에 css를 적용하기 위해서는 똑같은 이름.css를 씀.



## React Props
- 컴포넌트를 따로 정의했을 때 날짜가 변경되어야 할 필요성이 있다면
  그 부분을 Props를 이용해 처리 가능
- "props"는 속성(properties)을 의미
- 컴포넌트 간에 데이터를 전달하는 메커니즘을 제공
- 데이터는 부모 컴포넌트에서 자식 컴포넌트로 전달

1. 부모 컴포넌트가 자식 컴포넌트를 호출할 때 props를 전달
- 문자열만 중괄호 생략 가능, 나머지는 중괄호 사용
ex) <ExpenseItem title='닭강정' price={8000} />

2. 자식 컴포넌트는 props를 전달받아서 사용, props는 객체임
ex) <h2>{props.title}</h2>

### Props 디스트럭쳐링
props는 객체이므로 객체를 받을 때 미리 디스트럭쳐링을 하면
title로 바로 쓸 수 있음
ex)
```jsx
const ExpenseItem = ({title, price, date}) => {
   return <h2>{title}</h2>;
};
```


### props로 객체 전달하기

```jsx
const ExpenseList = () => {
  
  return (
    <div className='expenses'>
      <ExpenseItem expense={
        {
         title: '닭강정',
         price: 8000,
         date: new Date(2025, 7, 13)
        }
      }/>
    </div>
  );
};

export default ExpenseList;
```

객체 전달받기
```jsx
// expense는 props에서 가져와서 디스트럭쳐링
const ExpenseItem = ({expense}) => {
  
  // expense를 디스트럭쳐링
  const {title, date, price} = expense;
}
```

### props로 배열 전달하기
- props로 배열을 전달함: `<ExpenseList expenses={expenseList} />`
- 받을 때: `const ExpenseList = ({ expenses: expenseList }) => {}`
  * props.expenses라는 속성을 꺼내서
  * 지역 변수 이름을 expenseList로 바꿔 쓰겠다!


### props children
- 이전까진 컴포넌트의 태그를 바로 닫았지만, 오프닝/클로징 태그를 통해
- children을 전달할 수 있음.

1. 셀프 클로징 컴포넌트 (Self-Closing Component)
```jsx
<ExpenseList expenses={expenseList} />
```
- props만 넘기고 바로 닫는 방식
- 자식(children)이 없는 경우에 자주 씀
- 흔히 “셀프 클로징” 또는 “self-closing tag”라고 부름



2. 오프닝/클로징 태그 + children 전달
```jsx
<Card className='expenses'>
  <ExpenseItem expense={expenseList[0]} />
  <ExpenseItem expense={expenseList[1]} />
  <ExpenseItem expense={expenseList[2]} />
</Card>
```
- <Card> ... </Card> 사이에 **자식 컴포넌트(children)**를 넣는 방식
- React에서는 **컴포지션(Composition)**이라고 부름
  (즉, 컴포넌트를 “합성해서” 더 큰 UI를 만드는 패턴)
- Card 컴포넌트 안에서 props.children으로 접근 가능

Card 컴포넌트
```jsx
const Card = ({ children, className='' }) => {
   return (
       <div className={`card ${className}`}>
          {children}
       </div>
   );
};
```
- props 객체를 children, className(기본값: '')으로 나눠서 디스트럭쳐링
- className은 클래스 명을 짓는 데에 추가하고,
- children은 div 태그 사이에 넣어줌



### 리액트 이벤트 바인딩
- 이벤트 핸들러 네이밍은 camelCase를 사용
- 이벤트 핸들러를 태그 속성으로 직접 지정
  * 함수 레퍼런스 전달: `onClick={handleClick}`
- 하지만 정말로 인라인 방식으로 넣는 것처럼 작동하지 않고,
- 리액트가 addEventListener를 사용하는 것처럼 처리함

바인딩 예시
```jsx
function handleClick() {
    console.log('Button was clicked!');
}

function MyButton() {
    return (
        <button onClick={handleClick}>버튼1</button>
    );
}
```

### 상태값과 useState Hook
- 상태(state)란 컴포넌트 내부에서 관리되는 데이터를 의미
- 상태값은 사용자의 입력, API 응답 등으로 인해 시간에 따라 변할 수 있는 값
- 상태가 변경되면 컴포넌트는 재렌더링됨


useState 훅
- 리턴값은 배열
- 파라미터는 초기 값
- 첫번째 요소는 관리할 상태값의 초기값
- 두번째 요소는 해당 상태값을 변경할 때 사용하는 setter 함수

예시)
```jsx
function MyComponent() {
    const [myState, setMyState] = useState(initialState);

    // 사용 예
    setMyState(newValue);
}
```



## 📌 React 상태값 관리 연습문제

### 1. 목표

* input[checkbox]에 change이벤트가 걸려서
* check상태가 바뀔 때마다 상태변수를 논리값으로 업데이트하여
* label의 클래스를 유동적으로 변경해야함.

---

### 2. 동작 흐름 정리

1. 사용자가 체크박스를 클릭한다.
   → 브라우저가 `input`의 `checked` 속성을 `true`로 바꾼다.

2. `onChange` 이벤트가 발생하고, 이벤트 핸들러 `handleChange`가 실행된다.
   → 이때 `e.target.checked` 값은 **최신화된 값**이다.

3. `setStatus(e.target.checked)` 실행 → `status` 상태가 최신값으로 갱신된다.
   → (처음 클릭 시 `false → true`, 다시 클릭 시 `true → false`)

4. React가 리렌더링을 수행한다.

    * `<input checked={status}>` → 상태값에 맞춰 체크박스 UI 반영
    * `<label className={status ? 'checked' : 'unchecked'}>` → 라벨 클래스도 갱신됨

5. 최종 결과:

    * 처음엔 `unchecked`
    * 클릭 시 `checked`
    * 다시 클릭하면 다시 `unchecked`

---

### 3. 코드 예시

```jsx
const CheckBoxStyle = () => {
  const [status, setStatus] = useState(false);

  const handleChange = (e) => {
    setStatus(e.target.checked);
  };

  return (
    <div className='checkbox-container'>
      <input
        type='checkbox'
        id='styled-checkbox'
        checked={status}        // 컨트롤드 컴포넌트
        onChange={handleChange} // change 이벤트
      />
      <label className={status ? 'checked' : 'unchecked'} htmlFor='styled-checkbox'>Check me!</label>
    </div>
  );
};

export default CheckBoxStyle;
```

---

### 4. 핵심 요약

* React에서 `setState`는 비동기 → 상태 업데이트 직후엔 바로 값이 반영되지 않는다.
* 하지만 이벤트 객체의 `e.target.checked`는 **최신화된 DOM 상태**를 담고 있어, 이를 상태값으로 저장하는 게 안전하다.
* `checked={status}`로 컨트롤드 컴포넌트를 만들면 상태와 UI가 항상 일치한다.
* 따라서 라벨의 클래스도 `status`를 기준으로 안정적으로 동기화할 수 있다.
