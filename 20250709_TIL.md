# 🗓️ 2025년 7월 9일 TIL



람다 mapping
origin: [ {}, {}, {}, {} ]
-> filter: [ {}, {}, {} ]
-> map :   [ '', '', '' ]


스트림 API (Stream API)
* 컬렉션(예: List, Set) 또는 배열의 데이터를 함수형 스타일로 처리할 수 있는 강력한 도구
* 데이터를 필터링, 매핑, 정렬, 집계하는 등의 작업을 간단하게 수행 가능


스트림 API의 주요 특징:

* 스트림은 한 번만 사용 가능, 한 번 처리된 스트림은 다시 사용할 수 없음
* 지연 연산(lazy execution)을 지원
* 중간 연산은 즉시 실행되지 않고, 최종 연산이 호출될 때 연속적으로 처리
* 병렬 처리를 지원하여 성능을 향상

스트림 API의 기본적인 사용법:

1. **데이터 소스 생성**: 스트림을 생성
2. **중간 연산**: 스트림의 데이터를 변환하거나 필터링
3. **최종 연산**: 스트림의 데이터를 처리하고 결과를 반환


예시
List<Dish> vegetarianList = menuList.stream() // 1. 데이터 소스 생성
    .filter(Dish::isVegetarian)               // 2. 중간연산
    .collect(toList());            // 3. 최종연산


스트림
데이터 소스의 요소를 함수형 스타일로 처리하는 추상화된 도구
데이터를 저장하지 않으며, 한 번만 사용할 수 있음


중간 연산 (Intermediate Operations)
스트림의 요소들을 변환하거나 필터링하는 연산
- **`filter(Predicate<T>)`**: 주어진 조건에 맞는 요소만을 필터링
- **`map(Function<T, R>)`**: 요소를 다른 형태로 변환
- **`sorted()`**: 스트림의 요소들을 정렬
- **`limit(long n)`**: 처음 `n`개의 요소만을 포함하는 스트림을 반환
- **`distinct()`**: 중복된 요소를 제거


최종 연산 (Terminal Operations)
스트림의 요소들을 처리하여 결과를 반환하는 연산
- **`forEach(Consumer<T>)`**: 각 요소를 처리
- **`collect(Collector<T, A, R>)`**: 스트림의 요소들을 특정 자료구조로 수집
- **`reduce(BinaryOperator<T>)`**: 스트림의 요소들을 결합하여 하나의 값을 반환
- **`count()`**: 스트림의 요소 수를 반환
- **`findFirst()`**: 첫 번째 요소를 반환
- **`anyMatch(Predicate<T>)`**: 조건에 맞는 요소가 하나라도 있는지 확인



```java
// 요리 목록에서 요리 이름과 칼로리만 추출해서
// 새 객체에 담아 포장하여 리스트에 담고 싶음.
// 1. Map을 생성하여 내용을 담고 리턴
List<Map<String, Object>> menuDetails = menuList.stream()
    .map(menu -> {
        Map<String, Object> menuMap = new HashMap<>();
        menuMap.put("menuName", menu.getName());
        menuMap.put("calories", menu.getCalories());
        return menuMap;
    })
    .collect(toList());

menuDetails.forEach(System.out::println);


// 2. 따로 클래스를 만들어서 생성자를 통해 객체 생성, 반환
List<SimpleDish> simpleDishList = menuList.stream()
    .map(menu -> new SimpleDish(menu))
    .collect(toList());
simpleDishList.forEach(System.out::println);
```
따로 클래스를 만드는 방식은 생성자에서 받아들인 파라미터를
통해 필드를 초기화하는 방식을 취한다.

```java
// 300 칼로리 이상인 요리 중 칼로리가 낮은 탑3 요리를 필터링
menuList.stream()
    .filter(m -> m.getCalories() >= 300)
    .sorted(Comparator.comparing(dish -> dish.getCalories()))
    .limit(3)
    .forEach(System.out::println);
```

