# 🗓️ 2025년 8월 6일 TIL



UserService에서 트랜잭션을 처리
@Transactional 어노테이션을 통해
성공하면 commit
실패하면 rollback


UserService의 회원가입 
서비스에서 user 엔터티를 바로 사용하면 위험함
이유로서는 데이터베이스와 연결되는 모든 정보가
user에 담겨져있기 때문이고, 엔터티가 왔다갔다 하면서
중요한 정보가 누설되거나 DB에 문제가 생길 수 있기 때문임
그래서 서비스에서는 request dto를 받아서 회원가입 진행(DB에 회원정보 insert)

입력값 검증을 위해 build.gradle에 검증 관련 의존성 추가
```text
implementation 'org.springframework.boot:spring-boot-starter-validation'
```

SignUpRequest의 필드명은 클라이언트가 전송할 때 사용할 
JSON의 key가 되니 프론트개발자와 협업이 필요하다.
필드명에는 @NotBlank 어노테이션 등을 추가하여 검증 가능

회원가입을 했으면 응답이 필요
-> 서비스의 회원가입 로직에서 사용자 정보를 return 해야함.
-> 반환해줘야할 정보만 있는 UserResponse DTO 제작
-> 정적 팩토리 메서드 패턴 (from 메서드) 이용해서 리턴



API응답은 언제나 일관적인게 중요함
- 객체, 배열, 문자열 형태 등으로 응답

# 클라이언트 개발자 입장
fetch().then(res => res.json()) 등
응답 형태에 따라 대응을 달리 해야함.
-> 일관적인 응답 객체(공통 응답, ApiResponse)를 만들어서 줌


---

회원가입을 할 때 사용자명, 이메일 중복 체크를 해줘서
예외를 GlobalExceptionHandler에게 줘야함

에러를 throw 했음 -> 어떤 에러 코드이고,
에러 정보가 무엇인지 알려줘야함
`throw new BusinessException("사용자명이 중복되었습니다.", 404, "not found");`
-> 하지만 세가지를 매번 적어야하고, 중복된 것이 나올 수 있음
-> 에러코드를 enum으로 관리



@JsonInclude(JsonInclude.Include.NON_NULL)
- 값이 null인 프로퍼티는 응답에서 제외

---

비밀번호는 해시로 변경해서 데이터베이스에 저장해줘야함.
-> 스프링 시큐리티 의존성 주입

```text
implementation 'org.springframework.boot:spring-boot-starter-security'
```

시큐리티 초기 설정 필수!

잠시 구조 설명
우리는 WAS로 Tomcat을 사용하고 있음
Tomcat 내부에 App이 있고,
App 내부에 Controller, Service, Repository가 있으며
Repository와 데이터베이스가 데이터를 주고받고있음

클라이언트(프론트엔드)에서 DTO로 앱이 정보를 받고,
디스패쳐서블릿이 그 DTO를 받아서 컨트롤러중
알맞은 컨트롤러에 매핑해서 가져다 줌

디스패쳐서블릿과 컨트롤러 사이에 필터를 통해
제한을 두는 것을 스프링 시큐리티의 SecurityFilterChain이 해줌.

SecurityFilterChain
- CSRF 공격 설정 off - JWT 인증방식을 방해하기 떄문
- CORS 설정 off - 우리가 따로 나중에 수동설정할 예정
- 세션 관리 설정을 JWT에 맞게 함
- 로그인 기본 폼 제거
- 기본 인증 비활성화

위는 기본으로 써주는편
---

회원가입할 때 비밀번호는 PasswordEncoder를 통해 해시로 암호화하고,
dto를 엔터티로 변경해줘서 db에 넣어주면 된다.
```java
// 비밀번호 암호화를 위한 객체
private final PasswordEncoder passwordEncoder;

// 패스워드를 해시로 암호화
String encodedPassword = passwordEncoder.encode(requestDto.getPassword());

// dto를 entity로 변경
User user = User.builder()
        .email(requestDto.getEmail())
        .username(requestDto.getUsername())
        .password(encodedPassword)
        .build();

// db에 insert 명령
User saved = userRepository.save(user);
```

---
로그인 로직
1. 사용자 조회(이름, 이메일)
```java
String inputAccount = loginRequest.getUsernameOrEmail();
User user = userRepository.findByUsername(inputAccount)
        .orElseGet(() -> userRepository.findByEmail(inputAccount)
                .orElseThrow(
                        () -> new BusinessException(ErrorCode.USER_NOT_FOUND)
                )
        );
```
- 사용자명 혹은 이메일명을 통해 로그인이 가능하도록 작성
- 사용자명으로 찾아보고 만약 없다면 .orElseGet()을 통해 이메일로 검증
- 이메일로 검증을 했는데도 DB에 정보가 없다면 가입하지 않은 사람으로 판명
- 에러를 글로벌 예외 핸들러에게 Throw 한다.

2. 비밀번호 검증
```java
// 사용자가 입력한 패스워드 ( 평문 )
String inputPassword = loginRequest.getPassword();

// DB에 저장된 패스워드 ( 암호문 )
String storedPassword = user.getPassword();

// 평문을 다시 해시화해서 암호화한후 비교
if (!passwordEncoder.matches(inputPassword, storedPassword)) {
    throw new BusinessException(ErrorCode.INVALID_PASSWORD);
}
```
- 평문을 해시화해서 암호화하고 비교했을때 다르다면
- 비밀번호가 틀린 것, 예외를 throw.
