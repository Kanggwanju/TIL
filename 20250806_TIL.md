# 🗓️ 2025년 8월 6일 TIL

## 🔑 오늘의 키워드
- 트랜잭션
- DTO & Entity
- 입력값 검증
- 회원가입
- 로그인
- 비밀번호 암호화
- Spring Security
- 예외 처리 & 에러 코드 관리

---

## 1. 트랜잭션 처리

* `@Transactional` 어노테이션을 사용해 **메서드 단위 트랜잭션** 관리 가능

    * **성공 시** → commit
    * **실패 시** → rollback

```java
@Transactional
public void signUpUser(SignUpRequest request) {
    // 회원가입 로직
}
```

---

## 2. DTO 사용 이유

* 서비스에서 \*\*엔터티(User)\*\*를 직접 사용하면 위험
    * DB와 연결되는 모든 정보가 노출됨
    * 정보 유출, 의도치 않은 DB 변경 위험
* 해결책 → **Request DTO**로 요청 받고, **Entity**로 변환 후 저장

---

## 3. 입력값 검증 (Validation)

* `build.gradle`에 검증 라이브러리 추가

```gradle
implementation 'org.springframework.boot:spring-boot-starter-validation'
```

* DTO 필드명은 클라이언트의 JSON key와 매칭 → 프론트엔드와 협업 필요
* 예: `@NotBlank` 등을 사용해 값 검증

```java
public class SignUpRequest {
  @NotBlank(message = "이메일은 필수입니다.")
  private String email;

  @NotBlank(message = "사용자명은 필수입니다.")
  private String username;
}
```

---

## 4. 응답 DTO & 일관된 API 응답

* 회원가입 후 → 필요한 정보만 담은 UserResponse DTO 반환
* 정적 팩토리 메서드(from)로 변환
* API 응답은 항상 일관성 유지 (ApiResponse 사용)
    * 클라이언트는 응답 구조에 따라 fetch 처리 로직을 다르게 해야 하기 때문

---

## 5. 예외 처리 & 에러 코드 관리

* 회원가입 시 이메일/사용자명 중복 체크
* 예외 발생 → GlobalExceptionHandler로 전달
* 매번 에러 메시지, 코드, 설명을 작성하면 중복 → Enum으로 에러 코드 관리

```java
throw new BusinessException(ErrorCode.DUPLICATE_USERNAME);
```

---

## 6. @JsonInclude

```java
@JsonInclude(JsonInclude.Include.NON_NULL)
```

* null 값 필드 제외 → 응답 데이터 가독성 향상

---

## 7. 비밀번호 암호화 & Security 기본 설정

* 비밀번호는 해시화 후 DB 저장
* 의존성 추가

```gradle
implementation 'org.springframework.boot:spring-boot-starter-security'
```

* 기본 설정

    * CSRF Off (JWT 사용 시 필요)
    * CORS 수동 설정
    * 세션 관리 → JWT 방식
    * 기본 로그인 폼 제거
    * 기본 인증 비활성화

---

## 8. 회원가입 로직 예시

```java
// 비밀번호 암호화
String encodedPassword = passwordEncoder.encode(requestDto.getPassword());

// DTO → 엔터티 변환
User user = User.builder()
        .email(requestDto.getEmail())
        .username(requestDto.getUsername())
        .password(encodedPassword)
        .build();

// DB 저장
User saved = userRepository.save(user);
```

---

## 9. 로그인 로직

### 9-1. 사용자 조회 (이름 또는 이메일)

* 로그인 시 **사용자명** 또는 **이메일**로 인증 가능
* 처리 순서

    1. 입력값을 받아 \*\*사용자명(username)\*\*으로 먼저 조회
    2. 없으면 `.orElseGet()`을 사용해 \*\*이메일(email)\*\*로 재조회
    3. 그래도 없으면 `BusinessException` 발생 → `GlobalExceptionHandler`에서 처리

```java
String inputAccount = loginRequest.getUsernameOrEmail();

User user = userRepository.findByUsername(inputAccount)
        .orElseGet(() -> userRepository.findByEmail(inputAccount)
                .orElseThrow(
                        () -> new BusinessException(ErrorCode.USER_NOT_FOUND)
                )
        );
```

---

### 9-2. 비밀번호 검증

* **입력된 평문 비밀번호**와 **DB 저장 암호문** 비교
* 평문을 `PasswordEncoder`로 해시화하여 비교
* 불일치 시 `INVALID_PASSWORD` 예외 발생

```java
// 사용자가 입력한 패스워드 ( 평문 )
String inputPassword = loginRequest.getPassword();

// DB에 저장된 패스워드 ( 암호문 )
String storedPassword = user.getPassword();

// 평문 → 해시 변환 후 비교
if (!passwordEncoder.matches(inputPassword, storedPassword)) {
    throw new BusinessException(ErrorCode.INVALID_PASSWORD);
}
```

---

## 📊 요약

| 기능            | 내용                      | 예외 코드                                 |
| ------------- | ----------------------- | ------------------------------------- |
| 회원가입          | DTO로 요청 받고 암호화 후 저장     | DUPLICATE\_USERNAME, DUPLICATE\_EMAIL |
| 로그인 - 사용자 조회  | username → email 순으로 조회 | USER\_NOT\_FOUND                      |
| 로그인 - 비밀번호 검증 | 평문 해시 후 비교              | INVALID\_PASSWORD                     |
| 응답 구조         | 일관된 ApiResponse 제공      | -                                     |
| 검증            | @NotBlank 등으로 입력값 체크    | -                                     |


