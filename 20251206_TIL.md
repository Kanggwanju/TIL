# 🗓️ 2025년 12월 6일 TIL - C언어

## 📌 오늘의 키워드

`이진 탐색 트리(Binary Search Tree)` `삽입(Insertion)`
`탐색(Search)` `중위 순회(Inorder Traversal)`
`재귀(Recursion)` `트리의 시간 복잡도`

---

## 1️⃣ 이진 탐색 트리(BST)란?

### 💡 정의

* **이진 탐색 트리(Binary Search Tree, BST)** 는
  각 노드가 **왼쪽 자식 < 부모 < 오른쪽 자식** 관계를 만족하는 **이진 트리**이다.
* 이 규칙 덕분에 **탐색(Search), 삽입(Insertion), 삭제(Deletion)** 연산을
  **효율적으로 수행**할 수 있다.

| 연산            | 평균 시간 복잡도 | 최악의 시간 복잡도     |
| ------------- | --------- | -------------- |
| 탐색(Search)    | O(log N)  | O(N) *(편향 트리)* |
| 삽입(Insertion) | O(log N)  | O(N)           |
| 삭제(Deletion)  | O(log N)  | O(N)           |

---

## 2️⃣ 노드 구조체

### 💻 구조체 정의

```c
typedef struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;
```

* `data`: 노드가 저장할 실제 값
* `left`, `right`: 각각 왼쪽, 오른쪽 자식 노드를 가리키는 포인터

---

## 3️⃣ 노드 삽입 함수

### 💻 코드

```c
TreeNode* insertNode(TreeNode* node, int key) {
    if (node == NULL) return createNode(key); // 삽입 위치 도달
    if (key < node->data)
        node->left = insertNode(node->left, key);
    else
        node->right = insertNode(node->right, key);
    return node;
}
```

### 📘 설명

* 삽입하려는 데이터(`key`)가 현재 노드보다 작으면 왼쪽 서브트리로 이동
* 크면 오른쪽 서브트리로 이동
* `node == NULL`인 지점에 새 노드를 생성하여 삽입

---

## 4️⃣ 탐색 (Search)

### 💡 재귀적 탐색 함수

```c
TreeNode* search_recursive(TreeNode* node, int key) {
    if (node == NULL) return NULL; // 탐색 실패
    if (key == node->data) return node; // 탐색 성공
    if (key < node->data)
        return search_recursive(node->left, key);
    else
        return search_recursive(node->right, key);
}
```

### 💡 반복문 기반 탐색 함수

```c
TreeNode* iterative(TreeNode* node, int key) {
    TreeNode* current = node;
    while (current != NULL) {
        if (key == current->data)
            return current;
        else if (key < current->data)
            current = current->left;
        else
            current = current->right;
    }
    return NULL; // 탐색 실패
}
```

---

## 5️⃣ 중위 순회 (Inorder Traversal)

### 💻 코드

```c
void inorder(TreeNode* node) {
    if (node == NULL) return;
    inorder(node->left);
    printf("[%d] ", node->data);
    inorder(node->right);
}
```

### 📘 특징

* **중위 순회(왼 → 중 → 오)** 는 BST의 데이터를 **오름차순으로 출력**한다.
* 즉, 정렬된 순서로 값을 얻을 수 있다.

---

## 6️⃣ 전체 트리 구성

```plaintext
                (50)
              /      \
           (30)       (80)
          /   \      /   \
       (20)  (40) (70)  (90)
```

### 삽입 순서

50 → 30 → 80 → 20 → 40 → 70 → 90

### 중위 순회 결과

```
[20] [30] [40] [50] [70] [80] [90]
```

---

## 7️⃣ 탐색 예시

### 💻 코드

```c
TreeNode* resultNode = search_recursive(root, 47);
if (resultNode != NULL)
    printf("탐색결과: %d\n", resultNode->data);
else
    printf("탐색 실패!!\n");
```

### 결과

```
탐색 실패!!
```

> (47은 존재하지 않기 때문)

---

## 8️⃣ 시간 복잡도 분석

| 상황                       | 설명                    | 복잡도      |
| ------------------------ | --------------------- | -------- |
| **균형 트리(Balanced Tree)** | 탐색 범위를 절반씩 줄임         | O(log N) |
| **편향 트리(Skewed Tree)**   | 정렬된 데이터를 순서대로 삽입 시 발생 | O(N)     |

**편향 트리 예시:**
데이터를 `10, 20, 30, 40, 50` 순서로 삽입하면 한쪽 방향으로만 뻗음
→ 리스트와 다를 바 없음

---

## 🎯 최종 정리

| 항목           | 내용                   |
| ------------ | -------------------- |
| **BST 특징**   | 왼쪽 < 루트 < 오른쪽        |
| **탐색**       | 비교 기반, 절반씩 탐색        |
| **중위 순회**    | 오름차순 출력              |
| **삽입 시 주의점** | 정렬된 입력은 트리 불균형 초래    |
| **복잡도**      | 평균 O(log N), 최악 O(N) |

---

## 💬 오늘의 소감

오늘은 **이진 탐색 트리(BST)** 의 원리와 삽입, 탐색, 순회를 학습했다.
재귀 함수를 통해 트리 구조가 자연스럽게 확장되는 과정을 이해할 수 있었고,
특히 중위 순회로 정렬된 출력이 되는 점이 인상 깊었다.
하지만 트리가 한쪽으로 기울어질 수 있다는 단점도 배웠다.
