### 2025년 5월 13일 TIL

커밋을 이미 해버리면 restore를 해도 복구할 수가 없다.
reset을 사용하면 잘못된 커밋을 되돌릴 수 있다.

git reset <commit-hash> 명령어는 현재 HEAD를 특정 커밋으로 이동시키는데 사용되며, 이전의 상태로 "되돌리고" 싶을 때 사용되는 명령어이다.


reset은 커밋을 삭제하는 명령어
완전히 사라지는것은 아니고, 브랜치에서 보이지 않게 되며, 그 커밋들은 Git 저장소 내에 존재하게 됨
= 복구의 가능성이 있음

| 옵션     | HEAD 이동 | Staging Area 초기화 | Working Directory 영향 | 설명 |
|----------|-----------|----------------------|--------------------------|------|
| `--soft` | ✅ 이동함 | ❌ 유지              | ❌ 유지                  | 커밋만 되돌리고 파일 상태는 유지 |
| `--mixed` (기본값) | ✅ 이동함 | ✅ 초기화 | ❌ 유지 | 커밋 + add 취소 (수정한 파일은 남음) |
| `--hard` | ✅ 이동함 | ✅ 초기화            | ✅ 초기화                | 파일까지 과거 상태로 완전히 되돌림 (되돌릴 수 없음) |

--hard 옵션을 사용하면 작업 디렉토리의 모든 변경사항이 사라지므로, 실수로 실행하면 작업 내용을 영구적으로 잃을 수 있습니다. 
## `git reset --hard ORIG_HEAD`
- 이 명령어는 reset을 잘못했을 때 취소할 수 있습니다.

혼자 작업할 때는 reset, 같이 작업할 때는 revert
github에 공유된 커밋은 reset해서는 안된다.
revert는 망친 커밋의 헤드를 이용
git revert를 사용하면 과거의 커밋을 "삭제"하는 것이 아니라, 그 커밋의 변경 사항을 취소하는 새로운 커밋을 추가함으로써 프로젝트의 히스토리를 유지



GitHub
주요 특징 및 기능
1. 코드 호스팅
2. 버전 관리
3. 협업
4. 이슈 트래킹 및 프로젝트 관리
5. 통합 및 확장

로컬 저장소
개발자의 개인 컴퓨터에 위치한 저장소입니다. 이는 git init 또는 git clone 명령을 통해 생성될 수 있다.

원격 저장소
깃허브에 올라가있는 저장소가 원격 저장소임. git push origin master
대표적인 원격 저장소 서비스로는 GitHub, GitLab, Bitbucket

Git Clone은 깃허브에 올라가있는 코드를 내 컴퓨터에 다운로드하는 명령어
git clone <repository_url>


Github에 원격 저장소 만들기
- 깃허브에 로그인하면 우측 상단에 + 버튼을 누르면 ‘New repository’ 메뉴
- 저장소 이름을 지어준 뒤 다른 옵션은 건드리지 말고 하단에 ‘Create repository’  클릭
- 그러면 원격 저장소가 생성되며 해당 저장소의 주소가 보임.
- 해당 주소를 복사
  
Git Remote - 원격 저장소를 관리하는 명령
로컬에서 get init이 된 곳에 git remote add를 하면 된다.

## git remote add - 원격 저장소를 추가할 때 사용하는 명령어
$ git remote add [별칭] [URL]
ex) $ git remote add origin <https://github.com/user/repo.git>

## git remote remove - 원격 저장소를 삭제(제거)할 때 사용하는 명령어
$ git remote remove [별칭]
ex) $ git remote remove origin

## git remote rename - 원격 저장소의 별칭을 변경할 때 사용하는 명령어
$ git remote rename [기존 별칭] [새 별칭]
ex) $ git remote rename origin upstream

## git remote show - 원격 저장소의 정보를 확인할 때 사용하는 명령어
$ git remote show [별칭]
ex) $ git remote show origin

## git remote -v - 추가된 원격 저장소의 목록을 확인할 때 사용하는 명령어
$ git remote -v

Git에서 origin이라는 별칭을 주로 사용하는 이유는 전통적인 관례 때문입니다. 
원격 저장소를 설정할 때 가장 처음 설정되는 저장소의 이름을 origin이라고 부르는 것이 Git의 일반적인 관례

모든 브랜치와 태그 업로드
$ git push --all
브랜치 별로 푸쉬
$ git push <remote> <branch>
<branch> 이름의 브랜치를 <remote>라는 원격 저장소에 푸시
<remote> : 원격 저장소의 별칭입니다. 일반적으로 origin이라는 이름을 사용하며, 이는 원격 저장소의 URL을 대신하는 역할
<branch> : 원격 저장소에 푸시할 로컬 저장소의 브랜치 이름

git push -u origin <branch-name> 명령은 브랜치를 원격 저장소로 푸시하고, 추가로 "upstream(상류)" 추적 정보를 설정하는 명령어
이렇게 설정하면 향후에 git pull 또는 git push 명령을 사용할 때,
추가적으로 브랜치 이름을 명시하지 않아도 Git은 이 연결을 기억하고 자동으로 해당 원격 브랜치에 대한 동작을 수행



원격 추적 브랜치(Remote Tracking Branch)는 Git에서 원격 저장소의 브랜치를 추적하는 로컬 브랜치를 의미
`origin/master`와 같이 표현되며, 여기서 origin은 원격 저장소의 이름이고, master는 원격 저장소의 브랜치 이름
origin/main은 원격 브랜치, 그냥 main은 로컬 브랜치(내가 관리하는 브랜치)


git branch -r 명령은 원격 저장소의 브랜치 목록을 표시하는 데 사용
git branch -a 명령은 로컬 및 원격 저장소의 모든 브랜치를 확인 가능


- git의 신기한 기능 중 하나는 원격 브랜치 이름으로 스위칭하면 바로 로컬에 같은 브랜치가 생성됨과 동시에 동기화되는 기능이 있는데요.
- 위 방법처럼 원격 브랜치로 체크아웃하고 브랜치를 생성하는 것이 아닌 다이렉트로 원격 브랜치이름을 스위칭하면 로컬에 바로 생성된다는 점입니다.


`git fetch`는 원격 저장소에서 정보를 가져오는 Git 명령
이 명령을 사용하면 원격 저장소의 최신 변경 사항을 로컬로 가져오지만, 작업 중인 브랜치에 이 변경 사항을 병합하거나 커밋하지 않습니다.
결론적으로 새로운 브랜치를 만들어서 최신 변경 사항을 가져오므로 git merge 명령을 사용하여 가져온 변경 사항을 현재의 브랜치에 병합하거나,
git checkout 명령을 사용하여 가져온 브랜치로 전환해야 한다.


fork할 때
copy the master branch only를 해제 그래야 모든 브랜치를 가져올 수 있음

git pull은 원격 Git 저장소의 변경 사항을 다운로드하고 자동으로 현재 브랜치에 이를 병합하는 Git 명령입니다.
이는 실질적으로 git fetch와 git merge 명령의 조합이다.


$ git pull [remote-name] [branch-name]
여기서 [remote-name]은 원격 저장소의 이름을 나타내며, [branch-name]은 병합할 원격 브랜치를 지정
ex) $ git pull origin main
Git은 origin 저장소의 main 브랜치의 변경 사항을 다운로드하고, 현재 브랜치에 이를 자동으로 병합
만약 작업 중인 브랜치에 아직 커밋되지 않은 변경 사항이 있다면, git pull을 실행하기 전에 이를 커밋하거나 스테시해야 합니다.
