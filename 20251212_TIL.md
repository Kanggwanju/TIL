# 🗓️ 2025년 12월 12일 TIL – C언어 기출 문제 풀이

## 📌 오늘의 키워드

`switch 폴스루` `스택(Stack)` `구조체 포인터`
`팩토리얼(재귀)` `문자열 포인터` `아스키 코드`
`비트 이동 연산` `삼항 연산자`
`2차원 배열` `포인터 배열` `문자열 복사` `Call by Value`

---

## 1️⃣ switch 문 폴스루(Fall-through) – 2023년 2회차

### 💻 코드

```c
#include <stdio.h>

// 2023년 2회차, switch 폴쓰루
int main(void) {
    
    int n[3] = {73, 95, 82};
    int sum = 0;

    for (int i = 0; i < 3; i++) {
        sum += n[i];
    }

    // 250 / 30 -> 몫: 8
    // 정답: BCD
    switch(sum / 30) {
        case 10:
        case 9: printf("A");
        case 8: printf("B");
        case 7: 
        case 6: printf("C");
        default: printf("D");
    }

    return 0;
}
```

### 🌱 핵심 개념

* `switch` 문에서 **break가 없으면 아래 case로 계속 실행**됨 → 폴스루
* `sum = 250`, `sum / 30 = 8`

### 🔁 실행 흐름

1. `case 8` → `"B"` 출력
2. break 없음 → `case 7, 6` → `"C"`
3. break 없음 → `default` → `"D"`

### ✅ 출력 결과

```
BCD
```

> 한 줄 정리: **switch에서 break가 없으면 멈추지 않고 끝까지 내려간다**

---

## 2️⃣ 스택(Stack) 구현 – 2023년 2회차

### 💻 코드

```c
#include <stdio.h>
#define MAX_SIZE 10

int isWhat[MAX_SIZE];
int point = -1;

int isEmpty() {return point == -1; }
int isFull() {return point == MAX_SIZE - 1; }

// push
void into(int num) {
    if (!isFull()) isWhat[++point] = num;
}

// pop
int take() {
    if (isEmpty()) return -1;
    else return isWhat[point--];
}


// 2023년 2회차, 스택
int main(void) {
    
    into(5); into(2);

    while (!isEmpty()) {
        printf("%d ", take());
        into(4); into(1); printf("%d ", take());
        into(3); printf("%d ", take()); printf("%d ", take());
        into(6); printf("%d ", take()); printf("%d ", take());
    }

    // 정답: 2 1 3 4 6 5

    return 0;
}
```

### 🌱 핵심 개념

* **스택(Stack)**: LIFO (Last In First Out)
* `push → ++point`, `pop → point--`

### 🔁 핵심 흐름 요약

* `into(5), into(2)` → top = 2
* `take()` 할 때마다 **가장 마지막에 넣은 값**이 나옴

### ✅ 출력 결과

```
2 1 3 4 6 5
```

> 한 줄 정리: **스택은 마지막에 들어간 데이터가 가장 먼저 나온다**

---

## 3️⃣ 구조체 변수 vs 구조체 포인터 – 2023년 3회차

### 💻 코드

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Data {
    char c;
    int *numPtr;
} Data;

// 2023년 3회차, 빈칸 찾기, 구조체 변수, 구조체 포인터
int main(void) {
    
    int num = 10;
    // 구조체 변수 d1.c, d1.numPtr
    Data d1;
    // 구조체 포인터 d2->c, d2->numPtr
    Data *d2 = malloc(sizeof(Data));

    d1.numPtr = &num;
    
    // d2 /* 빈칸 */ numPtr = &num;
    // 정답: ->
    d2->numPtr = &num;

    printf("%d\n", *d1.numPtr);
    printf("%d\n", *d2->numPtr);

    free(d2);

    return 0;
}
```

### 🌱 핵심 개념

* 구조체 **변수** → `.` 사용
* 구조체 **포인터** → `->` 사용

### ✅ 출력 결과

```
10
10
```

> 한 줄 정리: **구조체 포인터는 반드시 `->`로 접근**

---

## 4️⃣ 재귀 함수로 팩토리얼 – 2023년 3회차

### 💻 코드

```c
#include <stdio.h>

int f(int n) {
    if (n <= 1) return 1;
    else return n * f(n - 1);
}

// 2023년 3회차, 팩토리얼 함수
int main(void) {
    
    // 정답: f(7) = 7 * f(6) = ... = 7*6*5*4*3*2*1 = 5040
    printf("%d", f(7));

    return 0;
}
```

### 🌱 핵심 개념

* 재귀 함수 = **자기 자신을 다시 호출**
* 종료 조건이 없으면 무한 호출 → 스택 오버플로우

### ✅ 출력 결과

```
5040
```

---

## 5️⃣ 문자열 포인터 & 아스키 코드 – 2023년 3회차

### 💻 코드

```c
#include <stdio.h>

// 2023년 3회차, 문자열 포인터, 아스키 값
int main(void) {
    
    char* p = "KOREA";

    printf("%s\n", p);        // KOREA
    printf("%s\n", p + 1);    // OREA
    printf("%c\n", *p);       // K
    printf("%c\n", *(p + 3)); // E
    printf("%c\n", *p + 4);   // K + 4 -> 75 + 4 -> 79 -> O

    // 참고: A: 65, a: 97, '0': 48

    return 0;
}
```

### 🌱 핵심 개념

* `*p + 4` → 문자 연산이 아니라 **아스키 값 연산**
* `'K'(75) + 4 = 'O'(79)`

### ✅ 출력 결과

```
KOREA
OREA
K
E
O
```

---

## 6️⃣ 삼항 연산자 & 비트 이동 – 2024년 1회차

### 💻 코드

```c
#include <stdio.h>

// 2024년 1회차, 비교연산, 삼항연산자, 비트 이동 연산
int main(void) {
    
    int v1 = 0, v2 = 35, v3 = 29;

    // 1. v1 > v2 -> 0 > 35는 False, v1(0) 실행
    // 2. v1(0)은 False이므로 else 실행
    if (v1 > v2 ? v2 : v1) {
        v2 = v2 << 2;
    } else {
        // 비트 이동 연산
        // << : 2^n 곱하기
        // >> : 2^n 나누기
        v3 = v3 << 2; // 29 * 4 = 116
    }

    // 정답: 35 + 116 = 151
    printf("%d", v2 + v3);

    return 0;
}
```

### 🌱 핵심 개념

* 삼항 연산자는 **조건 결과 자체를 if 조건으로 사용 가능**
* `<< 2` = 4배

### ✅ 출력 결과

```
151
```

---

## 7️⃣ 문자열 뒤집기 – 2024년 1회차

### 💻 코드

```c
#include <stdio.h>
#include <string.h>

void reverse(char* str) {
    // null 문자 빼고 문자열 길이 계산
    int len = strlen(str);
    char temp;
    char* p1 = str;
    char* p2 = str + len - 1;
    while (p1 < p2) {
        // Swap 연산
        temp = *p1;
        *p1 = *p2;
        *p2 = temp;
        p1++;
        p2--;
    }
}

// 2024년 1회차, 문자열 뒤집기
int main(void) {

    char str[100] = "ABCDEFGH";

    // str: HGFEDCBA
    reverse(str);

    // len: 8
    int len = strlen(str);

    // 정답: GECA
    for (int i = 1; i < len; i += 2) {
        printf("%c", str[i]);
    }

    printf("\n");
    
    return 0;
}
```

### 🌱 핵심 개념

* 포인터 두 개로 문자열 양쪽에서 중앙으로 교환
* 뒤집은 후 **홀수 인덱스만 출력**

### ✅ 출력 결과

```
GECA
```

---

## 8️⃣ 구조체 + 이자 계산 – 2024년 1회차

### 💻 코드

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int accNum;
    double bal;
} BankAcc;

double calcPower(double base, int year) {
    double r = 1.0;
    for (int i = 0; i < year; i++) {
        r *= base;
    }
    return r;
}

void initAcc(BankAcc *acc, int accNumber, double balance) {
    acc->accNum = accNumber;
    acc->bal = balance;
}

void transact(BankAcc *acc, double *amount) {
    if (*amount > 0 && *amount < acc->bal) {
        acc->bal -= *amount;
    } else {
        acc->bal += *amount;
    }
}

void applyInterest(BankAcc *acc) {
    acc->bal *= calcPower(1 + 0.1, 3);
}

// 2024년 1회차
int main(void) {

    BankAcc myAcc;
    initAcc(&myAcc, 9981, 2200.0);

    double amount = 100.0;

    // myAcc.bal: 2100.0
    transact(&myAcc, &amount);

    // myAcc.bal: 2795.1
    applyInterest(&myAcc);

    // 정답: 9981 and 2795.10
    printf("%d and %.2f\n", myAcc.accNum, myAcc.bal);
    
    return 0;
}
```

### 🌱 핵심 개념

* 구조체를 **함수 인자로 포인터로 전달**
* `acc->field` 형태로 구조체 멤버 접근
* 이자 계산은 `1.1³`을 직접 곱해서 구현

### 🔁 실행 흐름

1. 초기 잔액 `2200`
2. `transact()` → 100 출금 → `2100`
3. `applyInterest()` → `2100 × 1.1³ = 2795.1`

### ✅ 출력 결과

```
9981 and 2795.10
```

> 한 줄 정리: **구조체 포인터 + 함수 분리 패턴 문제**

---

## 9️⃣ 아스키 코드 변환 – 2024년 1회차

### 💻 코드

```c
#include <stdio.h>
#include <ctype.h>

// 2024년 1회차, 아스키 코드
int main(void) {
    
    char* p = "It is 8";
    char result[100];
    int i;

    // 참고: A: 65, a: 97, '0': 48
    for (i = 0; p[i] != '\0'; i++) {
        if (isupper(p[i])) // 대문자면 true
            result[i] = (p[i] - 'A' + 5) % 26 + 'A';
        else if (islower(p[i])) // 소문자면 true
            result[i] = (p[i] - 'a' + 10) % 26 + 'a';
        else if (isdigit(p[i])) // 숫자면 true
            result[i] = (p[i] - '0' + 3) % 10 + '0';
        else
            result[i] = p[i];
    }

    result[i] = '\0';
    // 정답: Nd sc 1
    printf("%s\n", result);

    return 0;
}
```

### 🌱 핵심 개념

* 문자 종류 판별: `isupper / islower / isdigit`
* **아스키 기준으로 이동 후 다시 문자로 복원**
* `% 26`, `% 10` → 알파벳/숫자 순환 처리

### 🔁 변환 예시

* `'I' → 'N'` (대문자 +5)
* `'t' → 'd'` (소문자 +10)
* `'8' → '1'` (숫자 +3)

### ✅ 출력 결과

```
Nd sc 1
```

> 한 줄 정리: **아스키 코드 + 나머지 연산 조합 문제**

---

## 🔟 2차원 배열 & 포인터 배열 – 2024년 2회차

### 💻 코드

```c
#include <stdio.h>

// 2024년 2회차, 2차원 배열, 포인터 배열
int main(void) {

    int arr[3][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    // arr[1]: {4, 5, 6}, arr[2]: {7, 8, 9}
    int* parr[2] = { arr[1], arr[2] };

    // 정답: 8 + 9 + 4 = 21
    printf("%d", parr[1][1], + *(parr[1] + 2) + **parr);
    
    return 0;
}
```

### 🌱 핵심 개념

* `arr[i]`는 **1차원 배열의 시작 주소**
* `int* parr[]` → 포인터들의 배열
* `**parr` = `parr[0][0]`

### 🔁 값 해석

* `parr[1][1]` → `8`
* `*(parr[1] + 2)` → `9`
* `**parr` → `4`

### ✅ 결과

```
21
```

---

## 1️⃣1️⃣ 문자열 복사 – 2024년 2회차

### 💻 코드

```c
#include <stdio.h>
#include <string.h>

void sumFn(char* d, const char* s) {
    while (*s) {
        // s가 가리키고 있는 것을 d가 가리키고 있는 것에 넣음
        *d++ = *s++;
    }
    *d = '\0';
}

// 2024년 2회차, 문자열 복사
int main(void) {
    
    const char* str1 = "first";
    char str2[50] = "teststring";
    int result = 0;

    // str2: f i r s t \0 r i n g \0
    sumFn(str2, str1);

    for (int i = 0; str2[i] != '\0'; i++) {
        result += i;
    }

    // 정답: 10
    printf("%d", result);

    return 0;
}
```

### 🌱 핵심 개념

* 문자열 복사는 **포인터 증가 방식**
* `\0` 만날 때까지 반복
* 이후 남은 문자열은 무시됨

### 🔁 결과 계산

* `"first"` 길이 = 5
* `0 + 1 + 2 + 3 + 4 = 10`

---

## 1️⃣2️⃣ Call by Value & switch 폴스루 – 2024년 2회차

### 💻 코드

```c
#include <stdio.h>

void swap(int a, int b) {
    int t = a;
    a = b;
    b = t;
}

// 2024년 2회차, Call by Value, Switch 폴쓰루
int main(void) {
    
    int a = 11;
    int b = 19;

    // Call by Value로 a와 b의 값이 바뀌지 않음
    swap(a, b);

    switch(a) {
        case 1: b += 1;
        case 11: b += 2;
        default: b += 3;
        break;
    }

    // 정답: a - b = 11 - 24 = -13
    printf("%d", a - b);

    return 0;
}
```

### 🌱 핵심 개념

* `swap()`은 **Call by Value** → 원본 값 변경 ❌
* `switch`에서 `case 11` 진입 후 break 없음 → 폴스루

### 🔁 흐름

* `b = 19`
* `case 11` → `+2`
* `default` → `+3`
* `b = 24`

### ✅ 결과

```
-13
```

---

## 🎯 오늘의 최종 정리

* 포인터 문제는 **“무엇을 가리키는가”를 끝까지 추적**
* 구조체 포인터 접근은 `->`
* `switch`는 항상 **break 유무 체크**
* 문자열 문제는 `\0` 기준
* Call by Value / Reference 구분 필수
* 스택은 **push / pop 흐름을 손으로 추적**
* 아스키 문제는 **숫자로 바꿔서 계산**
* 문자열 문제는 **포인터 + 아스키 코드** 조합이 자주 출제됨
* 비트 연산은 `2의 거듭제곱 배수`로 바로 해석

---

## 💬 오늘의 소감

이번 TIL은 **단순 암기용이 아니라**,
코드를 한 줄씩 따라가면서 **머릿속으로 메모리 구조를 그려보는 연습**이 됐다.

특히

* 포인터 배열
* 구조체 포인터
* switch 폴스루
  이 세 가지는 시험뿐만 아니라
  **실제 C 코드 읽을 때도 실수하기 쉬운 포인트**라는 걸 확실히 느꼈다.
