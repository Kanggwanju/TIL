# 🗓️ 2025년 11월 13일 TIL - c언어

## 📌 오늘의 키워드

`재귀 함수 (Recursion)` `스택 메모리 (Call Stack)` `종료 조건 (Base Case)` `팩토리얼` `피보나치 수열` `하노이의 탑` `재귀적 사고`

---

## 1️⃣ 재귀 함수의 개념

### 💡 정의

* **재귀 함수(Recursive Function)** :
  자기 자신을 다시 호출하는 함수
* 프로그램이 재귀를 처리하는 핵심은 **콜 스택(Call Stack)** 구조에 있다.

  * LIFO(Last In, First Out) 구조
  * 마지막에 호출된 함수가 가장 먼저 종료된다.

### 재귀의 두 가지 필수 요소

1. **종료 조건(Base Case)** — 무한 재귀를 방지하는 탈출 조건
2. **재귀 호출(Recursive Call)** — 문제를 더 작은 단위로 줄이는 과정

---

## 2️⃣ 기본 예제: Countdown 함수

### 💻 예시 코드

```c
void countdown(int n) {
    if (n <= 0) {
        printf("발사!\n");
        return;
    }
    printf("%d...\n", n);
    countdown(n - 1);
}
```



### 🔍 동작 과정

* `countdown(3)` 호출 시

  ```
  3...
  2...
  1...
  발사!
  ```
* 재귀 호출마다 n이 1씩 감소하며, 0 이하가 되면 종료된다.

---

## 3️⃣ 팩토리얼 계산

### 💻 예시 코드

```c
int factorial(int n) {
    if (n == 1) return 1;
    return n * factorial(n - 1);
}
```



### 🔍 실행 순서 (factorial(5))

```
= 5 * factorial(4)
= 5 * 4 * factorial(3)
= 5 * 4 * 3 * factorial(2)
= 5 * 4 * 3 * 2 * factorial(1)
= 120
```

### 특징

* 수학적 정의를 그대로 코드로 옮길 수 있어 표현이 직관적이다.
* 단, **함수 호출 스택이 깊어지면 메모리 사용량이 많아진다.**

---

## 4️⃣ 피보나치 수열

### 💻 예시 코드

```c
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```



### 🔍 동작 원리

* `fibonacci(7)` → `f(6) + f(5)`
* 각 하위 호출마다 다시 2개의 재귀 호출 발생

### ⚠문제점

* 동일한 계산이 반복 수행되어 **비효율적 (O(2ⁿ))**
* 해결 방법: **메모이제이션(Memoization)** 또는 **반복문으로 구현**

---

## 5️⃣ 배열의 합 (재귀로 구현)

### 💻 예시 코드

```c
int sum_array(int arr[], int n) {
    if (n <= 0) return 0;
    return arr[n - 1] + sum_array(arr, n - 1);
}
```



### 🔍 실행 흐름

```
sum_array([10,20,30,40,50],5)
= 50 + sum_array(...,4)
= 50 + 40 + 30 + 20 + 10 = 150
```

### 🧠 포인트

* 배열의 합을 for문 없이 계산 가능.
* 재귀 호출의 “누적” 개념을 익히기에 좋은 예제.

---

## 6️⃣ 하노이의 탑

### 💻 예시 코드

```c
void hanoi(int n, char from, char by, char to) {
    if (n == 1)
        printf("원반 1을 %c에서 %c로 옮긴다.\n", from, to);
    else {
        hanoi(n - 1, from, to, by);
        printf("원반 %d을(를) %c에서 %c로 옮긴다.\n", n, from, to);
        hanoi(n - 1, by, from, to);
    }
}
```



### 🔍 핵심 아이디어

1. `n-1`개의 원반을 보조 기둥으로 옮긴다.
2. 가장 큰 원반 1개를 목표 기둥으로 이동.
3. 다시 `n-1`개의 원반을 목표 기둥으로 이동.

### 📈 이동 횟수

* 총 이동 횟수 = **2ⁿ - 1**
* `n=3`일 때 → 7번 이동

---

## 7️⃣ 다양한 재귀 패턴

### (1) 위 → 아래 순서 출력

```c
void func(int k) {
    if (k > 0) {
        func(k - 1);
        printf("%d", k);
    }
}
```


출력 결과: `123`

### (2) 자릿수 합 구하기

```c
int func(int n) {
    if (n < 10) return n;
    return (n % 10) + func(n / 10);
}
```


예: `253 → 2 + 5 + 3 = 10`

### (3) 양쪽 재귀 호출

```c
void func(int n) {
    if (n > 0) {
        func(n - 1);
        printf("%d ", n);
        func(n - 1);
    }
}
```


출력: `1 2 1 3 1 2 1`

---

## 🎯 최종 정리

| 구분    | 특징             | 시간 복잡도          | 예시                   |
| ----- | -------------- | --------------- | -------------------- |
| 단순 재귀 | 자기 자신을 반복 호출   | O(n) ~ O(2ⁿ)    | Countdown, Factorial |
| 중첩 재귀 | 한 호출에 여러 재귀 포함 | O(2ⁿ)           | Fibonacci, Hanoi     |
| 꼬리 재귀 | 마지막에 자기 자신 호출  | O(n) (스택 절약 가능) | Countdown            |

---

## 💬 오늘의 소감

오늘은 재귀 함수의 구조와 동작 원리를 다양한 예시를 통해 익혔다.
특히 콜 스택에 함수 호출이 쌓였다가 **반대로 출력되는 원리**를 눈으로 확인하면서,
재귀는 단순 반복이 아닌 **문제 분할(분할 정복, Divide and Conquer)** 의 기반이라는 점을 깨달았다.
