# 🗓️ 2025년 7월 31일 TIL



QueryDSL
- 타입-세이프한 SQL-like 쿼리를 자바에서 사용할 수 있게 해주는 프레임워크
- 타입-세이프(type-safe)란 컴파일 시점에 데이터 타입의 유효성을 검사하는 기능
- 쿼리를 빌더 패턴을 사용하여 만듬.
- QueryDSL은 다양한 플랫폼에서 사용이 가능합니다. JPA, JDO, SQL, MongoDB, Lucene, Hibernate Search 등에서 사용가능

QueryDSL이 Spring JPA의 단점을 보완하는 방법
1. 동적 쿼리 작성의 용이성:
    Spring Data JPA 복잡한 동적 쿼리의 경우 메서드 이름을 통한 쿼리 생성에 한계가 있음
   QueryDSL을 사용하면, 동적으로 쿼리를 만들어 사용할 수 있습니다.

2. 컴파일 시점의 쿼리 오류 발견

간단한 쿼리(INSERT, UPDATE, DELETE, 단순조회) -> Spring JPA
조금 복잡한 쿼리 (간단한 조인, 간단한 그룹바이) -> QueryDSL
완전 복잡한 쿼리 or DBMS에 종속적인 쿼리 -> JDBC


QueryDSL을 사용하는 Gradle 설정 (spring boot 3)
build.gradle
```text
dependencies {
    // ... 기존내용
    
    // QueryDSL 의존성 추가
    implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
    annotationProcessor 'com.querydsl:querydsl-apt:5.0.0:jakarta'
    annotationProcessor 'jakarta.annotation:jakarta.annotation-api'
    annotationProcessor 'jakarta.persistence:jakarta.persistence-api'
}
```

### **검증용 Q 타입 생성**

**Gradle IntelliJ 사용법**

- Gradle → Tasks → build → clean
- Gradle → Tasks → build → build

**Gradle 콘솔 사용법**
- ./gradlew clean build

**소스루트 설정**
- build 폴더를 열어서 generated 폴더를 오른쪽 마우스 클릭 
- → 디렉터리를 다음으로 표시 → 소스 루트 클릭



QType과 JPAQueryFactory
Q-Type
 - QueryDSL이 생성하는 엔티티 메타 모델 클래스.
 - 엔티티 클래스를 기준으로 Q 클래스가 생성
 - 이 클래스를 통해 타입 안정성이 보장된 쿼리를 작성 가능

JPAQueryFactory
 - QueryDSL을 이용하여 쿼리를 생성하는 핵심 클래스
 - 엔티티 매니저를 통해 초기화되며, 쿼리를 빌더 패턴으로 조립할 수 있음

---

JPAQueryFactory 초기화

Config 파일
- QueryDsl의 핵심객체 JPAQueryFactory를 스프링에게 맡기는 설정 (빈 수동 등록)
```java
@Configuration
@RequiredArgsConstructor
public class QueryDslConfig {

    private final EntityManager em;

    @Bean
    public JPAQueryFactory factory() {
        return new JPAQueryFactory(em);
    }

}

```

테스트 파일
```java
class QueryDslBasicTest {
    // Config 파일에서 빈 수동 등록
    @Autowired
    JPAQueryFactory factory;  // QueryDsl 핵심객체
}
```


---

QueryDsl where절 사용
```java
@Test
@DisplayName("QueryDsl로 특정 이름의 아이돌 조회하기")
void queryDslTest() {
    //given

    //when
    Idol foundIdol = factory
            .selectFrom(QIdol.idol)
            .where(idol.idolName.eq("사쿠라"))
            .fetchOne();

    //then
    System.out.println("\n\nfoundIdol = " + foundIdol);
    System.out.println("foundIdol.getGroup() = " + foundIdol.getGroup());
}
```
테스트 코드 설명
- `QIdol.idol`은 스태틱 임포트 하면 `idol`로 바로 쓸 수 있음.
- import static com.spring.database.querydsl.entity.QIdol.*;
- JPAQueryFactory를 이용하여 쿼리를 빌더 패턴을 사용하여 만들었음.

---

다양한 where 절 사용법

idol.idolName.eq("리즈") // idolName = '리즈'
idol.idolName.ne("리즈") // idolName != '리즈'
idol.idolName.eq("리즈").not() // idolName != '리즈'
idol.idolName.isNotNull() //이름이 is not null
idol.age.in(10, 20) // age in (10,20)
idol.age.notIn(10, 20) // age not in (10, 20)
idol.age.between(10,30) //between 10, 30
idol.age.goe(30) // age >= 30
idol.age.gt(30) // age > 30
idol.age.loe(30) // age <= 30
idol.age.lt(30) // age < 30
idol.idolName.like("_김%")  // like _김%
idol.idolName.contains("김") // like %김%
idol.idolName.startsWith("김") // like 김%
idol.idolName.endsWith("김") // like %김

where 절 2가지 동시 조건 - and 사용
```java
Idol foundIdol = factory
        .selectFrom(idol)
        .where(
                idol.idolName.eq(name)
                        .and(idol.age.eq(age))
        )
        .fetchOne();
```

---

결과 반환 방법

fetch() : 다중 행 조회
- 쿼리 결과를 리스트로 반환
- 반환타입: List<T>

fetchFirst() : 다중행 조회에서 첫번째 행을 반환
- 결과가 없으면 null 반환
- 반환타입: T

fetchOne() : 단일행 조회
- 결과가 없거나 여러 개인 경우 예외를 발생 시킴
- 반환 타입: T

단일행 조회시 NPE에 취약하기 때문에 Optional을 사용하고 싶을 때는??
```java
Optional<Idol> fetchOne = Optional.ofNullable(
        factory
                .selectFrom(idol)
                .where(idol.idolName.eq("김채원"))
                .fetchOne()
);

Idol foundIdol = fetchOne.orElse(new Idol());
```

fetchOne.orElseThrow( 에러 커스터마이징 )
-> null이면 에러 커스터마이징을 사용해서 글로벌 예외 핸들러에게 반환가능

fetchOne.orElse(new Idol())
-> 결과가 null일 경우 새로운 아이돌 생성

---

정렬

기본적으로 .orderBy() 사용
오름차 조건.asc()
내림차 조건.desc()
두 조건을 쓰고싶다면 `,`로 연결해서 사용

```java
List<Idol> sortedIdols = factory
        .selectFrom(idol)
        .orderBy(idol.age.desc(), idol.idolName.asc())
        .fetch();
```

---

페이징 처리

sql 문법을 사용한 페이징 처리
```sql
SELECT *
FROM tbl_student
ORDER BY stu_name
LIMIT 5 OFFSET 5
;
```
LIMIT: 한번에 몇개까지 보여줄것인지
OFFSET: 어디서부터 보여줄건지 (첫번째 데이터가 0번)
`LIMIT 5 OFFSET 1` -> 첫번째 데이터부터 5개 보여줌  

---

QueryDsl로 페이징 처리 테스트 
```java
@Test
@DisplayName("페이징 처리 하기")
void pagingTest() {
    //given
    int limit = 2;
    int pageNo = 1;
    int offset = (pageNo - 1) * limit;

    //when
    List<Idol> idolList = factory
            .selectFrom(idol)
            .orderBy(idol.age.desc())
            .offset(offset)
            .limit(limit)
            .fetch();

    //then
    System.out.println("\n\n============  results  ==============");
    idolList.forEach(System.out::println);
}

```
테스트 코드 설명
보통 클라이언트는 offset을 주지않고 pageNo를 줌
-> offset을 (pageNo - 1) * limit로 설정하여
페이지 번호만 주면 해당하는 페이지의 정보를 DB에서 꺼낼 수 있게 함.


