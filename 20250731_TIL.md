# 🗓️ 2025년 7월 31일 TIL - QueryDSL

## ✅ QueryDSL 개념

* **타입-세이프한 SQL-like 쿼리**를 자바에서 사용할 수 있게 해주는 프레임워크
* **타입-세이프(Type-safe)**: 컴파일 시점에 타입 검사를 수행하여 오류를 방지
* **빌더 패턴**을 활용한 쿼리 생성
* **사용 가능 플랫폼**: JPA, JDO, SQL, MongoDB, Lucene, Hibernate Search 등

---

## ✅ Spring Data JPA의 단점 보완

1. **동적 쿼리 작성 용이**

    * Spring JPA는 메서드 이름 기반 쿼리에 한계 있음
    * QueryDSL은 유연하게 동적 쿼리 구성 가능

2. **컴파일 시점 오류 탐지**

    * 문법 오류를 런타임 전에 잡을 수 있음

---

## ✅ 상황별 쿼리 도구 선택

| 쿼리 복잡도             | 추천 도구               |
| ------------------ | ------------------- |
| 단순 CRUD            | Spring Data JPA     |
| 중간 복잡도 (간단한 조인/그룹) | QueryDSL            |
| 고난이도 or DBMS 의존 쿼리 | JDBC (Native Query) |

---

## ✅ Gradle 설정 (Spring Boot 3 기준)

build.gradle
```groovy
dependencies {
    implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
    annotationProcessor 'com.querydsl:querydsl-apt:5.0.0:jakarta'
    annotationProcessor 'jakarta.annotation:jakarta.annotation-api'
    annotationProcessor 'jakarta.persistence:jakarta.persistence-api'
}
```

---

## ✅ Q타입 생성과 소스 루트 설정

### 💡 IntelliJ에서 Q타입 생성 방법

* Gradle → Tasks → build → clean
* Gradle → Tasks → build → build

### 💡 콘솔 사용법

```bash
./gradlew clean build
```

### 💡 Q타입 소스 루트 설정

* `build/generated` 폴더 우클릭 → **디렉터리를 다음으로 표시 → 소스 루트**

---

## ✅ Q타입 & JPAQueryFactory

### 🔹 Q타입 (Q 클래스)

* 엔티티 클래스 기준으로 생성되는 **메타 모델 클래스**
* 타입 안정성 보장

### 🔹 JPAQueryFactory

* 쿼리를 **빌더 패턴**으로 조립할 수 있는 핵심 클래스
* `EntityManager`를 주입받아 초기화

### JPAQueryFactory 초기화

#### Config 파일

- QueryDsl의 핵심객체 JPAQueryFactory를 스프링에게 맡기는 설정 (빈 수동 등록)
```java
@Configuration
@RequiredArgsConstructor
public class QueryDslConfig {
    private final EntityManager em;
    
    @Bean
    public JPAQueryFactory factory() {
        return new JPAQueryFactory(em);
    }
}
```

#### 테스트 파일
```java
class QueryDslBasicTest {
    // Config 파일에서 빈 수동 등록
    @Autowired
    JPAQueryFactory factory;  // QueryDsl 핵심객체
}
```

---

## ✅ QueryDSL 기본 쿼리 예시

### ▶ 이름으로 조회 (where절)

```java
@Test
@DisplayName("QueryDSL로 특정 이름의 아이돌 조회")
void queryDslTest() {
    Idol foundIdol = factory
        .selectFrom(idol)
        .where(idol.idolName.eq("사쿠라"))
        .fetchOne();

    System.out.println("foundIdol = " + foundIdol);
}
```

💡 `QIdol.idol`은 `import static com.spring.database.querydsl.entity.QIdol.*`로 간단히 사용 가능

---

## ✅ 다양한 where절 사용법

```java
idol.idolName.eq("리즈")           // = '리즈'
idol.idolName.ne("리즈")           // != '리즈'
idol.idolName.eq("리즈").not()     // != '리즈'
idol.idolName.isNotNull()          // is not null
idol.age.in(10, 20)                // IN (10, 20)
idol.age.notIn(10, 20)             // NOT IN (10, 20
idol.age.between(10, 30)           // BETWEEN 10 AND 30
dol.age.goe(30)                    // >= 30
idol.age.gt(30)                    // > 30
idol.age.loe(30)                   // <= 30
idol.age.lt(30)                    // < 30
idol.idolName.like("_김%")         // like _김%
idol.idolName.contains("김")       // like %김%
idol.idolName.startsWith("김")     // like 김%
idol.idolName.endsWith("김")       // like %김
```

### ▶ and 조건

```java
.where(
    idol.idolName.eq(name)
        .and(idol.age.eq(age))
)
```

---

## ✅ 결과 반환 방식

| 메서드            | 설명                 | 반환 타입     |
| -------------- | ------------------ | --------- |
| `fetch()`      | 여러 행 반환            | `List<T>` |
| `fetchFirst()` | 첫 행만 반환 (없으면 null) | `T`       |
| `fetchOne()`   | 단일 행 (여러 개면 예외 발생) | `T`       |

### ▶ Optional로 감싸기 (NPE 방지)

```java
Optional<Idol> optionalIdol = Optional.ofNullable(
    factory.selectFrom(idol)
           .where(idol.idolName.eq("김채원"))
           .fetchOne()
);

Idol foundIdol = optionalIdol.orElseThrow(
        () -> new IdolNotFoundException("해당 아이돌은 존재하지 않습니다.")
);
```

fetchOne.orElseThrow( 에러 커스터마이징 )
-> new IdolNotFoundException: 내가 만든 커스텀 예외 객체

커스텀 예외 클래스
```java
public class IdolNotFoundException extends RuntimeException {
    public IdolNotFoundException(String message) {
        super(message);
    }
}
```
- 직접 만든 예외는 글로벌 예외 처리(@ControllerAdvice)로
  잡아서 사용자에게 친절하게 메시지를 줄 수 있음.


fetchOne.orElse(new Idol())
-> 결과가 null일 경우 새로운 아이돌 생성

---

## ✅ 정렬 (Order By)

```java
List<Idol> sorted = factory
    .selectFrom(idol)
    .orderBy(idol.age.desc(), idol.idolName.asc())
    .fetch();
```

* `조건.asc()` → 오름차순
* `조건.desc()` → 내림차순

---

## ✅ 페이징 처리

### ▶ SQL 기준

```sql
SELECT * FROM tbl_student
ORDER BY stu_name
LIMIT 5 OFFSET 5;
```

* **LIMIT**: 몇 개까지 보여줄지
* **OFFSET**: 어디서부터 보여줄지 (0부터 시작)

### ▶ QueryDSL 페이징 테스트 코드

```java
@Test
@DisplayName("페이징 처리")
void pagingTest() {
    int limit = 2;
    int pageNo = 1;
    int offset = (pageNo - 1) * limit;

    List<Idol> idols = factory
        .selectFrom(idol)
        .orderBy(idol.age.desc())
        .offset(offset)
        .limit(limit)
        .fetch();

    idols.forEach(System.out::println);
}
```
- 보통 클라이언트는 offset을 주지않고 pageNo를 줌
- 하지만 실제 DB는 페이지 번호가 아닌
- **"어디서부터 몇 개를 가져올지"**를 알아야 함 -> OFFSET, LIMIT 필요
- 보통 프론트엔드가 `page=3&size=10` 같은 쿼리 파라미터로 요청
- limit = 10, offset = (pageNo - 1) * limit -> 20
- DB의 21번째 데이터부터 10개 보여주면 된다.

---

## 🧠 정리 요약

| 기능     | 사용법 요약                                  |
| ------ | --------------------------------------- |
| 조건 검색  | `.where(조건)`                            |
| 정렬     | `.orderBy(조건.asc(), 조건.desc())`         |
| 페이징 처리 | `.offset(n).limit(m)`                   |
| 결과 추출  | `fetch()`, `fetchOne()`, `fetchFirst()` |

