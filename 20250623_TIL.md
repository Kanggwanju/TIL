# 🗓️ 2025년 6월 23일 TIL


자바
- 객체 지향 프로그래밍 패러다임을 따르며
    클래스와 객체를 통해 코드의 재사용성과 유지보수성을 높임
- 플랫폼 독립적
  자바 프로그램은 자바 가상 머신에서 실행되며, 운영 체제에 상관없이
  동일한 코드가 실행될 수 있음
- 강력한 메모리 관리
  가비지 컬렉터를 통해 메모리 관리를 자동으로 처리하여 메모리 누수를 방지
- 멀티스레드 지원
  멀티스레딩을 기본적으로 지원하여, 병렬 처리를 쉽게 구현할 수 있음
- 풍부한 라이브러리
  방대한 표준 라이브러리(API)를 제공하여 다양한 기능을 쉽게 구현 가능


자바 다운로드!


기본 문법
- 정적 타이핑 언어
  자료형을 반드시 명시해야하고, 컴파일 타임에 타입 검사를 수행하여 오류를 미리 잡음

1. 변수와 데이터 타입

정수 타입 (byte: 1, short: 2, int: 4, long: 8)

1byte == 8bit -> 10진수 정수 8 => 0 0001000
-128 ~ 127
제일 앞은 부호비트

2byte == 16bit -> 10진수 정수 1000 => 1111101000
-32768 ~ 32767

long x4 = 2147483648155616511L;
뒤에 L을 붙이는 이유
| 상황               | 설명                                 |
| ---------------- | ---------------------------------- |
| 자바 정수 리터럴 기본 타입  | `int` (4바이트)                       |
| 너무 큰 숫자 (21억 초과) | `int` 범위를 넘으면 컴파일 오류               |
| 해결책              | 숫자 뒤에 `L` 붙여서 `long` 타입 리터럴로 만들기   |
| 왜 `L`?           | long 타입임을 명시하기 위해 (소문자 l은 혼동되기 쉬움) |


실수 타입
float f1 = 3.123123131123F;     // 4byte - 7자리
double f2 = 3.123123131231;     // 8byte - 15자리

| 내용             | 설명                                          |
| -------------- | ------------------------------------------- |
| 실수 리터럴 기본 타입   | `double` (8바이트)                             |
| `float`에 저장하려면 | 숫자 뒤에 `F` 또는 `f`를 붙여야 함                     |
| 이유             | `double` → `float`은 자동 변환이 안 되고, 명시해야 함     |
| 주의             | `float`은 약 7자리 정밀도 → 너무 많은 소수 자릿수는 손실 발생 가능 |


논리 타입
boolean b1 = true;
boolean b2 = false;
boolean b3 = 10 < 5;

문자 타입
char c1 = 'A';      // 2byte - 0 ~ 65535
char c2 = 44032;    // 가


char[] cArr = {'h', 'e', 'l', 'l', 'o'};
String str = new String(cArr);    // hello

String str2 = "안녕하세요";

자바 17부터 지원
```java
        String str3 = """
                안녕
                메롱
                잘가\
                ㅋㅋㅋㅋ
                """;
```

동적 타이핑 지원 (java 9)
var z = 100;
var v = "gggg";





타입 캐스팅
java는 타입이 다른 데이터의 연산을 지원하지 않음
byte a = 100;
int b = a; // 암묵적 형 변환 (byte: 1 -> int: 4)


```java
/*
    var c
    0 0000000 00000000 00000011 11101000
    var d
    1 1101000
    
    음수를 표현하는 방식
    1의보수: 비트 반전
    1101000 -> 0010111
    2의보수: 1을 더함
    0010111
          1
    0011000
*/

int c = 1000;
byte d = (byte) c; // int: 4 -> byte: 1
// 명시적 형 변환 - 데이터 손실이 발생할 수 있음
System.out.println("d = " + d); // -24
```

int k = 50;   // 4byte
double j = k; // 8byte, 50.0

double m = 5.567;
int n = (int) m; // 명시적 형 변환 -> 데이터 손실
System.out.println("n = " + n); // 5, 소수점 버리기


암묵적(묵시적) 형 변환 -> upcasting (promotion)
명시적 형 변환 -> downcasting


```java
int v = 91;
double z = 6.6;
double result = v + z; // 97.6

int result2 = 'A' + v; // 156

int h = 5;
double result3 = 27 / (double) h; // 5.4
```


int 보다 작은 데이터(char, short, byte)들은 연산 결과가 무조건 int다.
byte b1 = 100;
byte b2 = 70;
int result4 = b1 + b2; // int



VarScope
java는 변수가 선언된 블록에서 생성되어
블록이 종료되면 메모리에서 자동 제거됨
if문 바깥에 x1이 있으므로 자바에서는 if문 내부에서 x1을 정의할 수 없음.
x2는 if 블록이 종료되면 메모리에서 자동 제거된다.
```java
int x1 = 10;
if (true) {
    int x2 = 20;
    System.out.println("x2 = " + x2);
} // if block
System.out.println("x1 = " + x1);
```

StandardIO
%d: 10진수 정수
%s: 문자열
%c: 문자 하나
%f: 실수
int month = 6;
int day = 6;
System.out.printf("오늘은 %d월 %d일입니다.\n", month, day);


java 15부터 가능
String message = "오늘은 %d월 %d일입니다.".formatted(month, day);
java 5부터 가능
String message2 = String.format("오늘은 %d월 %d일입니다.", month, day);

표준 입력
Scanner scanner = new Scanner(System.in);

System.out.print("나이: ");
int age = Integer.parseInt(scanner.nextLine());
System.out.println("age = " + age);

받아들이는 입력은 문자열이므로 Integer.parseInt()를 통해 숫자로 변경



배열
1. 동종모음 구조 (같은 타입끼리만 저장 가능)
2. 생성시의 크기가 불변함 (값을 안넣으면 기본값 초기화)

배열 생성
```java
// 1. 배열 변수를 선언 (스택에 변수를 선언)
int[] numbers; // 4byte? (X)
// 2. 배열을 생성 (힙에 데이터를 저장)
numbers = new int[5];
// 3. 배열을 초기화 (값 저장)
numbers[0] = 50;
numbers[1] = 77;
numbers[2] = (int) 66.7;
numbers[3] = numbers[0] * 2;
numbers[4] = 99;
System.out.println("numbers = " + numbers);
```

Arrays.toString(numbers) // [50, 77, 66, 100, 99]
numbers.length           //  5


배열 순회
for (int i = 0; i < numbers.length; i++) {
    System.out.println("데이터= " + numbers[i]);
}

enhanced for loop
for (int n : numbers) {
    System.out.println("n = " + n);
}

배열 단축 생성 문법
String[] pets = new String[] {"멍멍이", "야옹이", "짹짹이"};

변수를 선언할 때만 new Type[] 생략 가능
String[] pets = {"멍멍이", "야옹이", "짹짹이"};
pets = new String[] {"어흥이", "톰톰이"};
System.out.println(Arrays.toString(pets)); // [어흥이, 톰톰이]



메서드에 문자열 배열을 전달
foo(new String[] {"하하", "호호"});

static void foo(String[] sArr) {
// 배열 처리하는 코드
}

| 문법                          | 설명                          |
| --------------------------- | --------------------------- |
| `new String[] { "A", "B" }` | 문자열 배열 생성                   |
| `foo(arr)`                  | 배열을 함수에 전달                  |
| `String[] sArr`             | 함수에서 배열을 받는 방법              |
| 배열 탐색                       | `for`문 또는 `for-each`문 사용 가능 |


배열의 기본 값
자바의 배열은 생성되는 순간 해당 공간에 기본값들을 채워넣음
정수형: 0
실수형: 0.0
논리형: false
문자형: ''
기타(String): null

