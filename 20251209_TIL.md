# 🗓️ 2025년 12월 9일 TIL - C언어

## 📌 오늘의 키워드

`DFS (Depth First Search)` `재귀 (Recursion)` `스택 (Stack)`
`인접 리스트 (Adjacency List)` `그래프 탐색` `방문 배열`

---

## 1️⃣ DFS(깊이 우선 탐색, Depth First Search)란

### 💡 개념

* **DFS**는 그래프 탐색 알고리즘 중 하나로, **하나의 경로를 끝까지 깊게 탐색한 후**
  더 이상 갈 곳이 없으면 **되돌아가 다른 경로를 탐색하는 방식**이다.
* 즉, **깊게(Depth)** 먼저 들어가고, 막히면 **되돌아오는(Backtracking)** 탐색 기법이다.

---

## 2️⃣ DFS의 기본 원리

| 단계                      | 설명                         |
| ----------------------- | -------------------------- |
| **1. 전진 (Go Forward)**  | 현재 정점에서 방문하지 않은 이웃 정점으로 이동 |
| **2. 막다른 길 (Dead End)** | 더 이상 방문할 이웃이 없을 때          |
| **3. 후퇴 (Backtrack)**   | 직전 갈림길로 돌아가 다른 경로 탐색       |
| **4. 방문 기록 (Visited)**  | 무한 루프를 방지하기 위해 방문한 정점을 체크  |

---

## 3️⃣ DFS 구현 방식 두 가지

| 구현 방식                   | 설명                        | 사용되는 구조          |
| ----------------------- | ------------------------- | ---------------- |
| **재귀 호출(Recursive)**    | 함수 호출 스택을 이용해 자연스럽게 깊이 탐색 | 콜 스택(Call Stack) |
| **반복문 + 스택(Iterative)** | 직접 스택 자료구조를 구현해 반복적으로 탐색  | Linked Stack     |

---

## 4️⃣ DFS 재귀(Recursive) 버전

### 💻 코드 요약

```c
void dfs_recursive(GraphList* g, int v) {
    GraphNode* w;
    visited[v] = 1;
    printf("정점 %d 방문 -> ", v);

    for (w = g->adj_list[v]; w != NULL; w = w->link) {
        if (!visited[w->vertex]) {
            dfs_recursive(g, w->vertex);
        }
    }
}
```

### 동작 원리

1. 현재 정점을 방문 표시 (`visited[v] = 1`)
2. 인접한 모든 정점을 순회하며, 아직 방문하지 않은 정점이면 **재귀 호출**
3. 함수 호출 스택을 통해 자동으로 되돌아가며 모든 정점을 탐색

### 특징

* 코드가 간결하고 이해하기 쉬움
* 하지만 **재귀 깊이 제한**으로 인해 **스택 오버플로우 위험** 존재

---

## 5️⃣ DFS 스택(Stack) 반복문 버전

### 💻 코드 요약

```c
void dfs_stack(GraphList* g, int v) {
    LinkedStack s;
    GraphNode* w;
    init_stack(&s);
    push(&s, v);

    while (!is_empty(&s)) {
        v = pop(&s);
        if (!visited[v]) {
            visited[v] = 1;
            printf("vertex %d -> ", v);

            for (w = g->adj_list[v]; w != NULL; w = w->link) {
                if (!visited[w->vertex])
                    push(&s, w->vertex);
            }
        }
    }
}
```

### 동작 원리

1. 시작 정점을 push 한다.
2. 스택에서 pop된 정점이 방문되지 않았다면 방문 처리한다.
3. 해당 정점의 인접 리스트에 저장된 순서대로 아직 방문하지 않은 정점을 스택에 push 한다.
4. 스택이 빌 때까지 반복

### 특징

* **명시적으로 스택을 사용**해 재귀 없이 구현 가능
* **스택 오버플로우 위험 없음**, 힙 메모리를 활용하므로 대규모 그래프에서도 안정적
* 단, 코드가 길고 구현 난이도가 조금 높음

---

## 6️⃣ 그래프 구조 예시

탐색에 사용된 그래프는 다음과 같다.

```
         0
       /   \
      1     2
      | \    \
      3  4 -- 5
               \
                6
```

### 🔹 연결 관계

| 정점 | 인접 정점   |
| -- | ------- |
| 0  | 1, 2    |
| 1  | 0, 3, 4 |
| 2  | 0, 5    |
| 3  | 1       |
| 4  | 1, 5    |
| 5  | 2, 4, 6 |
| 6  | 5       |

---

## 7️⃣ DFS 탐색 결과 예시

### 재귀 버전 출력

```
vertex 0 -> vertex 1 -> vertex 3 -> vertex 4 -> vertex 5 -> vertex 2 -> vertex 6
```

### 스택 버전 출력

```
vertex 0 -> vertex 2 -> vertex 5 -> vertex 6 -> vertex 4 -> vertex 1 -> vertex 3
```

> 재귀 버전과 스택 버전 모두 모든 정점을 방문하지만,
> **스택 구조의 LIFO 특성** 때문에 탐색 순서는 약간 다를 수 있다.

---

## 8️⃣ 두 버전의 비교

| 구분           | 재귀 DFS          | 스택 DFS         |
| ------------ | --------------- | -------------- |
| **사용 구조**    | 함수 호출 스택        | 명시적 스택         |
| **메모리 관리**   | 시스템 스택 사용 (제한적) | 힙 메모리 사용 (유연함) |
| **구현 난이도**   | 간단              | 복잡             |
| **성능**       | 비슷              | 비슷             |
| **오버플로우 위험** | 있음              | 없음             |
| **대규모 그래프**  | 비추천             | 안정적            |

---

## 🎯 최종 정리

| 항목         | 내용                  |
| ---------- | ------------------- |
| **DFS 목적** | 깊이 우선 탐색으로 모든 노드 방문 |
| **방문 배열**  | 무한 루프 방지용           |
| **재귀 DFS** | 단순, 호출 스택 기반        |
| **스택 DFS** | 명시적 스택으로 반복문 처리     |
| **공통점**    | 그래프 구조의 깊이 탐색 구현    |

---

## 💬 오늘의 소감

오늘은 **그래프 탐색(DFS)** 의 두 가지 구현 방식을 학습했다.
재귀 버전에서는 함수 호출을 통한 자연스러운 백트래킹을 경험했고,
스택 버전에서는 **스택 구조의 LIFO 원리**를 직접 적용해 동일한 탐색을 구현했다.

특히, 스택을 명시적으로 사용하는 방식은
**재귀 깊이 제한 없이 안정적으로 탐색 가능**하다는 점이 인상 깊었다.
