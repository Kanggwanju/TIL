# 🗓️ 2025년 6월 18일 TIL




UP-DOWN 게임 실습

나는 데이터를 불러오기 위해서 요소 노드를 가져오고,
그 노드의 textContent를 불러와서 게임에 필요한 데이터를
획득했다.
선생님은 게임에 필요한 데이터들을 하나의 객체로 묶어서 관리했음.

나는 요소 노드를 가져올 때 패널 설정 함수 내부에서 받았지만
선생님은 따로 전역으로 모든 요소 노드들을 정의하셨다.




입력값 검증 부분에서 나는 범위 내의 값인지만 확인했지만,
선생님은 `isNaN(userGuess)`을 추가로 조건을 달아줬음.
`isNaN(value)`: value가 숫자가 아니면 true를 반환하고, 숫자면 false를 반환한다.
이후 $input.focus();를 하면 다시 시도할 때 input에 커서가 올려짐.
UX가 좋아진다.




나는 사용자의 기록을 따로 저장하지 않고 성공, up, down 판정을 내리는
곳에서 함수를 통해 그 결과에 따라 정답을 판별하고,
함수를 통해 바로 인터페이스를 변경했음.

하지만 선생님은 유저의 기록을 저장하기 위해서 전역으로 만들어둔
게임 데이터 객체의 배열(guessHistory)으로 된 프로퍼티에 내용(객체)을 push,
이후에 인터페이스를 변경(로그 렌더링)할 때 guessHistory를 이용함.



- 사용자 입력, 입력값 검증, 기회 차감, 판정 순으로 프로그램을 구성 하였음.

판정에선 크게 1. 정답인 경우, 2. 아닌 경우(UP, DOWN)으로 나누어 처리함.
- 1. 정답, UI 업데이트 
- 2. UP, DOWN, 범위 업데이트, 자동 정답, 게임 오버 처리, UI 업데이트로 구성
- 자동 정답 처리가 되려면 게임의 최소 범위와 최대 범위가 같아질 때,
동시에 남은 기회가 0보다 커야 함.

### 🔁 게임 재시작 처리

* `form.submit()`으로 새로고침하는 방식은 ❌ UX 저하
* 수동 초기화 함수로 게임 상태를 리셋하는 방식이 ✅ 바람직
* 재시작 버튼을 눌렀을 때와 처음 실행 코드에서 초기화 함수 호출

게임 재시작 이벤트
- 재시작 버튼을 눌렀을 때 폼을 제출하게 하여 새로고침 되게 만들음.
- 하지만 수동 리셋 해주는게 좋다. 이유로는 새로고침 되는게 UX가 안좋고,
이전에 데이터를 쌓아놨던 것들이 다 사라지기 때문이다.
- 재시작 버튼을 눌렀을 때 게임 초기화 함수 호출, 처음 실행 코드에서
초기화 함수 호출


사용자 콘솔 접근 방지
처음에 전역변수로 만들어 놨던 게임 데이터들을 사용자가 콘솔로
접근(ex: 정답 변경)하여 값을 변경하면 게임이 망가진다.
이를 방지하기 위해선 모든 값, 함수들을 한가지 함수에 담고
호출하면 된다.
즉시실행 함수(IIFE)
```js
(function() {
  return 100;
})();
```
즉시실행 함수는 이름이 없기 때문에 접근할 수 없음. 따라서 유저가
게임에 콘솔로 접근할 가능성을 아예 원천 차단함.






AJAX
서버 통신을 연습하기 위해 페이크 서버를 이용해서 학습함.
가짜 서버 사이트는 `https://jsonplaceholder.typicode.com`
사이트에는 여러가지 Resources가 있음.
Resources는 실제 서버가 제공하는 데이터와 비슷하며 우리는 서버에
요청을 하면 요청에 따라 데이터를 제공받을 수 있음.

XHR - 서버와의 통신을 중개해주는 대행 객체
`const xhr = new XMLHttpRequest();`

데이터 요청시 사용하는 방식 4가지
1. GET : 조회
2. POST : 생성
3. PUT/ PATCH : 수정
4. DELETE : 삭제

서버에서 가져온 데이터는 string(문자열=JSON)이다.
데이터의 표준 포맷은 JSON이 추세이다.
JSON: 자바스크립트 객체 표기법
JSON != JS
자바스크립트와 다른 점은 키를 "name"처럼 쌍 따옴표를 이용하여 표현.
`"title": "qui est esse"`

서버가 사용하는 언어는 서버마다 다름
클라이언트도 사용하는 언어가 다름

언어마다 JSON을 특정언어로 변환하는 기능을 내장하고 있음
JSON -> JS : JSON.parse()
JS -> JSON : JSON.stringify()
서버에서 가져온 데이터를 JS로 변환하고 사용해야함.


서버 통신은 비동기이므로 응답 데이터를 사용하려면 callback 함수를
사용해야함.


XHR을 통해 비동기 요청을 제어할 수 있지만,
복잡한 비동기 로직을 처리할 때 콜백 중첩이 발생할 수 있다.
두 번 이상의 요청이 연속적으로 필요한 경우에는 콜백을 반복해서
사용해야 하므로 코드 가독성이 떨어지고 관리가 어려워진다.
이러한 현상을 콜백 지옥이라 부른다.

ex)
```js
  // 1. 회원목록 조회
  fetchGet(`${url}/users`, (response) => {
    // console.log(response);
    // 2. 그 중에 두번째 회원이 쓴 게시물 정보를 추가 조회한다.
    fetchGet(`${url}/posts?userId=${response[1].id}`, (response2) => {
      console.log(response2);
      // 3. 그중 4번째 게시물의 모든 댓글을 가져오고싶다.
      fetchGet(`${url}/comments?postId=${response2[3].id}`, (response3) => {
        console.log(response3);
      });
    });
  });
```
fetchGet을 따로 3번씩 하면 내가 원하는 정보를 받을 수 없으므로
콜백을 중첩해서 사용하여 정보를 받아야 한다. 이렇게 콜백 함수가
중첩되어 실현되면 콜백 지옥이 나타난다.

중요! api key는 깃허브에 업로드하면 안된다.

