# 🗓️ 2025년 7월 4일 TIL

자바 표준 API
lang - Object, String, Wrapper
time
generic
배열 구현
을 오늘 배움


자바 표준 API
다양한 기능을 쉽게 구현할 수 있도록 제공되는 라이브러리 집합

## `java.lang` 패키지
기본적인 클래스들을 포함하는 가장 기본적인 패키지
자바 프로그램에서 자동으로 임포트되므로, 별도의 임포트 없이 사용할 수 있음

주요 클래스
`Object`
클래스를 만들 때 상속을 쓰지 않으면 자동으로 Object가
상속됨을 기억

`Pen yellowPen = new Pen(100L, "노랑", 1000);`

`System.out.println(yellowPen);`
yellowPen 에는 .toString()이 숨겨져있음.

toString은
getClass().getName() + "@" + 해시코드 16진수를 반환함.

우리가 궁금한 것은 실제 필드 값이 궁금하므로 toString을
클래스 내부에서 오버라이딩 해서 사용하는 것.



String
charAt(index) : 문자열 인덱스에 따른 글자 반환
substring() : 문자열의 특정 범위를 추출
length() : 문자열의 총 길이 반환
indexOf(), lastIndexOf(): 특정 문자나 단어의 첫글자 인덱스 반환, 없으면 -1
toLowerCase(), toUpperCase(): 일괄 대소문자변경

filePath.substring(filePath.lastIndexOf(".") + 1); : 파일경로에서 확장자 추출
replace(old, new): 문자열 내부에 old 문자를 찾아서 new 문자로 일괄변경
split() : 문자열을 특정 기준을 기반으로 쪼개서 배열에 반환

Wrapper
기본 타입 -> 객체 : Wrapper
Byte, Short, Integer, Long, Float, Double, Boolean, Character
Integer x1 = new Integer(10);

boxing: 그냥 기본 타입처럼 써도 객체로 처리해주겠다.
Integer x2 = 20;

time

날짜와 시간을 표현
1970년 1월 1일 00:00:00 이전의 시간은 모름 - 에폭 타임 (유닉스 타임)
밀리초단위로 시간을 늘려나감
System.out.println(System.currentTimeMillis());

현재 시간
LocalDate nowDate = LocalDate.now();
LocalTime nowTime = LocalTime.now();

오늘로부터 1년 3개월 20일 3시간 이후는 언제냐
LocalDateTime targetDateTime = nowDateTime
    .plusYears(1)
    .plusMonths(3)
    .plusDays(20)
    .plusHours(3)
    ;

현재 날짜에서 다른 정보 말고 딱 월 정보만 가져오고 싶음
int monthValue = nowDateTime.getMonthValue();

날짜 포맷 변경
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy년 MM월 dd일 a hh시 mm분 ss초");
String formattedDate = nowDateTime.format(formatter);





generic
```java
/*
    이건 바구니의 설계도고 아직 뭘 담을지는 몰라
    근데 아무튼 과일을 담을거임
    F는 과일을 의미, 이게 대체 무슨 과일이냐? 설계도는 몰라
    F는 바구니가 만들어진 다음에 결정됨
    F는 Fruit 카테고리 여야함.
 */
public class Basket<F extends Fruit> {

    private F fruit;

    public F getFruit() {
        return fruit;
    }

    public void setFruit(F fruit) {
        this.fruit = fruit;
    }
}

```

```java
public class Main {
    public static void main(String[] args) {
        // ====== 제네릭을 사용했을 때 ====== //
        // 일단 범용적인 바스켓을 만들고, 만들고 난 다음에 뭘 담을지 후에 결정

        // 사과바구니를 만들거야
        // new Basket<Apple>은 Apple 생략 가능
        Basket<Apple> basketA = new Basket<>();
        basketA.setFruit(new Apple(11));
        Apple app = basketA.getFruit();

        // 바나나 바구니를 만들거야
        Basket<Banana> basketB = new Basket<>();
        basketB.setFruit(new Banana(25));
        Banana ban = basketB.getFruit();

        Basket<Peach> basketC = new Basket<>();
        basketC.setFruit(new Peach(10));

        // Water는 Fruit을 상속하지 않았기 때문에 불가능
        // -> 물은 과일 카테고리가 아니므로 바구니에 못담음
//        Basket<Water> basketD = new Basket<>();
    }
}
```

배열 구현
generic을 이용해서 배열을 구현하면 이전의 바구니 예제와
같이 배열에 특정한 타입이 들어올 수 있게 설정하지 않고
들어오는 순간 그 타입의 배열이 되게끔 만들 수 있다.

배열을 생성할 때에 타입을 정수형의 경우
Int로 만들면 안 되고, Wrapper(Integer)를 기준으로 넣어줘야
정수형 배열을 만들 수 있다.

MyArrayList<T>
size를 통해 실제로 가지고 있는 데이터 개수를 추적하고,
실제 데이터를 제외한 나머지는 null으로 초기화 시켜놓음

배열의 length는 필요할 경우
메서드를 통해 한번에 10개씩 커지게 만들음


remove 메서드 구현: 특정 인덱스의 요소 삭제

1. 지울 데이터를 백업
`T removed = get(index);`

2. for 문을 통해 배열의 index 위치에서 (size - 1) 위치까지 한 칸씩
앞으로 당겨서 복사
`for (int i = index; i < size - 1; i++) { values[i] = values[i + 1]; }`

3. 배열의 사이즈를 줄임
`size--;`

4. 메모리 관리 팁: 실제로 가려진 데이터를 지워줌
`values[size] = null;`

5. 지운 데이터를 리턴
`return removed;`




clear 메서드 구현
배열을 비울 때
size만 0으로 만들면
논리적으로 전체삭제는 구현이 되었으나 실제 배열 내부에는
아직 데이터가 남아있는 상태가 됨.
그 데이터들은 size 크기만큼 for문을 돌려서 전부
null로 만들어줌

근데, 만약 현재 실제 데이터가 10000개일 경우
10240개 -> 10개로 회귀시켜서 방 크기를 줄이는가?
아니다. 실제 구현에서는 방 크기를 놔둔다. 
이유: clear 이후에 다시 그만큼의 데이터를 채우는게 일반적이기 때문이다.




