# 🗓️ 2025년 7월 3일 TIL



final

final class: 상속 금지

final method: 오버라이딩 금지

필드에 final을 달고 초기화를 안 한 뒤에 생성자에서
final 필드를 초기화 가능
-> 생성자를 통해 객체를 생성할 때에만 final 필드를 입력
가능해짐. 이후에는 final 필드를 변경할 수 없다.

자바의 상수 (불변성: final, 유일성: static)
ex) public static final String NATION = "대한민국";

static 전용 생성자 - 정적 초기화자 (static initializer)
필드에 static을 붙였을 경우에는 생성자를 통해 초기화 할
수 없음. 정적 초기화자를 통해 초기화 해야한다.
`static { instance = new Singleton(); }`
스태틱 접근시 최초 1번 호출
스태틱 상수 최초 접근 or 생성자를 통해 객체가 생성될 때
정적 초기화자는 최초에 1번만 호출된다.

싱글턴 패턴: 객체 생성은 오직 하나만 생성되어야 한다.
1. 아예 외부에서 객체를 못만들게 함.
2. 스스로 딱 하나의 객체를 생성함.
3. 외부에 공개할 메서드를 만들고 그 메서드에 단 하나의 객체를 리턴시킴
객체 생성 없이 외부에서 호출하기 위해서 메서드에는 static을 붙인다.



enum
각각은 생성자 호출을 의미하며, 파라미터를 전달할 수 있다.
```java
public enum PizzaStatus {
    // 주문 완료, 준비 완료, 배달 완료 (생성자 호출)
    ORDERED("주문 완료", 10),
    READY("준비 완료", 30),
    DELIVERED("배달 완료", 40)
    ;
}
```

필드 선언하고, 생성자를 만들어서 생성자 호출 부분에서 전달한
파라미터를 이용하여 필드를 초기화 할 수 있다.
필드는 보통 private 으로 막아둬서 getter 메서드를
이용하여 각각의 필드에 접근하게 할 수 있음.



추상적
추상 클래스: 실체화된 객체가 아닌 다형성을 위한 껍데기 클래스 (규격)
오버라이딩을 강제할 수 있다.
`public abstract class Pet`
abstract를 붙여주면 객체 생성(객체화) 기능이 막힘.


자식 클래스들의 메서드를 오버라이딩 해주기 위해서
부모 클래스에 껍데기 메서드를 제작해줘야함.
추상 메서드: 오버라이딩을 위한 껍데기 틀, ';'로 처리
`public abstract void feed();`
`public abstract void sleep();`

이러면 Pet을 상속하면 feed와 sleep 메서드를 필수적으로
오버라이딩을 해야한다.

객체의 무결성을 지키기 위해서 추상 기능을 사용하면 안전하게
클래스를 생성할 수 있음.

규격과 틀을 제대로 만들어 놓으면 새로운 클래스를 만들 때
규격과 틀을 걱정할 필요가 없고, 동일한 성능을 보장한다.

```java
public class Dog extends Pet{
    @Override
    public void feed() {System.out.println("강아지는 사료를 냠냠!");}
    @Override
    public void sleep() {System.out.println("강아지는 마당에서 낮잠을 쿨쿨쿨!");}
}
```


인터페이스
추상 클래스를 편하게 만들기 위한 편의 기능
추상 클래스와 같은 얘기라고 보면 됨.
```java
public interface Pet {
    // 애완동물의 필수 기능
    // 노는 기능
    void handle();
    // 예방접종 기능
    boolean inject();
}

public class Cat implements Pet {
    @Override
    public void handle() {}

    @Override
    public boolean inject() { return false; }
}
```
자바는 다중 상속이 불가능하게 만들어졌지만,
인터페이스는 다중 상속이 가능하다.



인터페이스 간의 상속
새로운 인터페이스 생성
인터페이스는 다른 인터페이스를 상속할 수 있음.
`public interface Aggressive extends Wild, Huntable {}`

인터페이스의 단점
인터페이스는 필드를 가질 수 없습니다.
따라서 필드를 하위 클래스에게 상속시키고 싶으면 추상 클래스를 써야함.
상수는 만들 수 있음 (static final)
`static final String ABC = "ddss";`


인터페이스 전용
뒤늦게 이미 구현이 많은 상태에서 새 메서드를 추가할 때는
오버라이드를 강요하지 말자
`default void eat() {}`
일단 디폴트로 만들어놔서 오버라이드를 강요하지 말고,
일일이 수동으로 상속한 클래스에 메서드를 만들음 나중에 다 만들었다고 판단되면
추상화로 만든다.

일반 메서드는 만들 수 없지만, static 메서드는 제작 가능
`static void aaa() {}`



예외 처리
오류: 시스템 레벨에서 발생하는 심각한 문제
메모리 부족 등 개발자가 해결해 줄 수 없는 문제

예외: 프로그램에서 예측하고 처리할 수 있는 상황,
적절히 처리해서 프로그램이 계속해서 실행될 수 있음.

예외처리: 에러를 복구해주는 개념 X, 보험처럼 대비하는 것.
에러가 날 것 같은 곳에다가 예외처리를 적용


try-catch-finally 구문
try: 예외 가능성이 있는 코드를 적고
예외가 발생하면 바로 기존 실행 흐름을 끊고 바로 catch로 이동

catch: 에러가 나면 어떻게 할건지를 적습니다.
발생한 예외를 처리하는 코드

finally: 예외 발생 여부와 상관없이 반드시 실행되는 코드


throws Exception
이 메서드는 에러 가능성이 있는 위험한 메서드다.
따라서 사용자는 직접 예외처리를 할 것이라고 알리는 기능

예외를 던지다 : 예외가 발생하면 코드의 흐름이 끊김.
마치 리턴문 탈출처럼 에러를 활용할 수 있다.
다만 에러가 발생하면 프로그램이 튕기기 때문에 그에 따른
예외처리는 호출하는 쪽에게 떠넘긴다.


커스텀 exception
에러 이름을 직접 만들 수 있음
```java
public class LoginInvalidException extends RuntimeException {
    public LoginInvalidException(String message) {
        super(message);
    }
}
```


