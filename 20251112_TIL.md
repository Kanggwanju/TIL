# 🗓️ 2025년 11월 12일 TIL - c언어

## 📌 오늘의 키워드

`버블 정렬 (Bubble Sort)`, `선택 정렬 (Selection Sort)`, `삽입 정렬 (Insertion Sort)`, `교환 (Swap)`, `정렬 과정 비교`, `시간 복잡도`, `장단점 분석`

---

## 1️⃣ 버블 정렬 (Bubble Sort)

### 💡 개념 정리

* 바로 **옆의 원소와 비교하여 크면 교환**하는 방식
* 한 번의 pass가 끝날 때마다 **가장 큰 원소가 맨 뒤로 이동**
* 전체 요소를 반복적으로 비교하며 **‘거품처럼’ 큰 값이 위로 올라간다.**

### 💻 예시 코드

```c
for (i = 0; i < len - 1; i++) {
    for (j = 0; j < len - 1 - i; j++) {
        if (arr[j] > arr[j + 1]) {
            swap(&arr[j], &arr[j + 1]);
        }
    }
}
```



### 🔍 특징

* 구현이 가장 단순하지만 **비교 횟수와 교환 횟수가 많다.**
* 정렬이 거의 되어 있어도 **끝까지 검사**해야 함.

### ⏱️ 시간 복잡도

| 구분             | 복잡도   |
| -------------- | ----- |
| 최선 (이미 정렬된 경우) | O(n)  |
| 평균             | O(n²) |
| 최악             | O(n²) |

### ⚖장단점

| 장점          | 단점                 |
| ----------- | ------------------ |
| 구현이 매우 쉬움   | 교환이 너무 많음          |
| 작은 데이터에는 적합 | 대규모 데이터에서는 매우 비효율적 |

---

## 2️⃣ 선택 정렬 (Selection Sort)

### 💡 개념 정리

* 배열 전체에서 **가장 작은 값을 찾아 앞으로 보내는 정렬**
* 교환은 한 pass에 **한 번만 발생**
* pass가 진행될수록 앞쪽은 정렬 완료, 뒤쪽은 미정렬 상태로 남음

### 💻 예시 코드

```c
for (i = 0; i < len - 1; i++) {
    min_index = i;
    for (j = i + 1; j < len; j++) {
        if (arr[j] < arr[min_index]) {
            min_index = j;
        }
    }
    swap(&arr[i], &arr[min_index]);
}
```



### 🔍 특징

* **비교 횟수는 많지만 교환 횟수는 적다.**
* 정렬이 어느 정도 되어 있어도 성능 차이가 거의 없다.

### ⏱️ 시간 복잡도

| 구분 | 복잡도   |
| -- | ----- |
| 최선 | O(n²) |
| 평균 | O(n²) |
| 최악 | O(n²) |

### ⚖️ 장단점

| 장점                      | 단점                       |
| ----------------------- | ------------------------ |
| 교환 횟수가 적어 메모리 교체 부하가 적음 | 비교 횟수는 항상 일정(O(n²))      |
| 구현이 단순                  | 이미 정렬된 데이터에서도 불필요한 비교 발생 |

---

## 3️⃣ 삽입 정렬 (Insertion Sort)

### 💡 개념 정리

* 데이터를 **왼쪽(정렬된 영역)** 과 **오른쪽(미정렬 영역)** 으로 나누고,
  오른쪽에서 한 개씩 꺼내 **적절한 위치에 삽입**
* **정렬된 부분을 점진적으로 확장**해가는 방식

### 💻 예시 코드

```c
for (i = 1; i < len; i++) {
    key = arr[i];
    for (j = i - 1; j >= 0 && arr[j] > key; j--) {
        arr[j + 1] = arr[j];
    }
    arr[j + 1] = key;
}
```



### 🔍 특징

* 버블/선택보다 효율적
* **이미 정렬된 데이터에는 매우 빠름 (O(n))**
* 하지만 역순일 경우에는 여전히 느림

### ⏱️ 시간 복잡도

| 구분             | 복잡도   |
| -------------- | ----- |
| 최선 (거의 정렬된 경우) | O(n)  |
| 평균             | O(n²) |
| 최악             | O(n²) |

### ⚖장단점

| 장점                     | 단점            |
| ---------------------- | ------------- |
| 부분적으로 정렬된 데이터에 매우 효율적  | 데이터가 많을수록 느림  |
| 구현이 단순하고 안정 정렬(stable) | 대규모 데이터에는 부적합 |

---

## 📊 세 정렬 알고리즘 비교 요약

| 정렬 방식 | 비교 횟수       | 교환 횟수 | 시간 복잡도(평균)   | 안정성   | 특징 요약            |
| ----- | ----------- | ----- | ------------ | ----- | ---------------- |
| 버블 정렬 | 많음          | 많음    | O(n²)        | ✅ 안정  | 구현 쉬움, 비효율적      |
| 선택 정렬 | 많음          | 적음    | O(n²)        | ❌ 불안정 | 교환 적지만 항상 O(n²)  |
| 삽입 정렬 | 적음 (부분정렬 시) | 적음    | O(n²) / O(n) | ✅ 안정  | 거의 정렬된 경우 가장 효율적 |

---

## 💬 오늘의 소감

오늘은 **세 가지 기본 정렬 알고리즘**을 직접 구현하면서 비교했다.
세 알고리즘 모두 O(n²)로 비슷하지만, **데이터의 초기 상태에 따라 효율성이 달라진다는 점**이 흥미로웠다.
