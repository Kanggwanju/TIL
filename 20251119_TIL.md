# 🗓️ 2025년 11월 19일 TIL - c언어

## 📌 오늘의 키워드

`병합 정렬 (Merge Sort)` `분할 정복 (Divide and Conquer)` `재귀 호출` `병합 알고리즘`
`O(N log N)` `안정 정렬 (Stable Sort)` `추가 메모리 사용`

---

## 1️⃣ 병합 정렬(Merge Sort)의 개념

### 💡 정의

* **분할 정복(Divide and Conquer)** 전략을 사용하는 대표적인 정렬 알고리즘
* 배열을 **반으로 나누고**, 각각을 재귀적으로 정렬한 뒤
  **두 개의 정렬된 배열을 병합(merge)** 하면서 하나로 합치는 방식
* **퀵 정렬(Quick Sort)** 과 달리,
  먼저 나누고(`Divide`) → 나중에 합치면서(`Conquer`) 정렬을 완성한다.

---

## 2️⃣ 동작 원리

1️⃣ **분할(Divide)**

* 배열을 절반으로 나눈다.
* 더 이상 나눌 수 없을 때(길이 1이 될 때) 재귀 종료.

2️⃣ **정복(Conquer)**

* 나뉜 하위 배열을 각각 정렬한다.
* 이미 정렬된 두 배열을 비교하면서 병합(merge)한다.

---

## 3️⃣ 병합 알고리즘 구조

### 💻 주요 코드

```c
void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1; // 왼쪽 배열 크기
    int n2 = right - mid;    // 오른쪽 배열 크기

    int* L = (int*) malloc(n1 * sizeof(int));
    int* R = (int*) malloc(n2 * sizeof(int));

    for (int i = 0; i < n1; i++) L[i] = arr[left + i];
    for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) arr[k++] = L[i++];
        else arr[k++] = R[j++];
    }

    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];

    free(L);
    free(R);
}
```



---

## 4️⃣ mergeSort 함수의 구조

### 💻 코드

```c
void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;

        mergeSort(arr, left, mid);     // 왼쪽 부분 정렬
        mergeSort(arr, mid + 1, right); // 오른쪽 부분 정렬
        merge(arr, left, mid, right);  // 병합
    }
}
```



---

## 5️⃣ 병합 과정 시각화

예시 입력:

```
[7, 2, 6, 8, 5, 3, 1, 4]
```

1️⃣ 분할 단계

```
[7, 2, 6, 8] | [5, 3, 1, 4]
[7, 2] | [6, 8] | [5, 3] | [1, 4]
[7] | [2] | [6] | [8] | [5] | [3] | [1] | [4]
```

2️⃣ 병합 단계

```
[2, 7] | [6, 8] | [3, 5] | [1, 4]
[2, 6, 7, 8] | [1, 3, 4, 5]
[1, 2, 3, 4, 5, 6, 7, 8]
```

---

## 6️⃣ 시간 복잡도 분석

| 단계    | 연산              | 개수    | 총 연산량      |
| ----- | --------------- | ----- | ---------- |
| 분할 단계 | 배열 절반 나누기       | log₂N | O(log N)   |
| 병합 단계 | 각 단계에서 전체 N개 비교 | log₂N | O(N log N) |

✅ **최악·평균·최선 모두 O(N log N)**
(정렬이 이미 되어 있어도 모든 단계 수행)

---

## 7️⃣ 장단점 비교

| 구분     | 장점                                   | 단점                    |
| ------ | ------------------------------------ | --------------------- |
| 시간 복잡도 | 항상 O(N log N) 보장                     | 퀵 정렬은 평균만 빠름          |
| 안정성    | **안정 정렬(Stable Sort)** — 같은 값의 순서 유지 | -                     |
| 추가 메모리 | -                                    | **O(N)** 만큼의 임시 배열 필요 |
| 구현 난이도 | 중간 정도                                | -                     |
| 정렬 대상  | 큰 데이터, 링크드 리스트에도 적합                  | 메모리 여유 필요             |

---

## 8️⃣ 퀵 정렬 vs 병합 정렬

| 구분     | 퀵 정렬 (Quick Sort)        | 병합 정렬 (Merge Sort) |
| ------ | ------------------------ | ------------------ |
| 정렬 전략  | 피벗 중심 분할                 | 완전 분할 후 병합         |
| 시간 복잡도 | 평균 O(N log N) / 최악 O(N²) | 항상 O(N log N)      |
| 공간 복잡도 | O(log N) (재귀 스택만 사용)     | O(N) (임시 배열 필요)    |
| 안정성    | 불안정 (Unstable)           | 안정 (Stable)        |
| 데이터 특성 | 랜덤 데이터에 효율적              | 정렬된 데이터에도 일정       |

---

## 🎯 최종 정리

* 병합 정렬은 **항상 O(N log N)** 의 일정한 성능을 제공하는 안정적인 정렬
* “반으로 나누고, 합치며 정렬”이라는 **단순한 재귀 구조**로 동작
* 다만, **추가 메모리 공간이 필요**하므로 메모리 제약이 적은 환경에서 효율적

---

## 💬 오늘의 소감

오늘은 병합 정렬을 학습하면서, “퀵 정렬은 빠르지만 운에 따라 느려질 수 있다”는 점과 달리
병합 정렬은 항상 일정한 속도를 유지한다는 게 인상 깊었다.
