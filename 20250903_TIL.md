# 🗓️ 2025년 9월 3일 TIL

## 📌 오늘의 키워드
- 이메일 인증 (회원가입 보안 절차)
- 인증번호 생성 & 만료시간 설정
- JavaMailSender (Spring 이메일 발송)
- DB 정규화 (이메일 인증 엔터티 1:1 관계)
- 디바운스 (lodash 활용)

---

## 이메일 인증 정리

## 🔑 개념

* **이메일 인증**: 회원가입 시, 입력한 이메일이 실제 사용자의 것인지 확인하는 절차
* **왜 필요한가?**

    * 가짜 계정 생성을 막음
    * 비밀번호 찾기 등 중요한 기능의 보안 강화

---

## ⚙️ 이메일 인증 과정 (흐름도)

1. **이메일 입력**

    * 사용자가 이메일을 입력
    * 서버는 DB에서 해당 이메일이 이미 가입된 것인지 확인

2. **인증번호 생성 & 전송**

    * 서버가 인증번호(랜덤 값)와 만료 시간 설정
    * DB에 저장 (이메일 인증 엔터티 테이블)
    * 입력된 이메일 주소로 인증번호 메일 발송

3. **사용자 입력 & 검증**

    * 사용자가 받은 인증번호를 클라이언트에 입력
    * 서버는 DB에 저장된 인증번호/만료시간과 비교
    * 올바르면 회원가입 진행

---

## 🗂️ 데이터베이스 설계 포인트

* **이메일 인증 엔터티**: 회원과 `1:1` 관계
* 새 인증번호 생성 시, 이전 인증번호는 삭제 (중복/혼란 방지)

---

## 📋 요약 표

| 단계      | 설명               |
| ------- | ---------------- |
| 이메일 입력  | 사용자 이메일 받고 중복 확인 |
| 인증번호 생성 | 서버에서 번호+만료시간 생성  |
| 이메일 발송  | 인증번호 포함 메일 전송    |
| 인증번호 검증 | 클라이언트 입력값 확인     |
| 회원가입 진행 | 인증 성공 시 가입 완료    |

---

## 메일 발송 설정
- 네이버 메일
- 환경설정
- POP3/IMAP
- POP3/SMTP 사용
- '사용함'으로 설정


## SMTP 설정
```yml
# application.yml
spring:
  # mail send setting
  mail:
    host: smtp.naver.com
    port: 465
    username: ---      # 네이버 아이디, github 유출 금지
    password: ---      # 애플리케이션 비밀번호, github 유출 금지
    protocol: smtp
    # 보안 설정, 보안연결(SSL)
    properties:
      mail:
        smtp:
          auth: true
          ssl:
            enable: true
```

## build.gradle
- 이메일 전송 라이브러리 의존성 추가

```groovy
implementation 'org.springframework.boot:spring-boot-starter-mail'
```

---

## 회원가입

### 1. [BACK] 이메일 중복확인 처리
- 이메일 중복 X -> 인증 코드 발송 메서드 호출
```java
@Transactional(readOnly = true)
public boolean checkEmailDuplicate(String email) {

    // 중복확인
    boolean flag = eventUserRepository.existsByEmail(email);
    log.info("Checking email {} is duplicate: {}", email, flag);

    // 사용가능한 이메일인 경우 인증메일 발송
    if (!flag) processSignup(email);

    return flag;
}
```

---

### 2. [BACK] 인증 코드 발송 메서드

#### 임시 회원가입
- 인증 코드를 발송 -> 인증 코드를 DB에 저장해야함
- 인증 코드를 DB에 저장하려면 회원정보가 필요하므로 임시 회원가입 해줌
- 이메일 인증 여부는 false(여기선 필드 기본값)
- 생성 시간은 사용자가 인증 코드를 제출하고, 비밀번호까지 설정했을 때 등록

#### 인증 메일 발송 (sendVerificationEmail)
- JavaMailSender 의존객체를 이용해서 로직 작성

```java
private void processSignup(String email) {
    // 1. 임시 회원가입
    EventUser tempUser = EventUser.builder()
            .email(email)
            .build();

    EventUser savedUser = eventUserRepository.save(tempUser);

    // 2. 인증 메일 발송
    String code = sendVerificationEmail(email);

    // 3. 인증 코드와 만료시간을 DB에 저장
    EmailVerification verification = EmailVerification.builder()
            .verificationCode(code)
            .expiryDate(LocalDateTime.now().plusMinutes(5)) // 만료시간 5분 설정
            .eventUser(savedUser) // FK 설정
            .build();
    emailVerificationRepository.save(verification);
}
```

### 3. [FRONT] 이메일 입력 시 패턴, 중복 검증

1. `input` 엘리먼트에 `onChange` 이벤트 핸들러 설정
- 사용자가 이메일 입력시 실행됨
- `lodash` 라이브러리를 통해 디바운스 설정
```jsx
<input
  ref={emailRef}
  className={error ? styles.invalidInput : ''}
  type='email'
  placeholder='Enter your email'
  onChange={debounce(handleEmail, 1000)}
/>
```

2. `handleEmail` 이벤트 핸들러
- 사용자가 입력 후, 1초 뒤 실행됨 (debounce)
- 이메일 패턴 검증
- 이메일 중복확인 검증(서버통신)
- onSuccess 함수는 부모가 내려준 함수로, 실행하면 이메일을 파라미터로 건네고,
- 다음 단계(인증 코드)로 동적 렌더링 됨

```jsx
const handleEmail = e => {
  const inputValue = e.target.value;

  // 이메일 패턴 검증
  const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/; // 간단한 이메일 패턴 검사
  if (!emailPattern.test(inputValue)) {
    setError('이메일이 올바르지 않습니다.');
    return;
  }

  // 이메일 중복확인 검증
  (async () => {
    const response = await fetch(`${AUTH_API_URL}/check-email?email=${inputValue}`);
    const { isDuplicate, message } = await response.json();
    if (isDuplicate) {
      setError(message);
    } else {
      onSuccess(inputValue);
    }
  })();

  setError('');
};
```

lodash 라이브러리: 디바운스, 쓰로틀 사용 가능
`npm install lodash`

---

### 4. [BACK] 인증코드 검증 로직 (isMatchCode)

1. 사용자 조회: 사용자의 이메일을 기반으로 `EventUser` 엔티티를 찾음
2. 인증 정보 조회: 찾은 `EventUser와` 연결된 `EmailVerification` 엔티티를 조회
3. 검증 및 처리: 인증 코드와 만료 시간을 확인하고, 조건에 따라 다음 작업을 수행
  * 성공: `EventUser`의 인증을 완료처리하고, 사용된 EmailVerification 정보를 삭제
  * 실패: 인증 코드를 재발송

```java
public boolean isMatchCode(String email, String code) {

    // 이메일을 통해 사용자의 PK를 조회
    EventUser eventUser = eventUserRepository.findByEmail(email).orElseThrow();

    // 사용자의 인증코드를 FK를 통해 데이터베이스에서 조회
    EmailVerification verification
            = emailVerificationRepository.findByEventUser(eventUser).orElseThrow();

    // 인증코드가 일치하고 만료시간이 지나지 않았는지 체크
    if (
            code.equals(verification.getVerificationCode())
            && verification.getExpiryDate().isAfter(LocalDateTime.now())
    ) {
        // 이메일 인증 완료처리
        eventUser.completeVerifying();
        eventUserRepository.save(eventUser);

        // 인증번호를 데이터베이스에서 삭제
        emailVerificationRepository.delete(verification);

        return true;
    }
    // 인증코드가 틀렸거나 만료된 경우 자동으로 인증코드를 재발송
    updateVerificationCode(email, verification);

    return false;
}
```

---

### 5. [FRONT] 인증코드 입력

1. 다중 ref 바인딩
- `input` 태그 4개에 인증코드를 입력
- maxLength를 통해 최대 길이 1로 제한
- ref에 함수를 넣어서 수동으로 ref 배열에 input 태그들 저장
- `value={codes[index]}`를 통해 코드의 변경된 값과 양방향 매핑
```jsx

// ref를 배열로 관리하는법
const inputRefs = useRef([]);

// 수동으로 ref 배열에 input 태그들 저장하기
const bindRef = ($input, index) => {
  inputRefs.current[index] = $input;
};

return (
  <>
    <div className={styles.codeInputContainer}>
      {
        Array.from(new Array(4)).map((_, index) => (
          <input
            ref={($input) => bindRef($input, index)}
            key={index}
            type='text'
            className={styles.codeInput}
            maxLength={1}
            onChange={(e) => handleNumber(index, e)}
            value={codes[index]}
          />
        ))
      }
    </div>
  </>
);
```

2. 인증코드 입력
- `input` 태그의 이벤트 핸들러인 `onChange`를 통해 `handleNumber` 함수 실행
- 인증 코드를 배열로 상태관리
- `test` 메서드를 이용해서 입력값 검증 실행
- 기존 입력값(codes)을 복사해서 새 배열을 만들고, 변경된 값을 넣어준 후 `setCodes`
- `focusNextInput` 함수를 통해 다음 칸으로 이동(마지막에는 포커스 아웃)
- 고차함수 `every()`를 통해 모든 인증코드를 입력하면 서버에 인증코드 전송
- `join('')`: 배열 요소들 사이에 아무런 구분자도 넣지 않고 하나의 문자열로 만들어 줌
```jsx
// 완성된 인증코드를 상태관리
const [codes, setCodes] = useState(['', '', '', '']);

// 숫자 입력 이벤트
const handleNumber = (index, e) => {

  const inputValue = e.target.value;
  
  // 숫자만 넣을 수 있도록 입력값 검증
  if (inputValue !== '' && !/^\d$/.test(inputValue)) {
    return;
  }

  // 입력한 숫자를 하나로 연결하기
  const copyCodes = [...codes];
  copyCodes[index] = inputValue;

  setCodes(copyCodes);

  focusNextInput(index + 1);

  // 모든 인증코드를 입력했을 때 서버에 인증코드를 전송
  if (copyCodes.every(code => code !== '')) {
    console.log('모든 칸이 입력됨! ', copyCodes);
    const verifyCode = copyCodes.join('');
    console.log('전송할 인증코드: ', verifyCode);

    // 서버에 전송
    fetchVerifying(verifyCode);
  }

};
```

---

3. 서버에 인증코드 전송
- 클라이언트에서 입력한 코드를 서버로 보내서 확인
- lodash 라이브러리의 디바운스 사용
- `email`은 이메일 입력 단계에서 입력한 이메일을 가져옴 
- 코드가 틀림: 리셋 -> 인증코드 재발송, 재입력 유도
- 코드를 맞춤: `onSuccess` 함수를 실행해서 다음 단계로 진행

```jsx
const fetchVerifying = debounce(async (verifyCode) => {
  const response
    = await fetch(`${AUTH_API_URL}/code?email=${email}&code=${verifyCode}`);
  const {isMatch} = await response.json();

  // 검증에 실패했을 경우
  if (!isMatch) {
    // 타이머를 리셋
    setTimer(300);

    // 에러메시지를 세팅
    setError('유효하지 않거나 만료된 인증코드입니다. 인증코드를 재발송합니다.');
    // 인증코드를 모두 빈칸으로 되돌림
    setCodes(Array(4).fill(''));
    // 첫번째 칸으로 재 포커싱
    inputRefs.current[0].focus();
    return;
  }
  // 검증 성공시 - 다음 스텝으로 이동하는 신호 올려보내기
  setError('');
  onSuccess();

}, 1000);
```

---

## ✅ 최종 정리
- **이메일 인증**은 회원가입 보안을 강화하는 핵심 절차
- 서버는 **인증번호 생성 + 만료시간 설정** 후 메일 발송
- 인증번호는 **엔터티 분리(회원과 1:1 관계)**로 관리 → 이전 코드는 삭제
- 프론트에서는 **디바운스 적용, UX 개선(입력칸 포커스 이동, 에러 처리)** 필수
- 핵심 포인트: **DB 정규화, 보안 설정(SMTP/만료), 사용자 경험 최적화**
