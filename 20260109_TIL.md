# 🗓️ 2026년 1월 9일 TIL - Java `static` & `final`

## 📌 오늘의 키워드
`static` `final` `static final`

---

## 1) `static` 한 줄 정리

### ✅ 의미
**객체(인스턴스)마다 생기는 값이 아니라, “클래스에 딱 1개만 존재해서 모두가 공유하는 값/기능”**

- `static` 멤버는 객체를 여러 개 만들어도 **클래스당 1개**만 존재
- 그래서 보통 “공통 설정값”, “전역적으로 공유할 값”, “유틸성 메서드”에 자주 씀

### 💡 `static final` 상수
`Idol` 클래스에 소속사 이름, 최대 인원 같은 값을 **상수**로 선언

```java
public static final String COMPANY_NAME = "HYBE";
public static final int MAX_GROUP_SIZE = 7;
```
- `static` → 모든 Idol이 공유 (메모리 효율)
- `final` → 값 변경 불가 (불변)

---

## 2) `final` 한 줄 정리

### ✅ 의미
**“한 번 정해진 걸 못 바꾸게 잠그는 키워드”**

---

## 3) `final` 변수(필드) 초기화 방법 3가지

`final`은 “값을 못 바꾸는” 게 핵심이라서, **초기화를 어디서 할 수 있는지**가 중요

### 3-1) 선언과 동시에 초기화

가장 단순하고 안전한 방식

```java
private final String name = "아이유";
```

* 장점: 코드가 간단하고 실수 적음
* 단점: 객체마다 다른 값을 넣기 어려움

---

### 3-2) 생성자에서 초기화

객체 생성할 때 외부에서 값을 받아서 넣고 싶을 때 가장 많이 사용

```java
private final String name;

public Idol(String name) {
    this.name = name;
}
```

✅ 규칙

* 생성자가 여러 개면, **모든 생성자에서 final 필드를 반드시 초기화**해야 함

---

### 3-3) 초기화 블록에서 초기화

“초기화 로직(계산/조건)”이 필요할 때 쓰는 방식

#### (1) 인스턴스 초기화 블록 (객체 생성 시 실행)

```java
private final String name;

{
    name = "기본값";
}
```

#### (2) static 초기화 블록 (클래스 로딩 시 실행) — `static final`과 궁합 좋음

```java
public static final int MAX;

static {
    MAX = 7;
}
```

* 장점: 계산/조건이 들어간 초기화 가능
* 단점: 가독성이 떨어질 수 있어서 보통은 “선언/생성자”가 우선 선택

---

## 4) `final` 필드(변수): 값 변경 금지

### 4-1) `final` 인스턴스 변수
인스턴스마다 값은 다를 수 있지만, **각 객체 안에서는 한 번 정해지면 못 바뀜**

```java
private final String name; // final 인스턴스 변수
```

### 4-2) 바꾸려고 하면 컴파일 에러

```java
// idol.name = "새이름"; // 컴파일 에러! final 필드는 변경 불가
// Idol.COMPANY_NAME = "새소속사"; // 컴파일 에러! final 변수는 변경 불가
```

반대로 `final`이 아닌 값은 변경 가능:

```java
idol.groupName = "새그룹"; // 정상 동작 (final이 아님)
```

---

## 5) `final` 메서드: 오버라이딩 금지

### ✅ 의미
**자식 클래스가 “이 메서드 동작을 바꾸지 못하게” 막는다.**

`Idol` 클래스 `final` 메서드:

```java
public final void showCompanyInfo() {
    System.out.println("소속사: HYBE");
}
```

그래서 자식 클래스(`SoloArtist`)에서 오버라이딩하려고 하면 컴파일 에러:

```java
// final 메서드는 오버라이딩 불가
// @Override
// public void showCompanyInfo() {} // 컴파일 에러!
```

📌 활용
- “이 기능은 절대 바뀌면 안 된다” (규칙/보안/핵심 로직 고정)
- 프레임워크에서 템플릿 메서드 패턴처럼 “흐름 고정”할 때 자주 사용

---

## 6) `final` 클래스: 상속 자체 금지

### ✅ 의미
**“이 클래스는 더 이상 확장(상속) 금지”**

`Actor`는 `final class`로 선언돼 있었어:

```java
public final class Actor {
    ...
}
```

그래서 상속하려고 하면 컴파일 에러:

```java
// public class SoloActor extends Actor { }
// 컴파일 에러! final 클래스는 상속 불가
```

📌 활용
- 클래스를 상속해서 동작을 바꾸면 위험한 경우 (설계 의도 보호)
- 불변 객체(Immutable) 설계를 강하게 지키고 싶을 때
- 대표 예: `String` 같은 표준 라이브러리도 이런 이유로 설계가 중요

---

## 🎯 최종 정리

| 키워드 | 적용 위치 | 의미 | 오늘 코드 예시 |
|---|---|---|---|
| `static` | 필드/메서드 | 클래스당 1개(공유) | `Idol.COMPANY_NAME` |
| `final` | 변수(필드) | 값 변경 불가 | `private final String name;` |
| `static final` | 변수(필드) | “공유 + 불변” 상수 | `public static final ...` |
| `final` | 메서드 | 오버라이딩 불가 | `public final void showCompanyInfo()` |
| `final` | 클래스 | 상속 불가 | `public final class Actor` |

---

## 💬 오늘의 소감
- `static`은 “공통으로 하나만 공유할 값”, `final`은 “절대 바꾸면 안 되는 값/규칙”이라는 느낌이 확 잡혔다.
- `final`은 “못 바꾸는 것”만 기억할 게 아니라, **어디서 딱 1번 초기화하는지**까지 같이 기억해야 실수하지 않는다.
