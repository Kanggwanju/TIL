# 탭 실습 기록

## 📅 2025년 6월 13일


<details>
<summary>html, css</summary>

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Title</title>
  <style>
      body {
          background-color: #f0f2f5;
          display: flex;
          justify-content: center;
          align-items: center;
          height: 100vh;
          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }
      .step-container {
          width: 700px;
          padding: 30px;
          background-color: white;
          border-radius: 12px;
          box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
      }
      .step-indicator-container {
          display: flex;
          justify-content: space-between;
          align-items: center;
          position: relative;
          margin-bottom: 40px;
      }
      /* 스텝 사이의 회색 연결선 */
      .step-indicator-container::before {
          content: '';
          position: absolute;
          top: 50%;
          left: 0;
          width: 100%;
          height: 4px;
          background-color: #e0e0e0;
          transform: translateY(-50%);
          z-index: 1;
      }
      .step-indicator {
          width: 40px;
          height: 40px;
          border-radius: 50%;
          background-color: #e0e0e0;
          color: #757575;
          display: flex;
          justify-content: center;
          align-items: center;
          font-weight: bold;
          z-index: 2;
          border: 4px solid #e0e0e0;
          cursor: pointer;
          transition: all 0.3s ease;
      }
      .step-indicator.active {
          background-color: #3498db;
          color: white;
          border-color: #3498db;
          transform: scale(1.1);
      }
      .step-content {
          display: none; /* 기본적으로 모든 콘텐츠는 숨김 */
          padding: 20px;
          border: 1px dashed #ddd;
          border-radius: 8px;
      }
      .step-content.active {
          display: block; /* active 클래스가 붙은 콘텐츠만 보여줌 */
      }
      h3 {
          color: #333;
      }
      p {
          color: #666;
          line-height: 1.6;
      }
      .step-navigation {
          display: flex;
          justify-content: space-between;
          margin-top: 30px;
      }
      .nav-button {
          padding: 12px 25px;
          border: none;
          border-radius: 6px;
          background-color: #3498db;
          color: white;
          font-size: 16px;
          font-weight: bold;
          cursor: pointer;
          transition: background-color 0.2s ease, opacity 0.2s ease;
      }
      .nav-button:disabled {
          background-color: #bdc3c7;
          cursor: not-allowed;
          opacity: 0.7;
      }
  </style>
</head>
<body>

  <div class="step-container">
    <div class="step-indicator-container">
      <div class="step-indicator active" data-step="1">1</div>
      <div class="step-indicator" data-step="2">2</div>
      <div class="step-indicator" data-step="3">3</div>
      <div class="step-indicator" data-step="4">4</div>
    </div>

    <div class="step-content-container">
      <div class="step-content active" id="step-1">
        <h3>1단계: 약관 동의</h3>
        <p>서비스 이용 약관 및 개인정보 처리 방침에 동의해주세요. 모든 내용은 꼼꼼히 읽어보시는 것이 좋습니다.</p>
      </div>
      <div class="step-content" id="step-2">
        <h3>2단계: 본인 인증</h3>
        <p>사용자님의 정보를 안전하게 보호하기 위해 본인 인증을 진행합니다. 휴대폰이나 아이핀으로 인증할 수 있습니다.</p>
      </div>
      <div class="step-content" id="step-3">
        <h3>3단계: 정보 입력</h3>
        <p>회원가입에 필요한 기본 정보를 입력해주세요. 아이디, 비밀번호, 이메일 주소는 정확하게 입력해야 합니다.</p>
      </div>
      <div class="step-content" id="step-4">
        <h3>4단계: 가입 완료</h3>
        <p>축하합니다! 회원가입이 성공적으로 완료되었습니다. 이제 모든 서비스를 자유롭게 이용하실 수 있습니다.</p>
      </div>
    </div>

    <div class="step-navigation">
      <button class="nav-button" id="prev-btn" disabled>이전</button>
      <button class="nav-button" id="next-btn">다음</button>
    </div>
  </div>
</body>
</html>
```
</details>


1. 필요 요소 노드 가져오기, 변수 선언
내코드
```js
// 전역 변수
const $prevBtn = document.getElementById('prev-btn');
const $nextBtn = document.getElementById('next-btn');
const $stepIndicators = [...document.querySelectorAll('.step-indicator')];
const $stepContents = [...document.querySelectorAll('.step-content')];
const $container = document.querySelector('.step-indicator-container');
let idx = 0;
```

선생님코드
```js
// ====== 필요한 요소 노드들 가져오기 ===== //
// 이전, 다음 버튼 가져오기
const [$prevBtn, $nextBtn] = [...document.querySelector('.step-navigation').children];
const $contents = [...document.querySelectorAll('.step-content')];
const $indicators = [...document.querySelectorAll('.step-indicator')];

// ====== 필요한 변수 선언 ======= //
// 지금 현재 몇단계를 보고있는지를 전역적으로 기억할 수 있게
let currentStep = 1;
// 전체 단계의 개수
const totalSteps = $indicators.length;
```

느낀점
- 선생님처럼 주석을 좀 더 달아서 어떤 역할을 하는지에 대해서 설명을 써야겠다고 느낌. 늘 생각하지만 막상 실습할 때는 떠오르지 않고있다.
- 나는 다음, 이전 버튼 클릭, 인디케이터 직접 클릭을 통해 바뀌어질 내용물을 관리하기 위해서 인덱스라는 변수를 만들었다.
- 하지만 선생님은 지금 몇단계를 보고있는지를 전역적으로 기억할 수 있을 변수를 선언하고, 인디케이터의 길이만큼 전체 단계의 개수를 설정해놓으셨다. 이를 통해 나중에 인디케이터가 많아져도 쉽게 유지 보수를 할 수 있을 것이다.


2. 함수 정의
내 코드
```js
// ===== 함수 ===== //

// 인디케이터, 콘텐츠 active 클래스 변경 함수
function changeContents() {
    // 모든 인디케이터, 콘텐트에서 active 클래스 제거
    $stepIndicators.forEach(indicator => {
    indicator.classList.remove('active');
    });
    $stepContents.forEach(content => {
    content.classList.remove('active');
    });

    // 감소한 인덱스에 해당하는 인디케이터에 active 클래스 추가
    $stepIndicators[idx].classList.add('active');
    $stepContents[idx].classList.add('active');
}
```

선생님 코드
```js
// ==== 공통 처리 함수 정의 ==== //
function updateUI() {
    // 1. 인디케이터에 현재스텝에 맞는 태그를 찾아 active부여
    $indicators.forEach(($indicator, index) => {
    if (currentStep === index + 1) {
        $indicator.classList.add('active');
    } else {
        $indicator.classList.remove('active');
    }
    });

    // 2. 콘텐츠 박스 업데이트
    $contents.forEach(($content) => {
    // 현재 활성화해야하는 컨텐츠박스의 id의 끝값과 currentStep의 값이 일치
    if ($content.getAttribute('id') === `step-${currentStep}`) {
        $content.classList.add('active');
    } else {
        $content.classList.remove('active');
    }
    });

    // 3. 이전/ 다음버튼 활성화 처리
    // step 1에서만 이전버튼 비활성화 나머지는 활성화
    // 마지막스텝에서만 다음버튼 비활성화 나머지는 활성화
    $prevBtn.disabled = currentStep === 1;
    $nextBtn.disabled = currentStep === totalSteps;
}
```

느낀점
- 나는 changeContents() 함수에서 idx를 이용하여 인디케이터와 콘텐트에서 active 클래스를 제거하고, 추가하는 동작을 작동하게 한 것은 잘했다고 생각한다.
- 하지만, 이전, 다음 버튼 활성화 처리를 선생님처럼 함수로 만들어서 작동시켰다면 더 깔끔한 결과물이 나왔을 것이라고 느꼈다.


3. 이벤트 핸들러 바인딩
내 코드
```js
// 이벤트 핸들러 바인딩
// 다음 버튼 클릭
$nextBtn.addEventListener('click', e => {
    // 다음 인디케이터가 마지막인지 감지
    if (idx === $stepIndicators.length-2) {
        $nextBtn.disabled = true;
        $prevBtn.disabled = false;
    } else {
        // 마지막을 제외하고는 이전 버튼 활성화
        $prevBtn.disabled = false;
    }

    // 인덱스 증가
    idx++;

    // 인디케이터, 콘텐츠 active 클래스 변경 함수
    changeContents();
});


// 이전 버튼 클릭
$prevBtn.addEventListener('click', e => {
    // 이전 인디케이터가 처음인지 감지
    if (idx === 1) {
        $nextBtn.disabled = false;
        $prevBtn.disabled = true;
    } else {
        // 처음을 제외하고는 다음 버튼 활성화
        $nextBtn.disabled = false;
    }

    // 인덱스 감소
    idx--;

    // 인디케이터, 콘텐츠 active 클래스 변경 함수
    changeContents();
});

// 인디케이터 클릭
$container.addEventListener('click', e => {
    if (!e.target.matches('.step-indicator')) return;

    idx = e.target.dataset.step - 1;

    // 처음 감지
    if (idx === 0) {
        $nextBtn.disabled = false;
        $prevBtn.disabled = true;
    } else if (idx === $stepIndicators.length - 1) {
        $nextBtn.disabled = true;
        $prevBtn.disabled = false;
    } else {
        $nextBtn.disabled = false;
        $prevBtn.disabled = false;
    }

    // 인디케이터, 콘텐츠 active 클래스 변경 함수
    changeContents();
});
```

선생님 코드
```js
// ====  이벤트 바인딩 ==== //
// 다음버튼 클릭시
$nextBtn.addEventListener('click', e => {
    if (currentStep < totalSteps) {
        currentStep++;
        // UI 업데이트
        updateUI();
    }
});

// 이전버튼 클릭시
$prevBtn.addEventListener('click', e => {
    if (currentStep > 1) {
        currentStep--;
        // UI 업데이트
        updateUI();
    }
});

// 인디케이터 직접 클릭 시
$indicators.forEach($indicator => {
    $indicator.addEventListener('click', e => {
        currentStep = +e.target.dataset.step;
        updateUI();
    });
});
```

느낀점
- 2번 함수 정의 부분에서 말했듯이 선생님은 함수 정의 부분에서 이전, 다음 버튼의 활성화 처리를 하셨다. 이벤트 바인딩 3곳에서 반복되는 부분이므로 함수로 정의하여 사용하면 더 깔끔한 코드가 됐을 것이다.
- 나는 idx에 따라서 버튼 활성화를 복잡하게 했지만, 선생님이 한 것처럼 `$prevBtn.disabled = idx === 0;`, `$nextBtn.disabled = idx === $stepIndicators.length - 1;`으로 설정했다면 더 깔끔하게 할 수 있다는걸 배웠다.
- `e.target.dataset.step`은 string이므로 안전하게 앞에 +를 붙여서 숫자로 만든 뒤 계산해야 된다는 것을 배움.
- `!e.target.matches('.step-indicator')`를 통해 클릭한 요소가 정확히 인디케이터가 아니라면 선택되지 않도록 한 것은 잘했다고 생각한다. 인디케이터의 부모 태그인 콘테이너에 클릭 이벤트를 바인딩 했기 때문에 이렇게 한 것이고, `event-delegation`을 생각해내서 제어한 것은 뿌듯했다.