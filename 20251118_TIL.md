# 🗓️ 2025년 11월 18일 TIL - c언어

## 📌 오늘의 키워드

`동적 메모리 할당 (Dynamic Memory Allocation)` `malloc()` `free()` `NULL 포인터`
`메모리 누수 (Memory Leak)` `2차원 배열 동적 할당` `힙(Heap)` `스택(Stack)`

---

## 1️⃣ 동적 메모리 할당의 개념

### 💡 개념 정리

* **정적 메모리 할당**: 배열 크기가 **컴파일 시점**에 고정됨
* **동적 메모리 할당**: 프로그램 실행 중(`Runtime`)에 메모리를 **필요한 만큼 요청**
* `malloc()` 함수를 이용해 운영체제(OS)로부터 **힙(Heap)** 영역을 빌림
* 사용이 끝나면 반드시 `free()`를 통해 **직접 반납**해야 함

> ✅ 힙 영역은 넓고 유연하지만, 자동 해제가 되지 않아 관리가 필요함

---

## 2️⃣ malloc() 기본 사용법

### 💻 예시 코드

```c
int *arr = (int*)malloc(4 * sizeof(int));

if (arr == NULL) {
    printf("메모리가 할당되지 않았습니다.");
    return 1;
}

printf("메모리 할당 성공! 주소: %p\n", arr);

arr[0] = 10;
arr[1] = 20;
arr[2] = 30;
arr[3] = 40;

for (int i = 0; i < 4; i++) {
    printf("arr[%d] = %d\n", i, arr[i]);
}

free(arr);
```



### 🔍 설명

* `malloc(4 * sizeof(int))` → `int`형 4개의 공간을 요청 (4 × 4byte = 16byte)
* `malloc()`은 성공 시 **할당된 첫 번째 주소를 반환**, 실패 시 `NULL` 반환
* `free()`를 통해 메모리 반납 (스택 변수는 자동, 힙 변수는 수동 관리)

---

## 3️⃣ 사용자 입력 기반 동적 배열

### 💻 예시 코드

```c
int student_count;
printf("성적을 입력할 학생 수 : ");
scanf("%d", &student_count);

int *scores = (int*)malloc(student_count * sizeof(int));

if (scores == NULL) {
    printf("메모리가 할당되지 않았습니다.");
    return 1;
}

for (int i = 0; i < student_count; i++) {
    printf("%d번 학생의 성적: ", i + 1);
    scanf("%d", &scores[i]);
}

for (int i = 0; i < student_count; i++) {
    printf("%d번 학생의 점수: %d점\n", i + 1, scores[i]);
}

free(scores);
```



### 🔍 포인트

* 사용자가 입력한 수(`student_count`)에 따라 배열 크기가 결정됨
* `malloc()`을 통해 유연하게 크기 조절 가능
* `free()` 호출 후에는 **주소나 값에 접근 금지 (dangling pointer 위험)**

  * `scores = NULL;`로 초기화하는 습관 권장

---

## 4️⃣ 메모리 누수(Memory Leak)의 위험

### ⚠️ 주의사항

* `malloc()`으로 할당한 메모리를 **`free()`로 해제하지 않으면**,
  프로그램이 종료될 때까지 그 공간은 다시 사용되지 않음
* 이러한 현상을 **메모리 누수**라고 하며,
  반복되면 **프로그램이 비정상적으로 종료**될 수 있음

### ✅ 올바른 사용 패턴

```c
int *data = (int*)malloc(100 * sizeof(int));
...
free(data);
data = NULL;
```

---

## 5️⃣ 2차원 배열의 동적 할당

### 💻 예시 코드

```c
int rows = 3, cols = 4, i, j;

int **arr = (int**)malloc(rows * sizeof(int*));

for (i = 0; i < rows; i++) {
    arr[i] = (int*)malloc(cols * sizeof(int));
}

for (i = 0; i < rows; i++) {
    for (j = 0; j < cols; j++) {
        arr[i][j] = i * 10 * j;
        printf("%d ", arr[i][j]);
    }
    printf("\n");
}

// 해제는 할당의 역순
for (i = 0; i < rows; i++) {
    free(arr[i]);
}
free(arr);
```



### 🔍 핵심 포인트

* 2차원 배열은 **“행의 주소를 담는 포인터 배열”** 로 구성됨
* `malloc()`을 두 번 사용 →
  ① 행 포인터 배열 할당 → ② 각 행의 실제 열 공간 할당
* 해제 시 **역순으로 free()** 해야 함
  (각 행 → 전체 포인터 배열 순서로)

---

## 🎯 최종 정리

| 구분         | 특징                | 함수                                      | 주의점            |
| ---------- | ----------------- | --------------------------------------- | -------------- |
| `malloc()` | 지정된 크기만큼 메모리 요청   | `malloc(size)`                          | 실패 시 `NULL` 반환 |
| `free()`   | 할당된 메모리 해제        | `free(ptr)`                             | `free` 후 접근 금지 |
| 동적 1차원 배열  | 크기 변경 가능          | `int *p = malloc(n * sizeof(int));`     | 꼭 `free()` 필요  |
| 동적 2차원 배열  | 행 포인터 배열 + 각 행 공간 | `int **p = malloc(rows * sizeof(int*))` | 해제 순서 주의       |
| 메모리 누수     | 해제되지 않은 메모리       | -                                       | 시스템 리소스 소모 위험  |

---

## 💬 오늘의 소감

오늘은 **malloc()과 free()를 이용한 동적 메모리 관리**를 배웠다.
처음에는 “배열은 선언할 때 크기가 정해지는 것”이라고 생각했지만,
실행 도중에도 `malloc()`으로 메모리를 자유롭게 빌릴 수 있다는 점이 흥미로웠다.
특히 2차원 배열의 동적 할당은 “포인터 배열이 행을 가리킨다”는 구조적 이해가 필요했다.
이제부터는 `malloc()`을 사용할 때 반드시 `free()`와 짝지어 쓰는 습관을 들여야겠다.
