# 🗓️ 2025년 6월 19일 TIL

프로미스
장점: 비동기 통신을 순차적으로 실행하고자 하나, 콜백지옥이 만들어지는걸 해결

첫번째 작업
```javascript
// 프로미스 생성을 위한 실행기 정의
function executor(resolve, reject) {
  // resolve : 약속이 이행되었을 때 실행할 콜백
  // reject : 약속이 거부되었을 때 실행할 콜백
  const flag = true;
  if (flag) {
    resolve('야호 신난다!! 김치찌개 냠냠');
  } else {
    reject('실패!! 주방에 불이 났어요!');
  }
}

// 프로미스 생성
const myPromise1 = new Promise(executor);
```

두번째 작업
- 첫번째 작업에서 성공 메시지를 받아서 그 메시지에 추가 메시지를 더해서 출력!
- 처음 작업에서 이어서 갈 때는 `첫약속.then`, 첫 약속이 성공했으면 실행됨
- x에는 첫번째 작업의 결과가 있음.

```javascript
const myPromise2 = myPromise1.then((x) => {
  // console.log(x);
  const result = x + '\n계산은 어디서 하죠??';
  return new Promise((resolve, reject) => {
    resolve(result); // 성공했을 때 실행할 콜백
  });
});
```

promise 중첩하여 사용할 때 축약 가능
```javascript
$fetchBtn.addEventListener('click', e => {
  fetchGet(`${serverUrl}/users`)
    .then((userList) => fetchGet(`${serverUrl}/posts?userId=${userList[1].id}`))
    .then((postList) => fetchGet(`${serverUrl}/comments?postId=${postList[3].id}`))
    .then((commentList) => {
      commentList.forEach(comment => {
        const $div = document.createElement('div');
        $div.textContent = comment.name;
        document.body.append($div);
      });
    });
});
```
.then은 성공했을 때 실행하고
.catch는 실패했을 때만 실행하고
.finally는 성공해도, 실패해도 실행함


fetch 기본
- fetch는 기본적으로 promise를 반환함.
기본 사용법
```javascript
fetch(url, options)
  .then(response => {
    // 1차적으로 응답을 처리하는 곳
  })
  .catch(error => {
    // 네트워크 에러 등이 발생했을 때 처리하는 곳
  });
```
`options`(선택 사항): 요청 방식을 정하거나(GET, POST 등), 데이터를 담아 보낼 때
사용하는 설정 객체. 비워두면 기본적으로 `GET` 방식으로 요청한다.




JSON 데이터 처리
- `fetch`를 통해 받은 응답은`Response`라는 객체로 한 번 감싸여 있어요.
- 우리가 실제 사용하고 싶은 데이터(주로 JSON)를 꺼내려면.
- `json()`메서드를 호출해야 합니다.
- fetch는 서버가 에러 상태코드를 보내도 바로 catch로 reject 하지 않습니다.
  그래서 상태코드를 확인해서 ok가 아닌 경우 직접 에러를 만들어서 보내야함
```javascript
fetch('https://jsonplaceholder.typicode.com/posts')
  .then(res => {
    // res.ok는 HTTP 상태 코드가 200~299 범위에 있는지 확인해주는 값이에요.
    if (!res.ok) {
      throw new Error("요청이 실패했어요!"); // 404, 500 같은 에러일 때
    }
    // 성공했다면, 응답을 JSON으로 변환하는 Promise를 리턴!
    return res.json();
  })
  .then(posts => {
    // 성공했을 때 실행
    displayPosts(posts.slice(0, 5)); // 상위 5개의 게시물만 표시
  })
  .catch(error => {
    // 실패했을 때만 실행
    postsContainer.innerHTML = `<p style="color: red;">${error}</p>`;
  })
  .finally(() => {
    // 성공해도 실행, 실패해도 실행
    console.log("데이터 요청 완료");
  });
```




async await
- fetch 코드를 간소화 가능 아래 두 함수는 동일한 결과를 낸다.
- 화살표 함수로 만들 때는 파라미터 () 앞에 async를 적는다.
```javascript
// 회원데이터를 서버에서 불러오는 함수 fetch로 구현
function fetchGet() {
  fetch(url)
    .then(res => res.json())
    .then(userList => {
      console.log(userList);
    })
}

// async await 으로 fetch 코드 간소화
async function fetchGetAsync() {
  const res = await fetch(url);
  const userList = await res.json();
  console.log(userList);
}
```




substring
문자열.substring(startIndex, endIndex);
startIndex: 포함 (이 위치부터 시작)
endIndex: 불포함 (이 위치 "바로 앞"까지 자름)
예시코드
```js
const jsonString = '```json\n{ "name": "현아" }\n```';
const start = jsonString.indexOf('{');
const end = jsonString.lastIndexOf('}');
const pureJson = jsonString.substring(start, end + 1);

console.log(pureJson); // { "name": "현아" }
```




## 🌟 오늘의 실습: 비동기 통신 포켓몬 API 실습
- IntersectionObserver 기반 무한 스크롤 구현
- Skeleton UI 적용 및 사용자 경험 개선
- 모달 정보 동적 렌더링 및 이벤트 처리
- `dataset`, `substring`, `fetch` 응답 핸들링 등 JS 기초 심화

---

## 🧾 실습 내용 정리

### 1. IntersectionObserver로 무한 스크롤 구현
- `.observe()`에 전달되는 대상은 반드시 **실제 DOM 요소**여야 함.
- 요소가 추가되기 전에 `observe()`를 실행하면 `undefined` 참조 에러 발생 (`parameter 1 is not of type Element`)
- 해결: `loadMoreContent()` 함수 내에서 카드가 **렌더링된 직후** `observer.observe()` 호출
- 이전에 감시하던 요소는 `unobserve()`로 감시 해제 후 새로 감시 시작

```js
if (lastObserved) observer.unobserve(lastObserved);
lastObserved = $pokeContainer.lastElementChild;
observer.observe(lastObserved);
```

---

### 2. Skeleton UI 적용

* 모달 콘텐츠가 렌더링되기 전까지 `#modal-skeleton`을 보여줌 → 사용자에게 로딩 중이라는 피드백 제공
* 데이터 렌더링 완료 후에는 `modal-skeleton`을 `display: none`, 실제 콘텐츠는 `display: flex`로 전환

```js
$modalContent.style.display = 'none';
document.getElementById('modal-skeleton').style.display = 'flex';

setTimeout(() => {
  // 데이터 렌더링
  $modalImage.src = poke.img;
  ...
  // UI 전환
  document.getElementById('modal-skeleton').style.display = 'none';
  $modalContent.style.display = 'flex';
}, 1000);
```

---

### 3. `dataset` 활용법

```html
<button data-user-id="101">삭제</button>
```

```js
btn.dataset.userId;  // "101"
btn.dataset.role = 'admin'; // 동적 수정 가능
```

* `data-*` 속성은 `element.dataset.keyName`으로 접근하며,
* `data-poke-number` → `dataset.pokeNumber` 식으로 camelCase로 자동 변환됨

---

### 4. fetch 응답 상태 코드 확인

```js
fetch(API_URL, ...)
  .then(res => {
    if (!res.ok) throw new Error(`상태 코드: ${res.status}`);
    return res.json();
  })
```

* `res.ok`: 상태 코드가 200\~299일 때 true
* `res.status`: 실제 숫자 코드 확인 가능

---

## 🐛 실습 중 겪은 문제 & 해결

| 문제                      | 원인                           | 해결 방법                  |
| ----------------------- | ---------------------------- | ---------------------- |
| IntersectionObserver 에러 | `observe()`에 `undefined` 전달됨 | 요소 렌더링 후에 observe 실행   |
| 스켈레톤 겹침                 | `display: none`이 빠져 있음       | skeleton 제거 후 콘텐츠 보여주기 |
| 모달이 까맣게 보임              | `<style><style>` 중복 오타       | style 태그 정상화 후 해결      |
| API 400 에러              | payload 구조 오류, 응답 체크 누락      | `res.ok` 체크 및 구조 검증 추가 |

---

## 📚 오늘의 회고

* `IntersectionObserver`를 제대로 사용하려면 **DOM 요소 존재 여부와 시점**이 중요하다는 걸 배움
* Skeleton UI를 사용하면 UX가 눈에 띄게 향상됨
* 작은 오타(`<style><style>`) 하나도 전체 레이아웃을 망가뜨릴 수 있으므로 꼼꼼한 확인이 필요함
* `.dataset`, `.substring()` 같이 기초 메서드도 **실전에서 자주 쓰인다**


