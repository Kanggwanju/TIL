# 🗓️ 2025년 10월 16일 TIL



## 설정과 비밀의 분리, ConfigMap & Secret

- 프로필을 prod로 설정할 경우 앱이 계속 재시작하는 CrashLoopBackOff 에러 발생
- 원인은 바로 DB 접속 정보가 없어서 스프링 부트 앱이 시작조차 못 하고 죽어버림


## 설정을 코드와 분리

우리가 DB 접속 정보를 코드나 Docker 이미지 안에 직접 넣는경우
- 개발용 DB에서 테스트용 DB로 바꾸려면? 이미지를 다시 빌드
- 운영 DB의 비밀번호가 바뀌면? 이미지를 또다시 빌드
- DB 비밀번호가 담긴 이미지가 실수로 외부에 유출 가능

**12-Factor App 원칙**: 코드는 한 번만 빌드하고, 설정은 외부에서 주입하여 어떤 환경에서든 실행할 수 있어야 한다.

---

## 도구 소개: ConfigMap vs Secret

구분	ConfigMap (공개 게시판 📌)	Secret (비밀 금고 🔒)
용도	일반적인 설정 정보	비밀번호, API 키 등 민감 정보
저장 방식	일반 텍스트	Base64로 인코딩된 텍스트
예시	로깅 레벨, 타임존 설정	DB 비밀번호, JWT 시크릿 키

---

## [실습] Secret으로 앱에 생명 불어넣기
- `CrashLoopBackOff` 문제를 해결하기 위해, DB 접속 정보를 담은 `Secret`을 만들고 Pod에 주입

### 1. Secret 생성하기
- `kubectl` 명령어를 이용해 DB 접속 정보를 담은 `my-db-secret`이라는 이름의 Secret을 생성
- 오류 발생시 한줄로 명령어 작성 혹은 작은 따옴표 제거

```
kubectl create secret generic my-db-secret \
--from-literal=DB_URL='jdbc:h2:mem:testdb' \
--from-literal=DB_USERNAME='sa' \
--from-literal=DB_PASSWORD='password'
```

- `secret/my-db-secret created` 메시지가 나오면 성공
- `kubectl get secrets` 명령어로 생성된 Secret을 확인 가능

### 2. deployment.yml 파일 수정
- Deployment가 Pod를 만들 때, 방금 만든 `Secret`의 값을 읽어서 컨테이너의 환경 변수(Environment Variable)로 넣어주도록 `deployment.yml`을 수정

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: memo-api-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: memo-api
  template:
    metadata:
      labels:
        app: memo-api
    spec:
      containers:
        - name: memo-api-container
          image: my-spring-app
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          # 👇 이 아래 env 부분을 추가합니다.
          env:
            - name: DB_URL # 컨테이너에 설정될 환경 변수 이름
              valueFrom:
                secretKeyRef:
                  name: my-db-secret # 사용할 Secret의 이름
                  key: DB_URL       # Secret 안에서 가져올 데이터의 Key
            - name: DB_USERNAME
              valueFrom:
                secretKeyRef:
                  name: my-db-secret
                  key: DB_USERNAME
            - name: DB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: my-db-secret
                  key: DB_PASSWORD
```


### 3. 재배포 및 성공 확인

1. 수정한 YAML 파일 다시 적용하기
```shell
kubectl apply -f deployment.yml
```

2. Pod 상태 실시간으로 지켜보기
  - `kubectl get pods -w`
  - 이전 Pod는 `Terminating`되고, 새로운 Pod가 생성

3. 로그로 성공 확인하기 (가장 중요!)
  - 새로 생성된 Pod의 이름을 확인하고, `logs` 명령어를 실행
    ```shell
    kubectl get pods
    
    # kubectl logs [새로운_Pod_이름]
    kubectl logs memo-api-deployment-xxxxxxxxxx-xxxxx
    ```

---

## AWS EKS(Elastic Kubernetes Service) - 관리형 쿠버네티스
- 컨트롤 플레인 운영을 AWS가 전부 책임져 주는 서비스
- 우리 앱을 잘 만들고 배포하는 데에만 집중

### EKS 아키텍처
- AWS 관리 영역 (Control Plane):
  - 우리가 직접 볼 수도, 만질 수도 없는 AWS의 영역에 존재
  - AWS의 전문가들이 24시간 모니터링하며 업데이트, 보안, 백업 등을 모두 책임짐
  - 우리는 그냥 `kubectl`로 명령만 내리면 됨

- 사용자 관리 영역 (Data Plane):
  - 우리 AWS 계정 안에 EC2 인스턴스로 생성
  - 이 '워커 노드'들의 사양(t3.small, m5.large 등)과 개수는 우리가 직접 결정 가능
  - 우리 애플리케이션 Pod들은 바로 이 EC2 인스턴스 위에서 실행됨

### EKS 사용 장점
- 높은 안정성
- 관리 부담 감소
- 뛰어난 확장성
- AWS 서비스와의 완벽한 연동

---

## EKS 클러스터 구축을 위한 사전 준비

### `eksctl`: EKS를 위한 만능 건설 도구
- EKS 클러스터를 만들고, 관리하고, 삭제하는 모든 작업을 커맨드 라인에서 할 수 있게 해주는 공식 CLI 도구

### `eksctl` 설치하기

- Windows (Chocolatey 사용 시)
```shell
# 관리자 권한으로 PowerShell을 열고 실행하세요.

# chocolatey 설치
Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))

# eksctl 설치
choco install eksctl

# 설치 확인
eksctl version
```

### AWS 출입증 재확인 (`aws configure`)
```shell
aws configure
```
- Access Key ID, Secret Access Key, Default region name 확인
- 문제 없다면 엔터 치고 넘어감

---

## 나의 첫 클라우드 클러스터 구축

### 비용 관련 중요!
- 실습이 끝나면 반드시 클러스터를 삭제합니다.
- 가장 저렴한 사양의 워커 노드를 사용합니다.

### `eksctl`로 EKS 클러스터 생성
- 15분에서 20분 정도 소요

```shell
eksctl create cluster \
--name my-eks-cluster \
--region ap-northeast-2 \
--nodes 2 \
--node-type t3.small
```
- --name [클러스터 이름]: 생성될 EKS 클러스터의 고유한 이름
- --region [AWS 리전]: 클러스터가 생성될 AWS의 지역, 우리는 서울(ap-northeast-2)을 사용
- --nodes [숫자]: 워커 노드(EC2 인스턴스)의 개수, 2로 시작하는 것이 안정적
- --node-type [EC2 타입]: 워커 노드의 사양입니다. t3.small은 비용이 저렴하면서도 우리 실습을 진행하기에 충분한 성능


### AWS 콘솔에서 클러스터 생성 완료 확인

#### 1. Elastic Kubernetes Service 콘솔 확인
- EKS 서비스로 이동하면, 방금 우리가 만든 my-eks-cluster가 활성(Active) 상태로 목록에 보입니다.

#### 2. EC2 콘솔 확인
- EC2 인스턴스 2개가 `실행 중` 상태로 떠 있는 것을 볼 수 있습니다.
- 이들이 바로 우리 애플리케이션이 실행될 워커 노드입니다.

#### 3. CloudFormation 콘솔 확인 (마법의 근원)
- `CloudFormation` 서비스로 이동
- `eksctl-my-eks-cluster-cluster` 라는 이름의 스택(Stack)이 `CREATE_COMPLETE`상태로 생성된 것을 볼 수 있습니다.

---

## EKS 클러스터에 애플리케이션 배포

### `kubectl`에 EKS 클러스터 등록
- 지금 우리의 `kubectl`은 로컬의 Docker Desktop 클러스터를 바라보고 있습니다.
- 이제부터는 AWS에 있는 EKS 클러스터와 통신해야 한다고 알려줘야 합니다.

```shell
aws eks update-kubeconfig --name my-eks-cluster --region ap-northeast-2

# 연결 확인
kubectl get nodes
```

### EKS 배포를 위한 YAML 파일 수정
로컬 클러스터와 EKS 클러스터의 가장 큰 차이점 중 하나는 이미지를 가져오는 위치
- 로컬 클러스터: 내 컴퓨터에 있는 로컬 이미지를 사용
- EKS 클러스터: 모든 서버가 접근할 수 있는 중앙 이미지 저장소, 즉 ECR(Elastic Container Registry)에서 이미지를 가져와야 함

1. 10월 15일에 진행한 `ECR에 스프링 부트 앱 이미지 올리기 실습` 참고

2. `deployment.yml` 수정
```yaml
...
    spec:
      containers:
        - name: memo-api-container
          # 👇 이 부분을 ECR 이미지 URI로 수정합니다.
          image: <AWS계정ID>.dkr.ecr.<리전>.amazonaws.com/my-spring-app:<이미지태그>
          # 예시: 423458036718.dkr.ecr.ap-northeast-2.amazonaws.com/my-spring-app:latest

          # imagePullPolicy는 명시하지 않으면 기본값인 Always가 적용되어 ECR에서 잘 가져옵니다.
          # 따라서 IfNotPresent는 이제 지워도 괜찮습니다.
          ports:
            - containerPort: 8080
...
```

### EKS 클러스터에 전체 스택 배포

#### 1단계: AWS RDS 인스턴스 생성 (교안 참고)

#### 2단계: EKS가 RDS에 접속할 수 있도록 '방화벽' 열어주기
1. 생성한 RDS 인스턴스의 상세 페이지로 이동하여 연결 & 보안 탭을 클릭
2. VPC 보안 그룹에 있는 링크를 클릭하여 해당 보안 그룹 설정으로 이동
3. 인바운드 규칙 탭을 클릭하고, 인바운드 규칙 편집 버튼
4. 규칙 추가 버튼을 클릭하고 아래와 같이 설정
  - 유형: `MYSQL/Aurora`
  - 소스: `사용자 지정`을 선택, EKS 워커 노드(EC2)가 사용하고 있는 보안 그룹의 ID를 입력
5. 규칙 저장

#### 3단계: memo-api의 Secret 정보 업데이트
1. 기존 Secret 삭제
```yaml
kubectl delete secret my-db-secret
```

2. RDS 정보로 Secret 생성
- 작은 따옴표 제거, 한줄로 작성, 생성한 RDS 엔드포인트, 패스워드 기입 
```shell
# <RDS_ENDPOINT>와 <RDS_PASSWORD>를 본인의 정보로 바꿔주세요.
kubectl create secret generic my-db-secret \
--from-literal=DB_URL='jdbc:mariadb://<RDS_ENDPOINT>:3306/memodb' \
--from-literal=DB_USERNAME='admin' \
--from-literal=DB_PASSWORD='<RDS_PASSWORD>'

kubectl create secret generic my-db-secret --from-literal=DB_URL='jdbc:mariadb://<RDS_ENDPOINT>:3306/memodb' --from-literal=DB_USERNAME='admin' --from-literal=DB_PASSWORD='<RDS_PASSWORD>'
```

#### 애플리케이션(backend) 스택 배포
- ECR 이미지 주소로 수정한 `memo-api`의 Deployment와 Service를 배포
```shell
# Deployment 배포
kubectl apply -f deployment.yml

# 배포 최종 확인
kubectl get pods -w
```

---

## LoadBalancer Service로 세상에 앱 공개

### 1. `service.yml` 파일 수정

```yaml
apiVersion: v1
kind: Service
metadata:
  name: memo-api-service
spec:
  # 👇 type을 NodePort에서 LoadBalancer로 변경합니다.
  type: LoadBalancer
  selector:
    app: memo-api
  ports:
    - protocol: TCP
      port: 80 # 👈 외부에서는 표준 HTTP 포트인 80번으로 접속
      targetPort: 8080
```

### 2. 변경사항 적용
```yaml
kubectl apply -f service.yml
```

### 3. 과정 확인 (가장 중요!)
```yaml
kubectl get service memo-api-service -w
```

### 4. AWS 콘솔에서 직접 확인
- EC2 서비스로 이동한 뒤, 왼쪽 메뉴 하단의 로드 밸런서를 클릭
- `kubectl`명령어로 생성된 실제 로드 밸런서가 목록에 떠 있는 것을 눈으로 확인할 수 있음

### 5. 최종 접속 테스트
1. `kubectl get service` 명령어로 할당된 `EXTERNAL-IP`주소 전체를 복사
2. 웹 브라우저를 이용해, 포트 번호 없이 이 주소로 API를 호출

---

## 비용 관리 (모든 비용 발생 요소 삭제)

### EKS 클러스터 전체 삭제하기
```yaml
eksctl delete cluster --name my-eks-cluster --region ap-northeast-2
```

### RDS
- 생성한 RDS DB 삭제
- 삭제 안 되면 VPC 삭제


