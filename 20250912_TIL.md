# 🗓️ 2025년 9월 12일 TIL

## 📌 오늘의 키워드
`Private Route` `라우트 가드` `@Builder.Default` `@PrePersist` `JPA 콜백` `optional` `nullable` `@AuthenticationPrincipal` `Mock 데이터` `React 최적화` `Zustand 성능` `Axios`

---

## Private Route (라우트 가드) - React

### Loader vs Component 방식

**Loader 방식의 한계**:
- 로딩 중 UI를 보여줄 수 없음
- 사용자 경험이 떨어짐

**Component 방식의 장점**:
- 로딩 상태를 보여줄 수 있음
- 더 세밀한 제어 가능

---

### Private Route 컴포넌트 구현

```jsx
const PrivateRoute = ({ children }) => {
  const { isAuthenticated, loading, hasCheckedAuth, fetchMe } = useAuthStore();

  // 최초 진입 시 인증 체크 1회만 실행
  useEffect(() => {
    if (!hasCheckedAuth) {
      fetchMe();
    }
  }, [hasCheckedAuth, fetchMe]);
  
  // 인증되지 않은 사용자는 메인 페이지로 리다이렉트
  if (!isAuthenticated) {
    return (
      <Navigate
        to='/'
        replace  // 뒤로가기 시 이전 페이지로 돌아가지 않도록
      />
    );
  }

  // 인증된 사용자만 children 렌더링
  return children;
};
```

**동작 방식**:
1. 컴포넌트 마운트 시 `hasCheckedAuth` 확인
2. 인증 체크를 하지 않았다면 `fetchMe()` 실행
3. 인증되지 않았으면 메인 페이지로 리다이렉트
4. 인증되었으면 자식 컴포넌트 렌더링

---

### Router 설정에 적용

```jsx
{
  path: '/app',
  element: (
    <PrivateRoute>
      <AppLayout />
    </PrivateRoute>
  ),
  children: [
    { index: true, element: <Dashboard /> },
    { path: 'rooms', element: <StudyRoomList /> },
    { path: 'rooms/:id', element: <RoomDetail /> },
  ],
}
```

**구조**:
- `/app` 경로와 그 하위 경로는 모두 인증 필요
- `PrivateRoute`로 감싸서 보호
- 인증되지 않은 접근은 자동으로 차단

**화면 예시**:
```
┌─────────────────────────────────────┐
│  🔒 인증이 필요한 페이지입니다      │
│                                     │
│  로그인 페이지로 이동 중...         │
└─────────────────────────────────────┘
```

---

## JPA 엔티티 초기값 설정

### @Builder.Default vs @PrePersist

두 방식 모두 필드의 기본값을 설정하지만, 동작 시점과 우선순위가 다릅니다.

---

### 1. @Builder.Default (Lombok)

```java
@Builder.Default
@Column(name = "max_participants", nullable = false)
private Integer maxParticipants = 4;
```

**특징**:
- **Lombok의 빌더 패턴**에서 사용
- **객체 생성 시점**에 기본값 할당
- 빌더로 객체를 생성할 때 해당 필드를 명시하지 않으면 기본값 사용

**예시**:
```java
// maxParticipants를 명시하지 않으면 4가 자동 할당
StudyRoom room = StudyRoom.builder()
    .title("스터디룸")
    .host(user)
    // maxParticipants는 4로 자동 설정
    .build();
```

---

### 2. @PrePersist (JPA)

```java
@PrePersist
void onPrePersist() {
    // MVP 요구사항: 항상 4명으로 고정
    this.maxParticipants = 4;
}
```

**특징**:
- **JPA의 라이프사이클 콜백**
- 엔티티가 **데이터베이스에 저장되기 직전**(INSERT 전)에 실행
- `@Builder.Default`로 설정된 값도 덮어쓸 수 있음

---

### 우선순위 비교

```java
@Entity
public class StudyRoom {
    @Builder.Default
    @Column(nullable = false)
    private Integer maxParticipants = 4;  // 1순위: 빌더 기본값
    
    @PrePersist
    void onPrePersist() {
        this.maxParticipants = 4;  // 2순위: DB 저장 직전 (최종값)
    }
}
```

**실행 순서**:
1. `@Builder.Default`: 객체 생성 시 → `maxParticipants = 4`
2. 개발자가 값을 변경 → `room.setMaxParticipants(10)`
3. `@PrePersist`: DB 저장 직전 → `maxParticipants = 4` (다시 4로 덮어씀)
4. 최종 DB에 저장되는 값 → **4**

**결론**: `@PrePersist`가 최종 우선권을 가짐

---

## JPA 연관관계 필수 설정

### optional=false vs nullable=false

```java
@ManyToOne(fetch = FetchType.LAZY, optional = false)
@JoinColumn(name = "host_id", nullable = false)
private User host;
```

둘 다 `null`을 방지하지만, **검증 시점과 레벨**이 다릅니다.

---

### 1. optional=false (JPA 레벨)

```java
@ManyToOne(optional = false)
```

**특징**:
- **JPA 애플리케이션 레벨**에서 검증
- 엔티티 저장 시 `host`가 `null`이면 **JPA가 예외 발생**
- 데이터베이스 쿼리 전에 차단

**예시**:
```java
StudyRoom room = StudyRoom.builder()
    .title("스터디룸")
    .host(null)  // ❌ optional=false이므로 예외 발생
    .build();

roomRepository.save(room);  // 💥 JPA가 DB 쿼리 전에 예외 던짐
```

---

### 2. nullable=false (DB 레벨)

```java
@JoinColumn(nullable = false)
```

**특징**:
- **데이터베이스 스키마 레벨**에서 `NOT NULL` 제약 조건 생성
- JPA를 거치지 않은 직접 SQL 접근에도 `null` 방지
- DB 테이블 생성 시 `NOT NULL` 제약 조건 추가

**생성되는 DDL**:
```sql
CREATE TABLE study_room (
    id BIGINT PRIMARY KEY,
    title VARCHAR(255),
    host_id BIGINT NOT NULL,  -- nullable=false에 의해 생성
    FOREIGN KEY (host_id) REFERENCES users(id)
);
```

---

### 비교 정리

| 속성 | optional=false | nullable=false |
|------|----------------|----------------|
| 검증 레벨 | **JPA (애플리케이션)** | **데이터베이스** |
| 검증 시점 | 엔티티 저장 전 | SQL 실행 시 |
| 영향 범위 | JPA를 통한 접근만 | 모든 DB 접근 |
| 에러 발생 위치 | Java 코드 레벨 | DB 레벨 |

---

### 왜 둘 다 사용하는가?

```java
@ManyToOne(fetch = FetchType.LAZY, optional = false)  // JPA 레벨 검증
@JoinColumn(name = "host_id", nullable = false)       // DB 레벨 제약
private User host;
```

**이유**:
- `optional=false`: 애플리케이션에서 빠르게 에러 감지
- `nullable=false`: 데이터베이스 무결성 보장
- **이중 안전장치**로 더욱 견고한 데이터 관리

**실무 권장**:
- 필수 연관관계는 **둘 다 사용**하는 것이 베스트 프랙티스

---

## Spring Security - 인증 정보 가져오기

### @AuthenticationPrincipal

```java
@GetMapping("/profile")
public ResponseEntity<UserProfile> getProfile(
    @AuthenticationPrincipal UserDetails userDetails
) {
    // SecurityContext에 저장된 로그인 정보를 바로 사용
    String email = userDetails.getUsername();
    // ...
}
```

**동작 흐름**:
```
1. A가 로그인
    ↓
2. JWT 필터가 토큰 검증
    ↓
3. SecurityContext에 A의 인증 정보 저장
    ↓
4. 요청 시 @AuthenticationPrincipal로 정보 추출
```

**장점**:
- SecurityContext에서 자동으로 인증 정보를 꺼내옴
- 수동으로 토큰 파싱할 필요 없음
- 코드가 간결해짐

---

## Mock 데이터 (가짜 데이터)

### Mock 데이터란?

```javascript
// Mock 데이터 예시
const mockRooms = [
  {
    id: 1,
    title: "알고리즘 스터디",
    host: "홍길동",
    participants: 3,
    maxParticipants: 4
  },
  {
    id: 2,
    title: "리액트 공부방",
    host: "김철수",
    participants: 2,
    maxParticipants: 4
  }
];
```

**사용 목적**:
- 백엔드 API가 준비되기 전에 프론트엔드 개발 진행
- UI/UX 렌더링 테스트
- 데이터 구조 미리 설계

**사용 시나리오**:
1. 백엔드 개발 중 → 프론트는 Mock 데이터로 개발
2. API 완성 → Mock 데이터를 실제 API 호출로 교체
3. 테스트 → Mock 데이터로 다양한 시나리오 테스트

---

## React 성능 최적화

### 1. 조건부 렌더링 최적화

**바닐라 JS 방식 (비효율적)**:
```javascript
// DOM에는 존재하지만 CSS로 숨김
modal.style.display = 'none';
```

**React 방식 (효율적)**:
```jsx
const Modal = ({ open, children }) => {
  // 모달이 닫혀있으면 아예 렌더링하지 않음
  if (!open) return null;
  
  return createPortal(
    <div className="modal">{children}</div>,
    document.body
  );
};
```

**장점**:
- 컴포넌트가 DOM에 존재하지 않음 (메모리 절약)
- 불필요한 렌더링 없음 (성능 향상)
- Portal 사용 시 더욱 효과적

---

### 2. Zustand 선택적 구독 최적화

**비효율적인 방식 (전체 구독)**:
```jsx
// ❌ Store의 모든 상태를 구독
const { rooms, setRooms, addRoomToTop } = useRoomStore();
// rooms가 변경되지 않아도 setRooms, addRoomToTop 변경 시 리렌더링
```

**효율적인 방식 (선택적 구독)**:
```jsx
// ✅ 필요한 것만 선택적으로 구독
const rooms = useRoomStore((state) => state.rooms);
const setRooms = useRoomStore((state) => state.setRooms);
const addRoomToTop = useRoomStore((state) => state.addRoomToTop);
```

**성능 차이**:
```
전체 구독: 아무 값이나 변경되면 리렌더링
    ↓
선택적 구독: 구독한 값만 변경되면 리렌더링
    ↓
불필요한 리렌더링 감소 → 성능 향상
```

**실무 권장**:
- 항상 선택적 구독 사용
- 여러 값이 필요해도 각각 선택적으로 구독

---

## Axios HTTP 메서드

### GET, POST, PUT, PATCH

```javascript
// 기본 형식
axios.get('/api/rooms');
axios.post('/api/rooms', { title: "스터디룸" });
axios.put('/api/rooms/1', { title: "수정된 제목" });
axios.patch('/api/rooms/1', { title: "일부 수정" });
```

---

### DELETE (주의!)

**일반 메서드와 다른 형식**:
```javascript
// ❌ 잘못된 방식 (body가 전달되지 않음)
axios.delete(`/rooms/${roomId}`, { roomId });

// ✅ 올바른 방식 (data 속성 사용)
axios.delete(`/rooms/${roomId}/leave`, { 
  data: { roomId } 
});
```

**이유**:
- GET과 DELETE는 HTTP 명세상 body를 권장하지 않음
- Axios는 DELETE에 body를 보내려면 `data` 속성으로 감싸야 함

**비교**:
```javascript
// POST/PUT/PATCH: 두 번째 인자가 바로 body
axios.post(url, { key: value });

// DELETE: data 속성으로 감싸야 함
axios.delete(url, { data: { key: value } });
```

---

## 🎯 최종 정리

- **Private Route**는 컴포넌트 방식으로 구현하여 로딩 UI 제공 및 사용자 경험 개선
- **@Builder.Default vs @PrePersist**: 빌더는 객체 생성 시, PrePersist는 DB 저장 직전 실행 (PrePersist가 최종 우선권)
- **optional=false (JPA) + nullable=false (DB)** 조합으로 이중 안전장치 구축
- **@AuthenticationPrincipal**로 SecurityContext의 인증 정보를 간편하게 추출
- **React 최적화**: 조건부 렌더링으로 불필요한 DOM 제거, Zustand 선택적 구독으로 리렌더링 최소화
- **Axios DELETE**: 일반 메서드와 달리 `data` 속성으로 body 전달 필요
- 핵심 포인트: **성능 최적화, JPA 엔티티 설계, 보안 인증, API 호출 패턴 이해**
