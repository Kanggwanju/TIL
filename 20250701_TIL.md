# 🗓️ 2025년 7월 1일 TIL


생성자에서 초기화 해주지 않으면 필드에 자동적으로 기본값이 들어감
String에는 '', int에는 0 ...

상속

상속을 위해 공통 속성과 공통 기능을 가진 부모 클래스 (super class)
부모로부터 기능과 속성을 물려받는 자식 클래스 (sub class)

상속은 IS A 관계 -
사자는 동물이다.  학생은 인간이다. 소나타는 자동차다.
public class Warrior extends Player


상속은 실제로 물려주는 것이 아니라 부모 객체를 참조하는 것이며,
두개의 객체를 이용하는 것이다.

자식 클래스를 생성하면, 부모의 생성자가 호출되고 이후에
자식의 생성자가 호출된다.

Warrior warrior = new Warrior("주차왕파킹");
여기에서 warrior 변수는 Warrior 클래스를 가리키며
Warrior 클래스에는 rage 필드만 있을 뿐.
Warrior 클래스의 생성자 내부에는 super();가 생략되어 있음.
super에 부모 클래스(Player)의 주소를 갖고 있어서 포인터로 가리킴.


Warrior의 필드에는 nickName이 없으므로 this를 사용하면 안 되고,
super.nickName을 사용해야 하지만 this 사용을 허용해줌.


Player의 생성자가 파라미터를 필요로 할 경우
Warrior(자식 클래스)의 생성자 내부에서는 super()에 필요한
파라미터를 넣어줘야 한다.
결론 Player 생성자가 파라미터 없음
-> Warrior 내부의 super()의 파라미터 없어야 함.


오버라이딩
부모-자식 관계에서 일어남
오버라이딩: 부모가 물려준 메서드를 고쳐 쓰는 것

규칙:
1. 부모의 시그니처(이름, 리턴타입, 파라미터)와 동일해야 함
2. 접근제어자는 more public, 부모와 같거나 더 제한을 풀어야 함.

메서드 윗줄에 @Override를 작성하면 오버라이딩 룰을 위반했는지 체크해줌


오버로딩
메서드 오버로딩
: 하나의 클래스 안에서 이름이 같은 메서드를 여러 개 만드는 것
- 규칙
1. 파라미터의 타입이 다를 것!
2. 파라미터의 순서가 다를 것!
3. 파라미터의 개수가 다를 것!
4. 리턴타입이나 접근제어자는 아무 영향을 안준다.

상속의 치명적인 단점: 캡슐화를 깨뜨린다
부모의 모든 것이 노출되어 자식과 부모의 내부 구현이
깊숙이 의존하게 되며, 부모 클래스의 일부를 변경하면
자식 클래스에 문제가 생길 가능성이 높아진다.

컴포지션을 사용하는게 더 좋음
객체 내부에 객체를 만들어서 다시 타고 들어가면 
그 객체의 모든 것을 사용할 수 있음.

상속은 다중 상속이 불가능
WarMage 처럼 Warrior, Mage를 다중 상속할 수 없다.
상속을 아예 안 쓰면 자동적으로 Object를 상속하게 되어있다.
결론적으로 Object는 모든 클래스의 부모가 된다.
/*
         Object
            |
         Player
     /      |     \
  Warrior  Mage    Hunter
     |   \   |
Berserker  WarMage
*/



tip.
Child 클래스에서 
this("홍길동");은 Child(String name) 실행을 의미함.
this()가 실행되면 super()가 실행되지않음



protected
protected는 다른 패키지에서의 접근을 허용하지 않음
상속관계가 있다면 부분적으로 생성자 내부에서 접근을 허용함.
메서드에서 접근하는 것은 안 된다.




다형성
형제는 상속 관계가 아니다. (관련이 없다.)

다형성 : 객체가 다양한 형태(type)를 가질 수 있는 성질
- 자식 객체는 상속관계에 있는 타입을 사용할 수 있음


다른 타입의 데이터를 하나로 묶기 위해서 다형성을 사용한 경우
이종 모음 배열이라고 불림.
Car[] cars = {t1, t2, t3, s1, s2, m1, m2, m3};









