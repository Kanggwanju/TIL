# 🗓️ 2025년 6월 24일 TIL




자바스크립트에서는 두 요소가 같은지 판별할 때에
`===`을 사용했다. 하지만 자바에서는 안 통함

자바에서 사용하는 판별 방법 
`foods[i].equals(target)`
-> foods 배열의 i번째 요소가 target과 같은가?


배열 알고리즘 - 복사

얕은 복사
아래와 같이 주소만 복사하면 pets의 배열의 원소가 변경되면
petsCopy의 원소도 같이 변경된다.
`String[] pets = {"멍멍이", "야옹이", "짹짹이"};`
`String[] petsCopy = pets; // 주소 복사`

깊은 복사
반복문을 이용한 수동 복사
```java
public static void main(String[] args) {
    String[] pets = {"멍멍이", "야옹이", "짹짹이"};
    
    // 배열 객체 복사
    String[] petsCopy = new String[pets.length];
    // 배열 값 복사
    for (int i = 0; i < pets.length; i++) {
        petsCopy[i] = pets[i];
    }
}
```

Arrays 메서드를 이용한 배열 복사 
```java
public static void main(String[] args) {
    String[] pets = {"멍멍이", "야옹이", "짹짹이"};
    String[] petsCopy = Arrays.copyOf(pets, pets.length);
}
```


배열 알고리즘 - 맨 끝에 추가(push)
1. 기존 배열 사이즈보다 한 칸 더 큰 배열 생성
2. 원본배열의 값들을 새 배열로 복사
3. 마지막 인덱스에 새 값 저장
4. 주소값 이전
5. 임시 배열에 null 할당
```java
static int[] numbers = {10, 20, 30, 40};

public static void main(String[] args) {
    int newNumber = 50;
    
    int[] tempArray = new int[numbers.length + 1];
    
    for (int i = 0; i < numbers.length; i++) {
        tempArray[i] = numbers[i];
    }
    tempArray[tempArray.length - 1] = newNumber;
    
    numbers = tempArray;
    tempArray = null;
    // numbers: { 10, 20, 30, 40, 50 };
}
```


배열 알고리즘 - 맨 끝 제거(pop)
- pop: 맨 끝 데이터를 지우면서 가져옴
0. 지워질 데이터를 백업
1. 기존 사이즈보다 1개 작은 배열 생성
2. 새 배열의 맨 끝 데이터만 빼고 복사
3. 주소값 이전
```java
public static void main(String[] args) {
    int[] numbers = {10, 20, 30, 40, 50, 60};
    
    int delTarget = numbers[numbers.length - 1];
    
    int[] temp = new int[numbers.length - 1];
    
    for (int i = 0; i < temp.length; i++) {
        temp[i] = numbers[i];
    }

    numbers = temp;
    temp = null;

    System.out.println(Arrays.toString(numbers)); // [10,20,30,40,50]
    System.out.println("삭제된 데이터: " + delTarget); // 60
}
```

배열 알고리즘 - 선형(순차) 탐색
- 배열의 인덱스 탐색과 요소 유무 확인
- 선형탐색: 0번부터 일일히 순차적으로 체크
- 인덱스를 -1로 설정하여 for 문을 돌려서 타겟과 같은 i번째 요소를 찾으면
- 인덱스를 i로 바꿔줌, 아니라면 변화가 없음.
```java
public static void main(String[] args) {
    String[] foods = {"족발", "파스타", "치킨", "삼겹살"};
    
    String target = "파스타";
    
    int index = -1;
    for (int i = 0; i < foods.length; i++) {
        if (foods[i].equals(target)) {
            index = i;
            break;
        }
    }
    // 유무확인
    boolean isPresent = index != -1;

    System.out.println("타겟의 인덱스: " + index); // 1
    System.out.println("타겟의 유무: " + isPresent); // true

}
```

배열 알고리즘 - 원하는 위치 삭제(Delete)
1. 타겟 인덱스가 4라고 했을 때 for 문을 돌려서 4번째 요소에 5번째 요소를 넣음
다시 말하자면 4번째 요소의 뒤쪽에 있는 요소들을 복사하여 한칸씩 당겨온다고 생각하면 됨.
2. 맨 끝 제거(pop)
 - 원본 배열보다 길이가 1 짧은 임시 배열을 만들어서
 - 깊은 복사를 수행, 원본 배열에 임시 배열의 주소값을 이전함

```java
public static void main(String[] args) {

    int[] numbers = {1, 3, 5, 7, 9, 11};

    int targetIndex = 4;

    /*
        사이즈를 1개 줄이기 전에 해야 할 일
        [ 1, 3, 5, 7, 9, 11 ]
        [ 1, 5, 5, 7, 9, 11 ]
        [ 1, 5, 7, 7, 9, 11 ]
        [ 1, 5, 7, 9, 9, 11 ]
        [ 1, 5, 7, 9, 11, 11 ]
        [ 1, 5, 7, 9, 11 ]
        마지막 데이터 pop
     */
    for (int i = targetIndex; i < numbers.length - 1; i++) {
        numbers[i] = numbers[i + 1];
    }
//        numbers[1] = numbers[2];
//        numbers[2] = numbers[3];
//        numbers[3] = numbers[4];
//        numbers[4] = numbers[5];

    int[] temp = new int[numbers.length - 1];
    for (int i = 0; i < temp.length; i++) {
        temp[i] = numbers[i];
    }
    numbers = temp;


    System.out.println(Arrays.toString(numbers)); // [1, 3, 5, 7, 11]
}
```

배열 알고리즘 - 원하는 위치 삽입(Insert)
1. 사이즈가 1칸 큰 배열 생성
2. 기존 데이터 새 배열로 복사
3. 타겟 인덱스에서 한 칸씩 뒤로 밀어냄
4. 타겟 인덱스의 값을 주어진 값으로 할당함.
5. 주소값 이전
```java
public static void main(String[] args) {

    int[] numbers = {10, 50, 90, 100, 150};

    int targetIndex = 2;
    int newNumber = 70;

    /*
        먼저 사이즈가 1개 큰 새 배열부터 생성
        [ 10, 50, 90, 100, 150, 0 ]
        [ 10, 50, 90, 100, 150, 150 ]
        [ 10, 50, 90, 100, 100, 150 ]
        [ 10, 50, 90, 90, 100, 150 ]
        [ 10, 50, 70, 90, 100, 150 ]
    */

    // 1. 사이즈가 1칸 큰 배열 생성
    int[] temp = new int[numbers.length + 1];

    // 2. 기존 데이터 새 배열로 복사
    for (int i = 0; i < numbers.length; i++) {
        temp[i] = numbers[i];
    }

    for (int i = numbers.length; i > targetIndex; i--) {
        temp[i] = temp[i - 1];
    }
    /*
        temp[5] = temp[4];
        temp[4] = temp[3];
        temp[3] = temp[2];
    */

    temp[targetIndex] = newNumber;
    numbers = temp;


    System.out.println(Arrays.toString(numbers));

}
```




2차원 배열

```java
public static void main(String[] args) {
    int[][] matrix = {
        {10, 20, 30},
        {40, 50, 60},
        {70, 80, 90}
    };
}
```

2차원 배열 순회 방법 2가지
```java
public static void main(String[] args) {
    for (int[] arr : matrix) {
        for (int n : arr) {
            System.out.print(n + " ");
        }
        System.out.println();
    }
}
```

```java
public static void main(String[] args) {
    for (int i = 0; i < matrix.length; i++) {
        int[] arr = matrix[i];
        for (int j = 0; j < arr.length; j++) {
            System.out.print(arr[j] + " ");
        }
        System.out.println();
    }
}
```






