# 🗓️ 2025년 12월 1일 TIL - C언어

## 📌 오늘의 키워드

`큐(Queue)` `선입선출(FIFO)` `원형 큐(Circular Queue)`
`연결 리스트 큐(Linked Queue)` `enqueue()` `dequeue()`

---

## 1️⃣ 큐(Queue)의 개념

### 💡 정의

* **큐(Queue)** 는 **선입선출(FIFO, First In First Out)** 구조의 자료구조다.
  → 먼저 들어간 데이터가 먼저 나온다.
* 대표적인 예시는 **은행 창구 번호표**, **프린터 작업 대기열** 등이 있다.

### 📘 주요 용도

* 프로세스 스케줄링
* 버퍼 관리
* 네트워크 데이터 패킷 처리

---

## 2️⃣ 원형 큐(Circular Queue)

### 💡 개념

일반적인 큐는 `rear`가 배열 끝에 도달하면, 앞쪽 공간이 비어 있어도 사용하지 못한다.
이를 해결하기 위해 **원형 구조로 배열을 연결한 큐**를 사용한다.

즉, **front와 rear를 모듈러 연산(%)으로 순환시키는 구조**다.

---

### 💻 구조체 정의

```c
#define MAX_QUEUE_SIZE 5

typedef struct {
    int data[MAX_QUEUE_SIZE];
    int front, rear;
} CircularQueue;
```

| 항목       | 설명                 |
| -------- | ------------------ |
| `front`  | 큐의 첫 번째 원소 바로 앞 위치 |
| `rear`   | 큐의 마지막 원소 위치       |
| `data[]` | 데이터를 저장할 배열        |

---

### ⚙️ 주요 함수 요약

#### ① 초기화

```c
void init_queue(CircularQueue* q) {
    q->front = 0;
    q->rear = 0;
}
```

#### ② 공백 / 포화 확인

```c
int is_empty(CircularQueue* q) {
    return q->front == q->rear;
}

int is_full(CircularQueue* q) {
    return (q->rear + 1) % MAX_QUEUE_SIZE == q->front;
}
```

#### ③ 삽입 (enqueue)

```c
void enqueue(CircularQueue* q, int item) {
    if (is_full(q)) {
        printf("큐가 꽉찼습니다!\n");
        return;
    }
    q->rear = (q->rear + 1) % MAX_QUEUE_SIZE;
    q->data[q->rear] = item;
}
```

* **rear 이동 → 데이터 삽입**
* 첫 칸은 포화 판별을 위해 **비워둔다**.

#### ④ 삭제 (dequeue)

```c
int dequeue(CircularQueue* q) {
    if (is_empty(q)) {
        printf("큐가 비었습니다!");
        exit(1);
    }
    q->front = (q->front + 1) % MAX_QUEUE_SIZE;
    return q->data[q->front];
}
```

* **front 이동 → 해당 위치 데이터 반환**

#### ⑤ 출력

```c
void print_queue(CircularQueue* q) {
    if (is_empty(q)) {
        printf("Queue [ ]\n");
        return;
    }
    printf("Queue: [ ");
    int i = q->front;
    while (i != q->rear) {
        i = (i + 1) % MAX_QUEUE_SIZE;
        printf("%d ", q->data[i]);
    }
    printf("]\n");
}
```

---

### ✅ 원형 큐 특징

| 항목     | 설명                           |
| ------ | ---------------------------- |
| 접근 방식  | FIFO                         |
| 시간 복잡도 | `enqueue`, `dequeue` 모두 O(1) |
| 장점     | 메모리 낭비 없음, 효율적 공간 활용         |
| 단점     | 크기 고정, 포화 판별이 까다로움           |
| 적합한 경우 | 최대 크기를 예측할 수 있는 상황           |

---

## 3️⃣ 연결 리스트 큐 (Linked Queue)

### 💡 개념

배열 대신 **연결 리스트(Node 구조체)** 를 이용해 큐를 구현한 방식이다.
메모리를 동적으로 할당하므로 **크기 제한이 없고, 구현이 직관적**이다.

---

### 💻 구조체 정의

```c
typedef struct Node {
    int data;
    struct Node* next;
} Node;

typedef struct {
    Node* front; // head
    Node* rear;  // tail
} LinkedQueue;
```

| 항목      | 설명             |
| ------- | -------------- |
| `front` | 큐의 첫 번째 노드     |
| `rear`  | 큐의 마지막 노드      |
| `Node`  | 데이터 + 다음 노드 주소 |

---

### ⚙️ 주요 함수 요약

#### ① 초기화

```c
void init_queue(LinkedQueue* q) {
    q->front = NULL;
    q->rear = NULL;
}
```

#### ② 비어 있는지 확인

```c
int is_empty(LinkedQueue* q) {
    return q->front == NULL && q->rear == NULL;
}
```

#### ③ 삽입 (enqueue)

```c
void enqueue(LinkedQueue* q, int item) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = item;
    newNode->next = NULL;

    if (is_empty(q)) {
        q->front = newNode;
        q->rear = newNode;
    } else {
        q->rear->next = newNode;
        q->rear = newNode;
    }
}
```

#### ④ 삭제 (dequeue)

```c
int dequeue(LinkedQueue* q) {
    if (is_empty(q)) {
        printf("큐가 비어있습니다.\n");
        exit(1);
    }

    Node* temp = q->front;
    int removed = temp->data;

    q->front = q->front->next;
    if (q->front == NULL) q->rear = NULL;

    free(temp);
    return removed;
}
```

---

### ✅ 연결 리스트 큐 특징

| 항목     | 설명                           |
| ------ | ---------------------------- |
| 접근 방식  | FIFO                         |
| 시간 복잡도 | `enqueue`, `dequeue` 모두 O(1) |
| 장점     | 크기 제한 없음, 구현 직관적             |
| 단점     | malloc/free 오버헤드 존재          |
| 적합한 경우 | 데이터 개수를 예측할 수 없는 상황          |

---

## 🎯 최종 비교

| 구분     | 원형 큐              | 연결 리스트 큐        |
| ------ | ----------------- | --------------- |
| 저장 공간  | 배열 (고정 크기)        | 동적 할당 (가변 크기)   |
| 메모리 효율 | 높음                | 낮음              |
| 구현 난이도 | 약간 복잡 (모듈러 연산 필요) | 직관적             |
| 크기 제한  | 있음                | 없음              |
| 속도     | 빠름                | 약간 느림           |
| 사용 예   | 한정된 버퍼, 고정된 작업 큐  | 네트워크 패킷, 비동기 처리 |

---

## 💬 오늘의 소감

오늘은 **큐(Queue)** 의 두 가지 구현 방식을 비교하며 학습했다.
배열 기반 원형 큐는 **메모리를 효율적으로 사용**하지만 크기 한계가 있었고,
연결 리스트 큐는 **메모리 낭비는 있지만 유연한 구조**였다.
특히 원형 큐에서 `front`와 `rear`를 모듈러 연산으로 순환시키는 아이디어가 흥미로웠다.
