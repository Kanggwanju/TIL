# 🗓️ 2025년 8월 29일 TIL

## 🗝️ 오늘의 키워드

* React Router
* SPA (Single Page Application)
* createBrowserRouter
* Link & NavLink
* errorElement & useRouteError
* URL 파라미터 (`useParams`)
* 검색 쿼리 (`useSearchParams`)
* 중첩 라우팅 (Nested Routes)

---

## React Router
- 단일 페이지 애플리케이션(SPA)
- 실제로 페이지를 새로 받아오지 않음
- 마치 페이지가 바뀌는 것처럼 보여줌
- 덕분에 웹사이트가 더 빠르고 부드럽게 동작

---

## 새로운 리액트 프로젝트 생성

## 명령 프롬프트
1. nodejs 설치
2. `npm create vite@latest 프로젝트폴더명`
    - proceed(y) -> React -> Javascript 선택
3. `cd 프로젝트폴더명` -> `npm install` -> `npm run dev`

## 인텔리제이 `유료`
- 새 프로젝트
- 제너레이터 Vite 선택
- 이름: react-router202508
- 템플릿: react

## 깃허브에서 클론한 리액트 프로젝트인 경우
1. `git clone`
2. `npm intall` <- 최초 1번
3. `npm run dev` <- 프론트엔드 서버 실행 (서버켤 때마다 실행)

- 서버 끌때는 터미널에서 Ctrl + C, Ctrl + Z

## React Router
```shell
npm install react-router-dom
```

## scss
```shell
npm install sass
```

---

## 라우터 만드는 방법

### 1. 페이지 컴포넌트 생성
```jsx
// Home.jsx
function Home() {
  return <h1>환영합니다!</h1>
}

// About.jsx
function About() {
  return <h1>회사 소개입니다</h1>
}
```

### 2. 라우터 설정
```jsx
// router-config.jsx
export const router = createBrowserRouter([
  {
    path: '/',
    element: <Home />
  },
  {
    path: '/about',
    element: <About />
  }
]);
```

### 3. 라우터를 적용
```jsx
// App.jsx
const App = () => {
  return <RouterProvider router={router} />
};
```

### 4. 페이지 이동
- 일반 HTML에서는 `<a>` 태그를 사용
- React Router에서는 `<Link>` 사용
- 새로고침이 발생하지 않음

```jsx
const MainNav = () => {
  return (
    <nav className={nav}>
      <Link to="/">Home</Link>
      <Link to="/blog">Blog</Link>
      <Link to="/about">About</Link>
    </nav>
  );
};
```

---

## createBrowserRouter
- 웹사이트의 각 주소가 어떤 내용을 보여줄지 미리 정함

### 기본 구조
```jsx
const router = createBrowserRouter([
  {
    path: '/',
    element: <RootLayout />,
    errorElement: <ErrorPage />,
    children: [
      {
        // path: '',
        index: true,
        element: <IndexPage />
      },
      {
        path: 'blog',
        element: <BlogPage />
      }
    ]
  },
]);
```
- path: 주소
- element: 보여줄 내용
- errorElement: custom error page 설정
- children: Layout의 Outlet 부분을 뭘로 바꿀지를 설정
---

## 레이아웃
- 공통 요소를 한 번만 작성
- Outlet에는 `children`에서 정의된 각 페이지마다 다른 부분이 들어감
- 라우터에 여러 개의 레이아웃을 층별 구조로 겹쳐서 사용 가능

### 레이아웃 기본 구조
```jsx
// RootLayout.jsx
function RootLayout() {
  return (
    <div>
      <header>
        <nav>{/* 네비게이션 메뉴 */}</nav>
      </header>

      <main>
        {/* 실제로 바뀌는 동적인 부분 */}
        <Outlet />
      </main>

      <footer>
        {/* 푸터 내용 */}
      </footer>
    </div>
  );
}
```

---

## NavLink
- `Link`의 특별한 버전. 네비게이션 메뉴를 만들 때 주로 사용
- 현재 URL과 NavLink의 `to`가 매칭되는지 여부를 자동으로 판단
- `className`/`style` prop에 함수를 넘기면, 거기다 객체를 파라미터로 넣어줌
- 그 객체에는 `isActive`, `isPending`이 boolean 타입으로 있음

예시)
```jsx
<NavLink to="/" className={activate}>Home</NavLink>
<NavLink to="/blog" className={activate}>Blog</NavLink>
<NavLink to="/about" className={activate}>About</NavLink>
```

### isActive
- 현재 URL이 함수를 호출한 NavLink의 to와 매칭되면 true
- 스타일, 클래스를 동적으로 적용 가능
```jsx
const activate = ({ isActive }) => {
  return `${navLink} ${isActive ? active : ''}`;
};
```

---

## 에러 페이지 처리 (errorElement)
- 라우터에서 에러가 발생했을 때 보여줄 페이지를 지정하는 속성
- 층별 구조의 레이아웃일 떄는 가장 가까운 errorElement를 찾아 올라감

예시) 라우터 errorElement 속성
```jsx
// custom error page 설정
errorElement: <ErrorPage />
```
- 잘못된 URL 접근이나 에러를 throw 했을 경우
- 설정된 error page로 이동함.

예시) 에러 throw
```jsx
throw new Error('알 수 없는 에러가 발생했습니다.');
throw new Response("Not Found", { status: 404 });
```

### 에러 정보 활용 (useRouteError())
- 에러가 발생하여 미리 지정된 페이지로 이동했을때,
- useRouteError를 통해 어떤 에러가 발생했는지 확인 가능

```jsx
import { useRouteError } from 'react-router-dom';

function ErrorPage() {
  const error = useRouteError();  

  return (
    <div>
      <h1>앗! 문제가 발생했어요</h1>
      <p>
        {
          error.status === 404
            ? '페이지를 찾을 수 없습니다.'
            : error.message
        }
      </p>
      <Link to="/">홈으로 돌아가기</Link>
    </div>
  );
}
```

---
## 동적 라우팅

### URL 파라미터
- 하나의 제품 상세 페이지에 ID만 바꿔가며 다른 내용 보여줌
- `/posts`: 전체 게시글 목록
- `/posts/123`: 123번 게시글

---

### URL 파라미터 설정 방법
```jsx
const router = createBrowserRouter([
  {
    path: '/',
    element: <RootLayout />,
    children: [
      { path: '/', element: <HomePage /> },
      { path: '/blog', element: <BlogList /> },
      // URL 파라미터 설정
      { path: '/blog/:postId', element: <BlogPost /> }
    ]
  }
]);
```
`:postId`가 URL 파라미터
- `:` 기호로 시작하는 부분이 파라미터

---

### 페이지 이동 예시
```jsx
const PostCard = ({ post }) => {
  return (
    <Link
      to={`/blog/${post.id}`}
      className={styles.cardLink}>
      <div className={styles.card}>
        {/* 내용... */}
      </div>
    </Link>
  );
};
```
- 게시물 목록에서 카드 형태의 게시물을 클릭하면,
- `/blog/${post.id}`로 이동하게끔 Link 컴포넌트 사용

---

### URL 파라미터 읽기 (useParams)
```jsx
const BlogPostDetailPage = () => {

  // 현재 라우팅된 postId를 url로부터 읽어내는 법
  const {postId} = useParams();
  
  // 해당 ID로 서버에 상세조회 요청
  // 지금은 서버 x, 더미데이터에서 특정 블로그 글 탐색
  const foundPost = posts.find(post => post.id === +postId);
  
  return (
    <article>
      {/*...*/}
    </article>
  );
};
```
- `useParams()` 훅을 쓰면, 라우트 path에서 `:파라미터명` 부분이 키가 되어 객체로 반환
- 값은 항상 문자열 → 숫자 비교 시엔 +postId처럼 변환 필요
- 없는 게시글일 경우엔 에러 throw를 통해 에러 페이지로 보낼 수 있음

---

## 검색 쿼리 다루기 (`useSearchParams`)
- ? 뒤에 붙는 쿼리스트링 읽는법
- useSearchParams는 배열을 리턴하는데
- 0번 인덱스: 쿼리스트링들을 모아놓은 객체
- 1번 인덱스: 쿼리스트링을 생성할 수 있는 함수를 리턴

### 기본 사용법
```jsx
function ProductList() {
  const [searchParams, setSearchParams] = useSearchParams();

  // 쿼리 파라미터 읽기
  const category = searchParams.get('category');
  const minPrice = searchParams.get('minPrice');
}
```

### 주요 메서드
#### 1. 값 가져오기
```jsx
// 단일 값 가져오기
searchParams.get('category') || 'all';  // 'react'

// 여러 값 가져오기 (체크박스 등)
searchParams.getAll('colors');  // ['red', 'blue']

// 존재 여부 확인
searchParams.has('category');  // true/false
```
- `get`은 값이 들어오지 않으면 null이 들어옴, 기본값 설정 권장

---

#### 2. 값 설정하기
옵션 선택 태그
```jsx
<select
  onChange={handleCategoryChange}
  value={searchParams.get('category') || 'all'}
>
  {/* option들 ... */}
</select>
```
- value를 searchParams에서 꺼낸 값을 가져와서 새로고침해도
- 선택된 option과 ? 뒤에 붙는 쿼리스트링이 동일하도록 설정

카테고리 옵션 선택 이벤트
```jsx
const handleCategoryChange = e => {
  // 쿼리스트링으로 ?category=xxx
  setSearchParams(prev => {
    prev.set('category', e.target.value);
    return prev;
  });
};
```
- 기존 쿼리(오래된 순서 정렬)에 category를 추가

---

## 중첩 라우팅 심화
- 하나의 페이지 안에 여러 하위 페이지를 구성하는 방식

### 중첩 라우팅의 구조
1\. 기본 구조
```jsx
const router = createBrowserRouter([
  {
    path: '/',
    element: <RootLayout />,
    children: [
      {
        path: 'products',
        element: <ProductsLayout />,
        children: [
          { index: true, element: <ProductsList /> },
          { path: ':id', element: <ProductDetail /> }
        ]
      }
    ]
  }
]);
```

2\. 레이아웃 컴포넌트
```jsx
function ProductsLayout() {
  return (
    <div>
      <nav>상품 카테고리 메뉴</nav>
      <Outlet /> {/* 하위 라우트가 여기에 렌더링됨 */}
    </div>
  );
}
```

---

## 📌 오늘의 요약

* **SPA 네비게이션**: React Router로 새로고침 없는 화면 전환 구현
* **라우트 정의**: `createBrowserRouter`로 경로와 컴포넌트 매핑
* **링크 컴포넌트**: `<Link>`, `<NavLink>`로 사용자 이동 제어
* **에러 처리**: `errorElement` + `useRouteError`로 공통 에러 페이지 제공
* **동적 라우팅**: `:postId` 같은 파라미터를 `useParams`로 읽어오기
* **검색/필터링**: `useSearchParams`로 쿼리스트링 다루기
* **중첩 라우팅**: 공통 레이아웃과 하위 페이지를 계층적으로 구성

