# 🗓️ 2025년 9월 15일 TIL

## 📌 오늘의 키워드
`WebSocket` `STOMP` `실시간 통신` `양방향 통신` `TCP` `메시지 브로커` `구독/발행` `핸드셰이크` `JWT 인증` `SockJS` `브로드캐스트`

---

## HTTP vs WebSocket (TCP)

### HTTP (REST API)의 특징

```
클라이언트 → 요청 → 서버
클라이언트 ← 응답 ← 서버
    (연결 종료)
```

**특징**:
- **비연결성(Connectionless)**: 요청-응답 후 연결을 끊음
- **무상태성(Stateless)**: 이전 통신 내용을 기억하지 않음
- **1:1 통신**: 하나의 요청에 하나의 응답

**적합한 사용 사례**:
- 게시글 목록 조회
- 데이터 CRUD
- 일반적인 웹 페이지 요청

---

### WebSocket (TCP)의 특징

```
클라이언트 ─────── 연결 유지 ─────── 서버
    ↕                              ↕
양방향 실시간 통신 (서버도 먼저 메시지 전송 가능)
```

**특징**:
- **연결성(Connection-oriented)**: 한 번 연결하면 계속 유지
- **양방향 통신(Full-duplex)**: 클라이언트와 서버 모두 먼저 메시지 전송 가능
- **신뢰성**: 3-way handshake로 연결 보장
- **실시간성**: 즉각적인 데이터 전송

**적합한 사용 사례**:
- 실시간 채팅
- 알림 시스템
- 실시간 게임
- 주식 시세 갱신
- 실시간 퀴즈 (SignBell의 경우)

---

## WebSocket 설정 (Spring Boot)

### 1. 의존성 추가

```groovy
// build.gradle
// WebSocket 기본 기능
implementation 'org.springframework.boot:spring-boot-starter-websocket'

// WebSocket 보안 기능 (simpDestMatchers 등)
implementation 'org.springframework.security:spring-security-messaging'
```

---

### 2. STOMP란?

**STOMP (Simple Text Oriented Messaging Protocol)**:
- WebSocket 위에서 동작하는 **메시지 프로토콜**
- "메시지를 어떻게 주고받을지" 정한 간단한 규칙
- pub/sub(발행/구독) 패턴을 쉽게 구현 가능

**비유**:
- **WebSocket**: 전화선 (연결 자체)
- **STOMP**: 전화 통화 규칙 (누가 말하고, 어떻게 전달하는지)

---

### 3. WebSocket 설정 클래스

```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    
    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        // 메시지 브로커 활성화
        // "/topic"으로 시작하는 주소는 브로드캐스트용
        registry.enableSimpleBroker("/topic");
        
        // "/app"으로 시작하는 메시지는 컨트롤러로 전달
        registry.setApplicationDestinationPrefixes("/app");
    }
    
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        // WebSocket 연결 엔드포인트 등록
        registry.addEndpoint("/ws")
                .setAllowedOrigins("http://localhost:3000")
                .withSockJS();  // WebSocket을 지원하지 않는 브라우저 대비
    }
}
```

**설정 설명**:
1. **연결 엔드포인트**: `/ws` → 브라우저가 서버와 WebSocket 연결을 맺는 주소
2. **메시지 주소 체계**:
    - `/topic/*`: 구독용 주소 (브로드캐스트)
    - `/app/*`: 메시지 전송용 주소 (컨트롤러)
3. **SockJS**: WebSocket을 지원하지 않는 브라우저를 위한 폴백 옵션

---

## STOMP 핵심 개념

### 주요 용어 정리

| 용어 | 설명 | 비유 |
|------|------|------|
| **구독(Subscribe)** | 특정 주소의 메시지를 받겠다고 신청 | 유튜브 채널 구독 |
| **전송(Send)** | 특정 주소로 메시지를 보냄 | 사연 보내기 |
| **토픽(Topic)** | 메시지를 받을 주소 (채팅방 같은 개념) | 채팅방 주소 |
| **브로드캐스트(Broadcast)** | 같은 토픽을 구독한 모두에게 메시지 전송 | 단체 메시지 |
| **메시지 브로커(Broker)** | 메시지를 받아서 구독자들에게 전달하는 중개자 | 우체부 |

---

### 주소 체계

```
구독 주소: /topic/rooms/{roomId}
    → 특정 방의 메시지를 받기 위한 주소
    
전송 주소: /app/rooms/{roomId}/chat
    → 특정 방으로 메시지를 보내기 위한 주소
```

**예시**:
```
/topic/rooms/1  → 방 1번의 메시지를 받는 주소
/app/rooms/1/chat  → 방 1번으로 메시지를 보내는 주소
```

---

## WebSocket 통신 흐름

### 채팅방 예시 (방 ID: 1)

```
┌─────────────────────────────────────────────────────────┐
│  1단계: 연결 (Handshake)                                │
│  브라우저 → "/ws" → 서버                                │
│  (전화선 연결)                                          │
└─────────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────┐
│  2단계: 구독 (Subscribe)                                │
│  브라우저 → "/topic/rooms/1" 구독 신청                  │
│  (방 1번의 소식 받기 신청)                              │
└─────────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────┐
│  3단계: 메시지 전송 (Send)                              │
│  브라우저 → "/app/rooms/1/chat" → 서버                  │
│  메시지: "안녕하세요!"                                   │
└─────────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────┐
│  4단계: 브로드캐스트 (Broadcast)                        │
│  서버 → "/topic/rooms/1" → 모든 구독자                  │
│  (방 1번을 구독한 모두에게 메시지 전달)                 │
└─────────────────────────────────────────────────────────┘
```

---

### 상세 흐름 설명

```javascript
// 1. WebSocket 연결
const socket = new SockJS('http://localhost:9005/ws');
const stompClient = new Client({ webSocketFactory: () => socket });

// 2. 연결 성공 후
stompClient.onConnect = () => {
    // 3. 토픽 구독 (메시지 받기 준비)
    stompClient.subscribe('/topic/rooms/1', (message) => {
        console.log('받은 메시지:', message.body);
    });
    
    // 4. 메시지 전송
    stompClient.publish({
        destination: '/app/rooms/1/chat',
        body: JSON.stringify({ content: '안녕하세요!' })
    });
};
```

---

## 구독과 전송의 관계

### 중요한 개념 정리

**구독은 전송의 전제조건이 아닙니다!**

```
구독 없이도 전송 가능 ✅
    ↓
하지만 내가 보낸 메시지를 받으려면 구독 필요 ✅
```

---

### 시나리오 예시

#### 케이스 1: 구독 O, 전송 O
```
브라우저: "/topic/rooms/1" 구독 ✅
브라우저: "/app/rooms/1/chat" 메시지 전송 ✅
서버: "/topic/rooms/1"로 브로드캐스트 ✅
브라우저: 메시지 수신 ✅
```
**결과**: 정상 작동 ✅

---

#### 케이스 2: 구독 X, 전송 O
```
브라우저: 구독 없음 ❌
브라우저: "/app/rooms/1/chat" 메시지 전송 ✅
서버: "/topic/rooms/1"로 브로드캐스트 ✅
브라우저: 메시지 수신 불가 ❌
```
**결과**:
- 메시지 전송은 성공
- 하지만 내가 보낸 메시지를 받을 수 없음 (브로드캐스트 수신 불가)

---

### 정리

| 동작 | 구독 여부 | 전송 가능? | 수신 가능? |
|------|-----------|------------|------------|
| 전송 | 필요 없음 | ✅ 가능 | ❌ 불가 |
| 수신 | 필수 | - | ✅ 가능 |

**결론**:
- **전송**은 구독 없이도 가능
- **브로드캐스트 수신**은 구독이 필수

---

## WebSocket 보안 설정

### 1. 보안 의존성 추가

```groovy
// WebSocket 메시지 보안 DSL (simpDestMatchers 등)
implementation 'org.springframework.security:spring-security-messaging'
```

---

### 2. CookieAuthHandshakeInterceptor

**역할**: WebSocket 연결 시 JWT 쿠키로 사용자 인증

```java
@Component
public class CookieAuthHandshakeInterceptor implements HandshakeInterceptor {
    
    @Override
    public boolean beforeHandshake(
        ServerHttpRequest request, 
        ServerHttpResponse response,
        WebSocketHandler wsHandler, 
        Map<String, Object> attributes
    ) throws Exception {
        
        // HTTP 요청에서 쿠키 추출
        HttpServletRequest servletRequest = 
            ((ServletServerHttpRequest) request).getServletRequest();
        
        Cookie[] cookies = servletRequest.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if ("ACCESS_TOKEN".equals(cookie.getName())) {
                    // JWT 토큰 검증
                    String token = cookie.getValue();
                    // 검증 로직...
                    
                    // 인증 정보를 WebSocket 세션에 저장
                    attributes.put("user", authenticatedUser);
                    return true;
                }
            }
        }
        
        return false;  // 인증 실패 시 연결 거부
    }
    
    @Override
    public void afterHandshake(...) {
        // 핸드셰이크 완료 후 처리
    }
}
```

---

### 동작 흐름

```
1. 브라우저가 /ws로 WebSocket 연결 요청
    ↓ (HTTP 요청에 쿠키 포함)
2. CookieAuthHandshakeInterceptor가 쿠키에서 JWT 추출
    ↓
3. JWT 검증 (유효성, 만료 확인)
    ↓
4. 검증 성공 → 사용자 정보를 WebSocket 세션에 저장
    ↓
5. WebSocket 연결 완료
    ↓
6. 이후 STOMP 메시지에서 "누가 보냈는지" 식별 가능
```

---

### 핸드셰이크(Handshake)란?

```
HTTP 프로토콜 (일반 웹 요청)
        ↓
    핸드셰이크 (프로토콜 업그레이드)
        ↓
WebSocket 프로토콜 (양방향 실시간 통신)
```

**핸드셰이크 과정**:
1. 클라이언트가 HTTP 요청으로 연결 시도
2. 서버가 HTTP 101 응답 (Switching Protocols)
3. HTTP → WebSocket으로 프로토콜 전환
4. **이 순간에 브라우저는 쿠키를 함께 전송**

**중요**: 핸드셰이크 시점에 인증하면, 이후 모든 메시지에서 사용자 식별 가능

---

### 3. WebSocket 전용 SecurityConfig

**일반 HTTP와 WebSocket은 보안 설정이 달라야 함**

```java
@Configuration
@EnableWebSocketSecurity
public class WebSocketSecurityConfig {
    
    @Bean
    public AuthorizationManager<Message<?>> messageAuthorizationManager(
        MessageMatcherDelegatingAuthorizationManager.Builder messages
    ) {
        messages
            .simpDestMatchers("/app/**").authenticated()  // 전송은 인증 필요
            .simpSubscribeDestMatchers("/topic/**").authenticated()  // 구독도 인증 필요
            .anyMessage().denyAll();  // 나머지는 차단
        
        return messages.build();
    }
}
```

**설정 설명**:
- `/app/**`: 메시지 전송 시 인증 필요
- `/topic/**`: 토픽 구독 시 인증 필요
- 나머지: 모두 차단

---

## React에서 WebSocket 사용

### 1. STOMP 라이브러리 설치

```json
// package.json
"dependencies": {
  "@stomp/stompjs": "^7.1.1",
  "sockjs-client": "^1.6.1"
}
```

```bash
npm install @stomp/stompjs sockjs-client
```

---

### 2. WebSocket 연결 예시

```javascript
import { Client } from '@stomp/stompjs';
import SockJS from 'sockjs-client';

// WebSocket 연결 함수
const connectWebSocket = (roomId) => {
  // SockJS로 WebSocket 연결
  const socket = new SockJS('http://localhost:9005/ws');
  
  // STOMP 클라이언트 생성
  const stompClient = new Client({
    webSocketFactory: () => socket,
    reconnectDelay: 5000,  // 재연결 딜레이
    
    onConnect: () => {
      console.log('WebSocket 연결 성공');
      
      // 토픽 구독
      stompClient.subscribe(`/topic/rooms/${roomId}`, (message) => {
        const data = JSON.parse(message.body);
        console.log('받은 메시지:', data);
      });
    },
    
    onDisconnect: () => {
      console.log('WebSocket 연결 종료');
    },
    
    onStompError: (frame) => {
      console.error('STOMP 에러:', frame);
    }
  });
  
  // 연결 시작
  stompClient.activate();
  
  return stompClient;
};

// 메시지 전송
const sendMessage = (stompClient, roomId, content) => {
  stompClient.publish({
    destination: `/app/rooms/${roomId}/chat`,
    body: JSON.stringify({ content })
  });
};
```

---

## 🎯 최종 정리

- **WebSocket은 실시간 양방향 통신**을 위한 프로토콜 (HTTP는 단방향 요청-응답)
- **STOMP는 WebSocket 위에서 동작**하는 메시지 프로토콜 (pub/sub 패턴)
- **핵심 흐름**: 연결(/ws) → 구독(/topic/*) → 전송(/app/*) → 브로드캐스트
- **구독 없이 전송 가능**하지만, 브로드캐스트 수신은 구독 필수
- **핸드셰이크 시 JWT 인증**: 쿠키에서 토큰 추출하여 WebSocket 세션에 사용자 정보 저장
- **WebSocket 전용 SecurityConfig**: HTTP와 별도로 메시지 보안 설정 필요
- **SockJS 폴백**: WebSocket 미지원 브라우저 대비
- 핵심 포인트: **실시간 통신 이해, STOMP 주소 체계, 인증 흐름, pub/sub 패턴**
