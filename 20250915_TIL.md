# 🗓️ 2025년 9월 15일 TIL

웹소켓

HTTP vs TCP

HTTP (REST)
- request와 response가 1:1
- 비연결성, 한번 요청하고 한번 연결하면 통신을 끊음
- 무상태성, 통신했던 내용을 기억하지 않음
- 게시글 목록 요청

TCP (WebSocket)
- 연결성, 클라이언트가 서버에 TCP 요청을 걸면 연결이 유지됨
- 3-way handshake를 통한 신뢰성
- 채팅


WebSocket 종속성 추가

```groovy
// WebSocket
implementation 'org.springframework.boot:spring-boot-starter-websocket'
```


WebSocket 및 STOMP 설정 클래스 추가
- WebSocket은 "전화 연결"처럼 한 번 연결하면 계속 유지됩니다. 서버도 먼저 말할 수 있어요.
- STOMP는 "메시지를 어떻게 주고받을지" 정한 간단한 규칙(프로토콜)입니다.

WebSocketConfig가 해주는 일
1) 브라우저가 WebSocket을 시작할 문(주소)을 만듭니다: "/ws"
2) 메시지를 나눠 받을 "주소 체계"를 만듭니다
3) 어떤 PC/브라우저는 WebSocket이 막혀 있을 수 있어서, 자동으로 다른 방식(SockJS)으로도 통신하게 합니다.

단어 정리
구독(subscribe): "이 주소의 알림을 받겠습니다"라고 신청하는 것 (예: 뉴스레터 구독)
전송(send): "이 주소로 메시지를 보냅니다"라고 보내는 것 (예: 사연 보내기)
토픽(topic): "채팅방 주소" 같은 것 (같은 방을 구독한 모두가 같은 소식을 받음)
브로드캐스트(broadcast): "같은 방 모두에게 뿌리기"
메시지 브로커(broker): "알림 배달부". 누가 어떤 주소를 구독했는지 보고, 알맞게 전달합니다.


한 눈에 보는 웹소켓 흐름 예시(채팅방 1):
- 브라우저: "/ws"로 서버와 연결을 맺음(전화 연결)
- 브라우저: "/topic/rooms/1"을 구독(방 1 소식 받기 신청)
- 브라우저: "/app/rooms/1/chat"으로 메시지 전송(내 말 보내기)
- 서버: 받은 메시지를 "/topic/rooms/1" 주소로 브로드캐스트(방 1 모두에게 전달)


리액트의 package.json에 stomp 종속성 추가
```json
"dependencies": {
  "@stomp/stompjs": "^7.1.1",
  ...
}
```

---

데이터 전송의 전제조건이 구독이 아님.
구독은 브로드캐스트의 전제조건

예를들어 소켓은 연결되어있고, 구독은 안 되어있을때
데이터를 전송 가능, 서버가 받은 데이터를 다시 받을 수 없다. (브로드캐스트 불가)

---

WebSocket 메시지 보안 DSL 종속성 추가 (simpDestMatchers 등)
```groovy
implementation 'org.springframework.security:spring-security-messaging'
```

---

CookieAuthHandshakeInterceptor
- WebSocket 핸드셰이크 시 쿠키(JWT)로 사용자 인증을 시도하는 인터셉터.

- HTTP → WebSocket으로 "연결을 바꾸는 순간(핸드셰이크)"에, 브라우저는 쿠키를 함께 보냅니다.
- 우리는 그 쿠키에서 Access Token(JWT)을 꺼내 검증하고, 사용자를 식별해 둡니다.
- 이렇게 하면 STOMP 메시지를 보낼 때도 "누가 보냈는지"를 알 수 있습니다.


웹소켓 전용 SecurityConfig를 따로 만들어야함




