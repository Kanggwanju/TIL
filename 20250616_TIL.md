# 🗓️ 2025년 6월 16일 TIL

오늘은 자바스크립트의 closure, lexical-scope, debounce, throttle을 배움.

1. closure
- 일급 함수: 함수를 값으로 처리, 자바스크립트에서는 함수가 함수를 리턴하는 것이 가능
```js
function foo() {
  return 100;
}

function bar() {
  return foo;
}

const result = bar();
console.log(typeof result); // 함수
console.log(result);        // foo

const r1 = result(); // foo();
console.log(`r1: ${r1}`); // 100
```

```js
function calculate() {
  // 중첩함수, 헬퍼함수
  function add(n1, n2) {
    return n1 + n2;
  }
  return add;
}

// 중첩함수, 헬퍼함수를 calculate 외부에서
// 호출하는 것은 불가능
// add(10, 20); => 에러!
const result2 = calculate(); // add()
console.log(`result2: `, result2(50, 70)) // 120;
```

```js
const calculate2 = () => (n1, n2) => n1 * n2;

const r3 = calculate2()(10, 3);
console.log(`r3: ${r3}`);
```

2. lexical scope(렉시컬 스코프)
- 자바스크립트는 **코드가 실행될 때(runtime)**가 아니라 코드를 작성할 때(compile/define) 스코프를 결정함.
- "어디서 선언했는지" 기준으로 스코프가 결정
```js
function outer() {
let x = 100;
}

console.log(x); // ❌ ReferenceError
```
- x는 outer() 함수 내부에서 선언되었고, 바깥쪽에서는 코드상 위치가 외부라서 접근 불가함.

3. 클로저, 렉시컬 스코프
```js
function increaseClosure() {
  let count = 0; // 지역 변수

  return {
    increaseCount: () => ++count,
    decreaseCount: () => --count
  };
}
// 취미 개수를 세는 함수 정의(x) -> 클로저에게 받아옴
const { increaseCount: increaseHobbyCount, decreaseCount: decreaseHobbyCount } = increaseClosure();
// 친구 수를 세는 함수를 클로저에게 또 받아옴
const { increaseCount: increaseFriendCount, decreaseCount: decreaseFriendCount } = increaseClosure();
console.log('===== 취미 카운팅 시작! =====');
console.log(increaseHobbyCount()); // 1, increaseCount()
console.log(increaseHobbyCount()); // 2
console.log(decreaseHobbyCount()); // 1, decreaseCount();
console.log(increaseHobbyCount()); // 2

console.log('===== 친구 카운팅 시작! =====');
console.log(increaseFriendCount()); // 1
console.log(increaseFriendCount()); // 2
console.log(decreaseFriendCount()); // 1
console.log(decreaseFriendCount()); // 0
```
- increaseClosure가 호출되어 끝난 후 원래는 count를 지워야 하지만,
- 헬퍼 함수에 문제가 생길까봐 lexical scope 라는 특별한 공간에 count를 따로 보관함.


4. debounce (디바운스)
- 사용자의 입력을 충분히 기다렸다가 입력을 멈추었을 때 서버에 요청을 보내는 것.
- 이벤트가 계속 발생하는 동안은 실행을 미루고, 이벤트가 끝난 후에 딱 한 번만 실행하고자 할 때 적합
- 디바운스를 해야 할 경우가 많아질 경우 전역 변수로 타이머 아이디를
  여러개 선언 해야한다. 이를 막고자 타이머 아이디를 클로저로 정의.


```js
// 디바운스 클로저 함수 정의
function debounce(callback, delay) {
  // 클로저가 기억할 비공개 변수다.
  // 이 변수는 debounce 함수의 실행 완료시에도 사라지지 않습니다.
  let timerId = null;

  // 파라미터가 몇 개가 들어오든 받기 위해서 ...을 써줌.
  return function (...args) {
    clearTimeout(timerId);

    timerId = setTimeout(() => {
      callback(...args);
    }, delay);
  }
}



// 입력 이벤트 핸들러
function searchHandler(e) {
  console.log('서버에 음식이름 요청중....');
  console.log(e.target.value);

  // 입력된 음식이름에 맞는 데이터들을 배열에서 필터링
  const foodName = e.target.value;
  const filteredFoods = foodItems.filter(food => food.includes(foodName));
  console.log(filteredFoods);

  if (filteredFoods.length > 0) {
    // 이전 결과 지우기
    $results.innerHTML = '';

    filteredFoods.forEach(food => {
      const $newDiv = document.createElement('div');
      $newDiv.classList.add('result-item');
      $newDiv.textContent = food;
      $results.append($newDiv);
    });
  } else {
    $results.textContent = '일치하는 음식이 없습니다.';
  }

}

// 디바운스 클로저 호출
const debounceHandler = debounce(searchHandler, 1000);

// 이벤트 핸들러 바인딩
$searchInput.addEventListener('input', e => debounceHandler(e));
```
- 디바운스 클로저를 호출할 때 searchHandler 함수와 delay를 파라미터로 넣어 주었고,
- debounce 함수의 return은 함수이다.
- 결국 debounceHandler는 debounce 함수가 리턴한 함수로 봐야함.
- 이벤트 핸들러 바인딩을 통해 이벤트 객체(e)를 파라미터로 넣어줘서
- 결국 searchHandler(e)를 delay 시간 뒤에 실행시키는 것이다.





5. 스로틀
- 일정 시간 간격마다 이벤트를 실행하며, 그 사이에 발생한 이벤트는 무시
- 이벤트가 계속 발생하더라도 일정 간격마다 한 번씩 실행하고자 할 때 적합

스로틀 활용 무한 스크롤 이벤트
- 무한 스크롤 이벤트는 스크롤이 화면 최하단에 갔을 때만 발동함.
- 화면 최하단 감지를 위해서는 스크롤 위치, 뷰포트 높이, 문저 전체 높이가 필요

현재 스크롤의 y축 위치
- `const scrollTop = window.scrollY;`

현재 뷰포트의 높이 (브라우저에서 보이는 만큼의 높이)
- 뷰포트 높이는 해상도 크기에 따라 달라짐
- `const windowHeight = window.innerHeight;`

문서 전체의 높이 (안 보이는 부분까지 포함한 높이)
- `const documentHeight = document.body.offsetHeight;`

스크롤이 페이지의 90%정도 왔을때 미리 스크롤 이벤트 발생 시킴
```js
if (scrollTop + windowHeight >= documentHeight - 100) {
  // console.log('스크롤 이벤트 발생!');
  loadMoreContent();
}
```

스로틀 함수 정의
```js
function throttle(callback, delay) {
  let timerId = null; // 현재 스로틀이 쿨타임중인지 아닌지 상태를 기억하는 비공개변수

  return (...args) => {
    // 쿨타임이 아닐 때만
    if (!timerId) {
      // 스로틀 쿨타임 시작
      timerId = setTimeout(() => {
        callback(...args); // 1000ms의 딜레이 후에 실행
        timerId = null;
      }, delay);
    }
  };
}
```

컨텐츠 로딩
```js
// 초기 데이터 개수
let initCount = 16;

function loadMoreContent() {

  if (initCount >= 30) {
    return;
  }

  // 로딩 메시지 보여주기
  const $loading = document.getElementById('loading');
  $loading.style.display = 'block';

  // 실제 서버처럼 살짝의 강제로딩을 넣어봄
  setTimeout(() => {
    for (let i = 0; i < 4; i++) {
      const $newDiv = document.createElement('div');
      $newDiv.classList.add('content-item');
      $newDiv.textContent = `추가된 컨텐츠 ${++initCount}`;

      document.getElementById('contentContainer').append($newDiv);

      // 로딩 메시지 숨기기
      $loading.style.display = 'none';
    }
  }, 1500);
}
```

스크롤 이벤트 바인딩
`window.addEventListener('scroll', throttle(scrollHandler, 1500));`




🔍 현재 사이즈 가져오기
만약 현재 폰트 사이즈를 먼저 확인하고 싶다면:
```js
console.log($secondText.style.fontSize); // 결과: '' (빈 문자열일 가능성 높음!)
```
왜냐하면 .style.fontSize는 인라인 스타일로 지정된 값만 보여줌


CSS 에서 설정된 값은 **getComputedStyle()**을 써야 정확히 가져올 수 있음!
```js
const currentSize = getComputedStyle($secondText).fontSize;
console.log(currentSize); // 예: '20px'
```
