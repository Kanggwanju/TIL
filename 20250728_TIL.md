# 🗓️ 2025년 7월 28일 TIL


Spring JPA
- Spring Framework의 하위 프로젝트 중 하나
- 자바 애플리케이션에서 관계형 데이터베이스의 데이터를 접근하고 조작하는데 사용되는 표준인
- JPA(Java Persistence API)를 더욱 쉽고 편리하게 사용할 수 있게 해줌

JPA(Java Persistence API)
- Java EE5부터 등장한 API로, 자바 개발자가 RDBMS를 보다 쉽게 사용할 수 있도록 하기 위한 목적으로 제작
- ORM(Object-Relational Mapping) 표준 기술
- 자바 클래스와 DB 테이블 간의 매핑 정보를 사용
- SQL Query 없이 데이터를 조작할 수 있도록 도와줌


스프링 JPA 기능
- Repository 인터페이스: 기본 CRUD 연산 메소드를 제공
- 쿼리 메소드: 메소드 이름을 통해 쿼리를 생성하고 실행
- 페이징과 정렬: 페이징과 정렬에 대한 복잡한 코드를 단순화
- 동적 쿼리: 조건에 따라 동적으로 쿼리를 생성


Spring boot에서 JPA 기본설정

```yaml
# application.yml

server:
  port: 9001

spring:
  application:
    name: spring-db202507
  datasource:
    url: jdbc:mariadb://localhost:3306/spring_study
    username: root
    password: mariadb
  jpa:
    hibernate:
      ddl-auto: create # sql 자동 생성
    properties:
      hibernate:
        format_sql: true # sql 세로로 써주는 옵션
    database: mysql
```
ddl-auto: create # sql 자동 생성
테이블을 drop하고 새로 create함.
새로운 데이터를 쌓고싶으면 update로 변경
실무 or 배포 과정에선 보통은 none으로 함.
자동화된 DDL 작업은 예기치 않은 데이터 손실을 초래할 수 있음.



Entity 클래스 생성하기

MyBatis에서는 DB에 테이블 생성 -> 엔터티 생성 -> mapper 생성 -> mapper xml 파일 작성
JPA에서는 엔터티 생성 -> Repository 생성, sql 코드도 직접 쓸 필요 없음

JPA에서 Entity 클래스를 생성할 때 사용되는 주요 Annotation
1. @Entity
- 클래스를 JPA Entity로 선언하는 데 사용
- 이 클래스는 데이터베이스 테이블과 1:1로 매칭되는 클래스임을 밝힘

```java
@Entity
public class User {
    // ...
}
```

2. @Table
- 엔티티가 연결될 데이터베이스 테이블 지정
- 생략하면 클래스 이름이 테이블 이름으로 사용됨
```java
@Entity
@Table(name="users")
public class User {
    // ...
}
```

3. @Id
- 필드가 엔티티의 기본 키(Primary Key)임을 지정
```java
@Entity
public class User {
    @Id
    private Long id;
}
```

4. @GeneratedValue
- 기본 키의 생성 전략을 지정
```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO) // 자동생성
    private Long id;
}
```

5. @Column
- 필드가 매핑될 데이터베이스 컬럼을 지정
- name(컬럼 이름), nullable(널 가능 여부), length(길이 제한), updatable(수정가능여부), unique 등의 속성 설정 가능
```java
@Entity
public class User {
    @Id
    @GeneratedValue
    private Long id;

    @Column(name="prod_nm", length = 50, nullable=false, unique=true)
    private String username;
}
```

6. @CreationTimestamp
- INSERT시 자동으로 시간을 저장

7. @UpdateTimestamp
- UPDATE문 실행시 자동으로 시간 수정

8. @Enumerated
- Java의 enum 타입을 매핑하는 데 사용
- @Enumerated은 ORDINAL 또는 STRING 중 하나의 값을 가질 수 있음
- 열거형데이터는 따로 옵션을 안주면 숫자로 저장함.
- FOOD: 1, FASHION: 2, ...
```java
public class Product {
	@Enumerated(EnumType.STRING)
	private Category category; // 상품 카테고리

	public enum Category {
		FOOD, FASHION, ELECTRONIC
	}
}
```



JpaRepository
- Spring Data JPA에서 기본적인 Repository 인터페이스를 만드는 방법은 매우 간단
- 사용할 엔티티를 Product라고 가정
- JpaRepository의 첫번째 제너릭 타입은 엔티티의 타입
- 두번째 제너릭 타입은 Primary Key의 타입
```java
public interface ProductJpaRepository extends JpaRepository<Product, Long> { // 엔티티, PK의 타입

}
```

JpaRepository를 상속하면 아래와 같은 기본 CRUD 메서드들이 자동으로 제공
- `save(S entity)`: 주어진 엔티티를 저장하고 반환합니다.
- `findById(ID id)`: 주어진 ID를 가진 엔티티를 찾아 Optional로 반환합니다.
- `existsById(ID id)`: 주어진 ID를 가진 엔티티의 존재 여부를 반환합니다.
- `findAll()`: 모든 엔티티를 찾아 반환합니다.
- `count()`: 엔티티의 총 수를 반환합니다.
- `deleteById(ID id)`: 주어진 ID를 가진 엔티티를 삭제합니다.
- `deleteAll()`: 모든 엔티티를 삭제합니다.



JpaRepository 테스트

@SpringBootTest 
- 스프링이 관리하는 모든 Bean을 로딩
@Transactional
- 트랜잭션(transaction)을 시작하고, 성공하면 commit, 실패하면 rollback 해주는 애너테이션
@Rollback 
- 테스트가 끝나면 DML을 취소
위의 세 아노테이션을 한가지로 통합하는 아노테이션 `@DataJpaTest`

@DataJpaTest
- @SpringBootTest + @Transactional + @Rollback
- @Repository 빈만 로딩, 롤백 옵션 자동 포함, 내장 DB만 사용가능 (H2 Database)


@BeforeEach
- 메서드 상단에 붙이는 애너테이션
- 테스트 전에 자동으로 해당 메서드가 실행되게 함  

---

Update 테스트

```java
@Test
@DisplayName("2번 상품의 이름과 가격을 수정한다.")
void updateTest() {
	//given
	Long id = 2L;
	String newName = "청소기";
	int newPrice = 150000;
	Product.Category newCategory = ELECTRONIC;
    
	//when
	Product foundProduct = productJpaRepository.findById(id).orElseThrow();

	foundProduct.changeProduct(newName, newPrice, newCategory);

	Product saved = productJpaRepository.save(foundProduct);
	//then
	assertTrue(saved);
}
```

JPA에서는 수정메서드를 따로 제공하지 않습니다.
단일 조회를 수행한 후 setter를 통해 값을 변경하고
다시 save를 하면 INSERT문 대신에 UPDATE문이 나갑니다.

`.orElseThrow()`
- Java의 Optional 클래스에서 제공하는 메서드로, 값이 존재하면 그 값을 반환하고, 존재하지 않으면 예외를 던지는 메서드
- 보통 결과를 `Optional<T>`로 반환
- `Optional`: `null` 일 수도 있는 값을 감싸서 `NullPointerException` 방지
- 예외 커스터마이징 가능: .orElseThrow(() -> new IllegalArgumentException("상품이 존재하지 않습니다."));


setter를 사용하면 여러번 반복해서 작성해야 하므로, 엔터티 내부에
편의 메서드를 만들어서 파라미터를 넣어주면 자동으로 객체의 필드가
변경되게 만들음.


SQL 로그 설정 (p6spy)

build.gradle
```text
dependencies {
	implementation 'com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.9.1'
}
```



Spring Data JPA 쿼리 메서드
- JPA는 Repository 인터페이스에 정의된 메서드 이름을 분석하여 해당하는 쿼리를 자동으로 생성해주는 기능을 제공
- 이를 쿼리 메서드 또는 메서드 쿼리라고 부름


쿼리 메서드 작성 규칙
- `findBy<필드이름>`: 주어진 필드값에 해당하는 엔티티를 조회합니다.
- `countBy<필드이름>`: 주어진 필드값에 해당하는 엔티티의 개수를 반환합니다.
- `existsBy<필드이름>`: 주어진 필드값에 해당하는 엔티티가 존재하는지 여부를 반환합니다.
- `deleteBy<필드이름>` 또는 `removeBy<필드이름>`: 주어진 필드값에 해당하는 엔티티를 삭제합니다.
- `<필드이름>LessThan`, `<필드이름>GreaterThan`, `<필드이름>Between` 등: 주어진 필드값을 기준으로 비교하는 엔티티를 조회

사용 예시
```java
public interface StudentRepository extends JpaRepository<Student, String> {

    List<Student> findByName(String name);

    // WHERE city = ? AND major = ?
    List<Student> findByCityAndMajor(String city, String major);

    // WHERE major LIKE '%?%'
    List<Student> findByMajorContaining(String major);

    // WHERE major LIKE '?%'
    List<Student> findByMajorStartingWith(String major);

    // WHERE major LIKE '%?'
    List<Student> findByMajorEndingWith(String major);
}
```