# 🗓️ 2025년 8월 26일 TIL

## 오늘의 키워드
- 입력창 초기화와 단방향 데이터 흐름
- 객체 상태 관리 & 불변성
- 이전 상태값 기반 업데이트 (비동기 처리 주의)
- 상향식 데이터 전달 (부모 ↔ 자식)
- 동적 리스트 렌더링과 key prop
- 조건부 렌더링 패턴
- 차트 UI 구현 흐름 (ExpenseList → ExpenseChart → Chart → ChartBar)

---

## 입력창 초기화

input 태그에다가 값을 입력하면 -> 상태변수에 저장됨  (단방향)
상태변수의 값을 바꾸면 -> input이 갱신된다?  (X)     (양방향)

form 제출 이벤트, 입력창 초기화
```jsx
const handleSubmit = (e) => {
  e.preventDefault();
  setTitle('');
  setPrice(0);
  setDate(null);
};
```

```jsx
<input
  type='date'
  min='2019-01-01'
  max={getTodayDate()}
  onInput={e => setDate(e.target.value)}
  value={date ?? ''}
/>
```
- ??는 왼쪽이 널일때 오른쪽

---

## 객체로 상태값을 한번에 관리 

```jsx
const initUserInputState = {
  title: '',
  price: 0,
  date:null
};

const [userInput, setUserInput] = useState(initUserInputState);
```

form 제출 이벤트에서는 

`setUserInput(initUserInputState);`를 해주면 됨

근데 input에 입력을 하면 onInput 이벤트 핸들러에서
setTitle 등으로 상태값을 변경했었음.


그러면 이제 각각의 onInput 이벤트 핸들러에서
객체의 프로퍼티 값을 setter로 변경해주면 되는가?
```jsx
const titleChangeHandler = e => {
  userInput.title = e.target.value;
  setUserInput(userInput);
};
```
-> 아님. 리액트는 기존객체에서 프로퍼티 값만을 바꾸면 상태변경을 감지하지 못함

아예 새로운 객체를 만들어서 전달해줘야 리액트가 감지하고 리렌더링을 함.

```jsx
const titleChangeHandler = e => {
  const newUserInput = {
    ...userInput,
    title: e.target.value,
  };

  setUserInput(newUserInput);
};
```

---

## 이전 상태값을 반영하여 상태 업데이트하기

리액트의 비동기 처리
- React의 상태 업데이트는 비동기적으로 이루어짐
- 여러 상태 업데이트가 동시에 일어나면 이전 상태를 기반으로 하는
  업데이트가 올바르게 반영되지 않을 수 있음
```jsx
const increaseHandler = () => {
  setCount(count + 1);
  setCount(count + 1);
}
```
- 위의 두개의 setCount는 비동기적으로 처리되므로
  업데이트가 올바르게 반영되지 않음

```jsx
const increaseHandler = () => {
  setCount(prev => prev + 1);
  setCount(prev => prev + 1);
}
```
- 위의 setCount는 count의 이전 값을 가져와서 더해주기 때문에
  확실하게 반영됨.


```jsx
const priceChangeHandler = e => setUserInput(prev => ({
  ...prev,
  price: +e.target.value,
}));
```
- ...prev → 기존 객체 상태를 전부 펼쳐서 복사(spread)
- price: +e.target.value → price만 새 값으로 교체.

---

## 상향식 데이터 전달

- 폼에 데이터를 입력하면 부모쪽에서 그 데이터를 이용해서 목록을 추가 해줘야함.
- 바구니처럼 부모가 함수를 내려주면, 자식쪽에서 파라미터를 담아 함수를 실행

1. 부모에서 컴포넌트를 호출
```jsx
<ExpenseFilter onChangeFilter={onFilterChange} />
```

2. 자식이 파라미터를 담아서 함수를 실행
```jsx
const changeYearHandler = e => {
  onChangeFilter(e.target.value);
};
return (
    <select onChange={changeYearHandler}>
      <option value='2025'>2025</option>
      <option value='2024'>2024</option>
      <option value='2023'>2023</option>
      <option value='2022'>2022</option>
      <option value='2021'>2021</option>
      <option value='2020'>2020</option>
      <option value='2019'>2019</option>
    </select>
);
```

3. 부모의 onFilterChange 함수가 실행됨
```jsx
const onFilterChange = (filteredYear) => {
  console.log(`선택된 연도: ${filteredYear}`);
  setYear(filteredYear);
};
```

---

## 동적 리스트 렌더링

```jsx
{expenseList
    .filter(ex => ex.date.getFullYear().toString() === year)
    .map(ex => <ExpenseItem expense={ex} />)}
```
- `ExpenseItem` 컴포넌트는 expenseList 배열의 각 항목에 대해 생성됨.
- `filter`, `map` 함수는 배열의 각 요소에 콜백 함수를 실행, 새로운 배열 반환
- 결과적으로 각 요소에 대해 `ExpenseItem` 컴포넌트를 반환
- `expense={ex}`: prop 전달


### key prop
- 각 항목을 식별하기 위해 `key` prop을 사용
- `key`는 각 항목이 구별되도록 고유한 값을 가져야 함.
- `key`가 없으면 React는 모든 항목을 처음부터 렌더링 해야 할 수 있음.
```jsx
.map(ex => <ExpenseItem key={Math.random().toString()} expense={ex} />)
```

---

## 조건부 렌더링

- 특정 조건에 따라 다른 컴포넌트를 렌더링하는 패턴

```jsx
// 해당년도 지출항목들을 필터링
const filteredExpenses = expenseList
    .filter(ex => ex.date.getFullYear().toString() === year);

{
  filteredExpenses.length > 0
      ? filteredExpenses
          .map(ex => <ExpenseItem key={Math.random().toString()} expense={ex} />)
      : <p>아직 해당년도의 지출항목이 없습니다.</p>
}
```
- `expenseList`를 미리 연도로 필터링
- `filteredExpenses` 배열이 비어있지 않으면 -> 리스트(ExpenseItem)를 렌더링
- `filteredExpenses` 배열이 비어있으면 -> `<p>` 태그 문구를 렌더링

---

## 차트 UI

1. `ExpenseList` 컴포넌트에서 `ExpenseChart`를 렌더링
- `expenseList`를 연도로 필터링한 결과를 `expenses` prop으로 전달
```jsx
<ExpenseChart expenses={filteredExpenses} />
```


2. `ExpenseChart` 컴포넌트에서 `Chart`를 렌더링
- 필터링된 지출 배열을 통해 chartDataPoints의 value들을 채우기
```jsx
expenses.forEach(ex => {
  chartDataPoints[ex.date.getMonth()].value += ex.price;
});
```

- `value`가 변경된 `chartDataPoints`를 `dataPoints` prop으로 전달
```jsx
<Chart dataPoints={chartDataPoints} />
```

3. `Chart` 컴포넌트에서 `ChartBar`를 렌더링
- `reduce` 함수를 통해 `dataPoints`의 value를 모두 더함 -> `totalValue`
```jsx
const totalValue = dataPoints.reduce((acc, dp) => acc + dp.value, 0);
```

- `key`, `label`, 현재 달의 value, `totalValue`를 prop으로 전달
```jsx
dataPoints.map(dp => <ChartBar
    key={dp.label}
    label={dp.label}
    currentMonthValue={dp.value}
    totalValue={totalValue}
/>)
```

4. `ChartBar`에서 UI를 렌더링
- 월별 지축액 비율 구하기: 해당월의 지출액 / 해당년도의 총지출액
```jsx
let barFillHeight = '0%';

if (totalValue > 0) {
  const percentage = (currentMonthValue / totalValue) * 100;
  barFillHeight = percentage + '%';
}
```

- `barFillHeight`를 통해 막대 그래프 height를 변경
```jsx
<div className='chart-bar__fill' style={{height: barFillHeight}}></div>
```

---

## ✅ 최종 정리

* **입력창 초기화**: 상태변수로 제어되는 input은 form 제출 시 초기값으로 reset
* **객체 상태 관리**: 기존 객체 속성만 수정하면 리렌더링 X → 새로운 객체를 만들어 `setState` 해야 함
* **이전 상태 기반 업데이트**: 상태 업데이트는 비동기 → `setState(prev => …)` 패턴을 사용해야 안전
* **상향식 데이터 전달**: 자식 컴포넌트에서 부모 함수 호출 → 부모 상태 갱신
* **동적 리스트 렌더링**: `filter` + `map` 조합, 각 항목에 고유한 `key` 필요
* **조건부 렌더링**: 데이터 유무에 따라 다른 UI를 보여주는 패턴 (`삼항연산자`, `&&`)
* **차트 UI**:

  * 필터링된 데이터 → `ExpenseChart`
  * 데이터 집계 → `Chart`
  * 시각화 비율 계산 → `ChartBar`


