# 🗓️ 2025년 8월 1일 TIL

## ✨ 오늘 학습한 핵심 키워드

* `QueryDSL`의 `SELECT` 절 컬럼 지정
* `Tuple`을 이용한 다중 컬럼 조회 및 접근 방법
* 집계 함수 (`SUM`, `AVG`, `COUNT` 등)
* `GROUP BY`, `HAVING` 사용법
* `DTO`로 결과 매핑하는 두 가지 방법
* `innerJoin`, `leftJoin`, `fetchJoin` 사용법
* `N + 1` 문제 발생 조건 및 해결 방법

---

## ✅ QueryDSL SELECT

### 🔹 1. 원하는 컬럼만 조회

```java
List<Tuple> idolList = factory
                .select(idol.idolName, idol.age)
                .from(idol)
                .fetch();
```

#### 🎯 반환 타입 요약

| 조회 방식                              | 반환 타입          |
| ---------------------------------- | -------------- |
| `.select(idol.idolName)`           | `List<String>` |
| `.select(idol.idolName, idol.age)` | `List<Tuple>`  |
| `.select(idol)`                    | `List<Idol>`   |

#### 🧾 Tuple 데이터 접근 예시

```java
for (Tuple tuple : idolList) {
    String name = tuple.get(idol.idolName);
    Integer age = tuple.get(idol.age); // 또는 int age = tuple.get(idol.age); → 오토 언박싱

    System.out.printf("이름: %s, 나이: %d세\n", name, age);
}
```

---

### 🔸 2. 집계 함수 사용

#### 📌 전체 그룹화 (GROUP BY 없이 집계 함수만 사용)

```java
Integer sumAge = factory
        .select(idol.age.sum())
        .from(idol)
        .fetchOne();
```

* `SUM`, `AVG`, `MAX`, `MIN`, `COUNT` 등 다양한 집계 함수 사용 가능

---

### 🔸 3. GROUP BY 사용

#### 🧮 그룹별 인원 수 세기

```java
List<Tuple> idolCounts = factory
        .select(idol.group.groupName, idol.count())
        .from(idol)
        .groupBy(idol.group.id)
        .fetch();
```

#### 📊 그룹별 평균 나이 + HAVING 절로 필터링

```java
List<Tuple> tuples = factory
        .select(idol.group.groupName, idol.age.avg())
        .from(idol)
        .groupBy(idol.group.groupName)
        .having(idol.age.avg().between(20, 25))
        .fetch();
```

* `HAVING` 절은 **집계된 그룹 결과**를 조건으로 필터링할 때 사용

---

### 🔹 4. DTO로 결과 매핑

#### 🧱 DTO 클래스 예시 (`GroupAverageAge.java`)

```java
public class GroupAverageAge {

    private String groupName;
    private Double averageAge;

    // 생성자 방식 매핑
    public GroupAverageAge(Tuple tuple) {
        this.groupName = tuple.get(QIdol.idol.group.groupName);
        this.averageAge = tuple.get(QIdol.idol.age.avg());
    }

    // 정적 팩토리 메서드 방식
    public static GroupAverageAge from(Tuple tuple) {
        return GroupAverageAge.builder()
                .groupName(tuple.get(QIdol.idol.group.groupName))
                .averageAge(tuple.get(QIdol.idol.age.avg()))
                .build();
    }
}
```

---

### ✅ DTO 매핑 방법

#### ✔ 방법 1. `Stream + Tuple → DTO` 매핑

```java
List<GroupAverageAge> results = factory
        .select(idol.group.groupName, idol.age.avg())
        .from(idol)
        .groupBy(idol.group.groupName)
        .having(idol.age.avg().between(20, 25))
        .fetch()
        .stream()
        .map(tuple -> GroupAverageAge.from(tuple))
        .collect(Collectors.toUnmodifiableList());
```

* `Stream + map`을 활용해 튜플을 DTO로 변환
* **정적 팩토리 메서드 패턴** 활용
* 읽기 쉬우며 유지보수가 용이

---

#### ✔ 방법 2. `Projections.constructor(...)` 사용

```java
List<GroupAverageAge> results = factory
        .select(
                Projections.constructor(
                        GroupAverageAge.class,
                        idol.group.groupName,
                        idol.age.avg()
                )
        )
        .from(idol)
        .groupBy(idol.group.groupName)
        .having(idol.age.avg().between(20, 25))
        .fetch();
```

* `Projections.constructor()`는 DTO의 생성자에 값을 자동 주입
* DTO는 `@AllArgsConstructor` 또는 적절한 생성자가 필요


---


## ✅ QueryDSL Join

### 🔹 1. Inner Join 예시

```java
List<Idol> idolList = factory
        .select(idol)
        .from(idol)
        .innerJoin(idol.group, group).fetchJoin()
        .fetch();
```

#### 💡 이전 방식

* `.where(idol.group.groupName.eq("아이브"))`
  👉 이렇게 **명시적인 조인 없이**도 필드 접근으로 연관 데이터를 사용할 수 있었음
  하지만 **쿼리 최적화**에는 한계가 있음.

#### 🧩 `.innerJoin(idol.group, group)` 설명

* 첫 번째 인자: `from` 절에 선언한 엔티티의 **연관관계 필드**
* 두 번째 인자: 실제로 조인할 **Q타입의 대상 엔티티**

---

### 🔸 2. `.fetchJoin()`이란?

#### ✅ `.fetchJoin()` 사용 시

* ✨ **조인된 엔티티까지 한 번에 로딩 (Idol + Group)**
* ✔️ **쿼리 1번만 실행**
* 💨 `idol.getGroup()` 호출 시에도 **추가 쿼리 없음**

```sql
-- 단 1회 실행되는 쿼리
SELECT * FROM idol 
JOIN group ON ...
```

#### ❌ `.fetchJoin()` 미사용 시

* `idol`만 조회하고, `group`은 로딩 안 됨 (지연 로딩 상태)
* 이후 `idol.getGroup()` 호출할 때마다 쿼리 발생

```sql
-- 아이돌 5명이라면 아래 쿼리가 5번 실행됨
SELECT * FROM group WHERE id = ?;
```

#### ⚠️ 결과: N + 1 문제 발생

* 1번: 아이돌 전체 조회
* N번: 각 아이돌의 그룹 조회
  → 총 **1 + N번 쿼리** 실행 → 비효율적 ❗

---

### 🔹 3. Left Outer Join 예시

```java
List<Idol> idolList = factory
        .select(idol)
        .from(idol)
        .leftJoin(idol.group, group).fetchJoin()
        .fetch();
```

* innerJoin과 사용법 동일
* 차이점은 👉 **조인 대상이 없어도 Null로 채워서 반환**됨

---

### 🔸 4. 2중 Inner Join 예시 (Idol → Group → Album)

```java
List<Tuple> idolList = factory
        .select(idol, album)
        .from(idol)
        .innerJoin(idol.group, group)
        .innerJoin(group.albums, album)
        .where(album.releaseYear.eq(year))
        .fetch();
```

#### 🧾 이 쿼리는 다음과 같은 의미

* 아이돌 → 그룹 → 앨범까지 **다단계 조인**
* **2022년에 발매된 앨범**을 조건으로 필터링
* 각 튜플에는 `Idol`과 `Album` 정보가 포함됨

---


## 🧾 오늘의 학습 요약 정리

| 분류                   | 기능 / 설명                                               |
| -------------------- | ----------------------------------------------------- |
| `select(컬럼)`         | 하나 or 여러 컬럼만 조회 가능 (`List<String>` / `List<Tuple>`)   |
| `Tuple.get(...)`     | 튜플에서 값 꺼낼 때 사용                                        |
| 집계 함수                | `.sum()`, `.avg()`, `.count()` 등                      |
| `groupBy(...)`       | 그룹화 기준 설정                                             |
| `having(...)`        | 그룹핑된 결과 조건 필터링                                        |
| DTO 매핑 방법            | `Stream + 정적 팩토리 메서드`, `Projections.constructor(...)` |
| `.innerJoin(a.b, c)` | 연관 필드 기준 조인                                           |
| `.leftJoin()`        | Outer Join (null도 포함)                                 |
| `.fetchJoin()`       | 즉시 로딩 (N+1 문제 예방)                                     |
| 지연 로딩 주의             | `.getX()` 호출 시 쿼리 발생 가능 → 성능 이슈 유발                    |

