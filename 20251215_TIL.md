# 🗓️ 2025년 12월 15일 TIL – C언어 기출 문제 풀이

## 📌 오늘의 키워드

`연결 리스트` `구조체 포인터(->)` `static 지역 변수` `이중 포인터(int**)`
`문자 배열(ASCII)` `삽입(shift)` `동적 2차원 배열` `삼항 연산자`
`비트 AND(&) 마스킹` `원형 큐(모듈러)` `구조체 배열 대입` `노드 역방향 연결`

---

## 1️⃣ 연결 리스트 기본 연결 & 포인터 체이닝 – 2024년 2회차

### 💻 코드

```c
#include <stdio.h>

struct node {
    int n1;
    struct node *n2;
};

// 2024년 2회차, 연결 리스트
int main(void) {

    struct node a = {10, NULL};
    struct node b = {20, NULL};
    struct node c = {30, NULL};

    struct node *head = &a;
    a.n2 = &b;
    b.n2 = &c;

    // head -> a n1:10, n2 -> b n1:20, n2 -> c n1:30, n2:NULL
    // head는 노드 포인터, a를 가리킴
    // head->n2는 a의 n2 멤버, b
    // head->n2->n1은 b의 n1 멤버

    // 정답: 20
    printf("%d\n", head->n2->n1);

    return 0;
}
```

### 🌱 핵심 개념

* `head->n2->n1`처럼 **next를 타고 들어가며** 값에 접근하는 문제
* `->`는 “포인터가 가리키는 구조체 멤버 접근” 연산자

### ✅ 출력 결과

```
20
```

---

## 2️⃣ static 지역 변수 누적 – 2024년 3회차

### 💻 코드

```c
#include <stdio.h>

// static 지역 변수는 함수가 종료되어도 값이 사라지지 않음
// main 함수의 x와 func 함수의 x를 별개의 존재로 생각해야 한다.
// 예: func()가 2번 호출되면 x가 4가 된다.
int func() {
    static int x = 0;
    x += 2;
    return x;
}

// 2024년 3회차, static
int main(void) {

    int x = 1;
    int sum = 0;
    for (int i = 0; i < 4; i++) {
        x++;
        sum += func();
    }
    
    // 정답: 20
    printf("%d", sum);
    
    return 0;
}
```

### 🌱 핵심 개념

* `static` 지역 변수는 함수 호출이 끝나도 값이 유지됨 → **누적형 변수**처럼 동작
* `main`의 `x`와 `func`의 `x`는 **서로 다른 변수**

### ✅ 출력 결과

```
20
```

---

## 3️⃣ 연결 리스트 값 스왑(두 칸씩 이동) – 2024년 3회차

### 💻 코드

```c
#include <stdio.h>

// 연결 리스트 구조체
struct Node {
    int value;
    struct Node* next;
};

// 처음 노드와 연결된 다음 노드의 value를 변경하는 함수
void func(struct Node * node) {
    while(node != NULL && node->next != NULL) {
        int t = node->value;
        node->value = node->next->value;
        node->next->value = t;
        node = node->next->next;
    }
}

// 2024년 3회차, 연결 리스트
int main(void) {
    
    struct Node n1 = {1, NULL}, n2 = {2, NULL}, n3 = {3, NULL};
    n1.next = &n3;
    n3.next = &n2;

    func(&n1);

    struct Node* current = &n1;

    // 정답: 312
    while(current != NULL) {
        printf("%d", current->value);
        current = current->next;
    }

    return 0;
}
```

### 🌱 핵심 개념

* 노드 연결을 바꾸는 게 아니라 **value만 swap**함
* `node = node->next->next` 때문에 **두 칸씩 건너뜀**

### ✅ 출력 결과

```
312
```

---

## 4️⃣ 이중 포인터(int**)로 배열 값 수정 – 2024년 3회차

### 💻 코드

```c
#include <stdio.h>

// arr: pp
// *arr: p
// *(*arr + i): arr[i]
void func(int** arr, int size) {
    for (int i = 0; i < size; i++) {
        *(*arr + i) = (*(*arr + i) + i) % size;
    }
}

// 2024년 3회차, 이중 포인터
int main(void) {
    
    int arr[] = {3, 1, 4, 1, 5};
    int* p = arr;
    int** pp = &p;
    int num = 6;

    // 3, 2, 1, 4, 4
    func(pp, 5);
    num = arr[2];

    // 정답: 1
    printf("%d", num);

    return 0;
}
```

### 🌱 핵심 개념

* `*(*arr + i)`는 결국 `arr[i]`를 의미 → **원본 배열 수정**
* `% size`로 값이 0~4 범위로 순환

### ✅ 출력 결과

```
1
```

---

## 5️⃣ 문자 배열 삽입 로직 + ASCII 차이 – 2025년 1회차

### 💻 코드

```c
#include <stdio.h>

char Data[5] = {'B', 'A', 'D', 'E'};
char c;

// 2025년 1회차
int main(void) {
    
    int i, temp, temp2;
    c = 'C';

    // 참고: A: 65, a: 97, '0': 48
    // 'E'(69) - 'A'(65) = 4
    printf("%d\n", Data[3] - Data[1]);

    // i = 2
    for(i = 0; i < 5; ++i) {
        if(Data[i] > c)
            break;
    }

    temp = Data[i]; // Data[2] = D -> 68
    Data[i] = c;
    i++;

    for (; i < 5; ++i) {
        temp2 = Data[i];
        Data[i] = temp;
        temp = temp2;
    }

    // 정답: BACDE
    for (i = 0; i < 5; i++) {
        printf("%c", Data[i]);
    }

    return 0;
}
```

### 🌱 핵심 개념

* 문자 비교는 ASCII 숫자 비교
* “끼워 넣기”는 `temp`로 들고 뒤를 한 칸씩 미는 패턴


### ✅ 출력 결과

* 첫 줄: `4`
* 다음 줄: `BACDE`

---

## 6️⃣ 동적 2차원 배열 + 교차 부호 합 – 2025년 1회차

### 💻 코드

```c
#include <stdio.h>
#include <stdlib.h>

// 2차원 배열 초기화
void set(int** arr, int* data, int rows, int cols) {
    for (int i = 0; i < rows * cols; ++i) {
        arr[((i + 1) / rows) % rows][(i + 1) % cols] = data[i];
    }
}

// 2025년 1회차, 2차원 배열
int main(void) {
    
    int rows = 3, cols = 3, sum = 0;
    int data[] = {5, 2, 7, 4, 1, 8, 3, 6, 9};

    // 2차원 배열 3행, 3열 동적 할당
    int** arr = (int**) malloc(sizeof(int*) * rows);
    for (int i = 0; i < cols; i++) {
        arr[i] = (int*) malloc(sizeof(int) * cols);
    }

    /*
        9 5 2
        7 4 1
        8 3 6
    */
    set(arr, data, rows, cols);
    for (int i = 0; i < rows * cols; i++) {
        //                               i가 짝수면 1, 홀수면 -1
        sum += arr[i / rows][i % cols] * (i % 2 == 0 ? 1 : -1);
    }

    // 정답: 13
    printf("%d", sum);

    return 0;
}
```

### 🌱 핵심 개념

* 2차원 동적 할당: “행 포인터 배열 → 각 행 메모리”
* `(i % 2 == 0 ? 1 : -1)` → 번갈아 더하고 빼기

### ✅ 출력 결과

```
13
```

---

## 7️⃣ 연결 리스트: 특정 값 노드를 head로 이동 – 2025년 1회차

### 💻 코드

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Data {
    int value;
    struct Data *next;
} Data;

Data* insert(Data* head, int value) {
    Data* new_node = (Data*)malloc(sizeof(Data));
    new_node->value = value;
    new_node->next = head;
    return new_node;
}

Data* reconnect(Data* head, int value) {
    if (head == NULL || head->value == value) return head;
    Data *prev = NULL, *curr = head;

    while (curr != NULL && curr->value != value) {
        prev = curr;
        curr = curr->next;
    }

    if (curr != NULL && prev != NULL) {
        prev->next = curr->next;
        curr->next = head;
        head = curr;
    }

    return head;
}

// 2025년 1회차, 연결 리스트
int main(void) {

    Data *head = NULL, *curr;

    // head -> Data(value:5) -> Data(value:4)
    // -> Data(value:3) -> Data(value:2) -> Data(value:1)
    for (int i = 1; i <= 5; i++)
        head = insert(head, i);
    
    // head -> Data(value:3) -> Data(value:5)
    // -> Data(value:4) -> Data(value:2) -> Data(value:1)
    head = reconnect(head, 3);
    
    // 정답: 35421
    for (curr = head; curr != NULL; curr = curr->next)
        printf("%d", curr->value);

    return 0;
}
```

### 🌱 핵심 개념

* 중간 노드를 떼어 `head` 앞으로 붙이는 “재연결” 패턴
* `prev->next = curr->next`가 핵심(떼어내기)

### ✅ 출력 결과

```
35421
```

---

## 8️⃣ 16진수 + 비트 AND(&) 마스킹 – 2025년 1회차

### 💻 코드

```c
#include <stdio.h>

typedef struct student {
    char* name;
    int score[3];
} Student;

// 비트 연산 &: 두 개의 비트가 모두 1일때 1
int dec(int enc) {
    return enc & 0xA5;
}

int sum(Student* p) {
    return dec(p->score[0]) + dec(p->score[1]) + dec(p->score[2]);
}

// 2025년 1회차 구조체, 16진수, 비트연산
int main(void) {
    /*
        2진수로 변환
        A5: 1010 0101
        A0: 1010 0000
        DB: 1101 1011
        ED: 1110 1101
        81: 1000 0001
    */
    Student s[2] = { {"Kim", {0xA0, 0xA5, 0xDB}}, {"Lee", {0xA0, 0xED, 0x81}} };
    int result = 0;

    for (int i = 0; i < 2; i++) {
        result += sum(&s[i]);
    }

    // 정답: 908
    printf("%d", result);

    return 0;
}
```

### 🌱 핵심 개념

* `& 0xA5`는 대표적인 **비트 마스킹**
* 필요한 비트만 남겨 “복호화”한 다음 합산

### ✅ 출력 결과

```
908
```

---

## 9️⃣ 원형 큐(Circular Queue) – 2025년 2회차

### 💻 코드

```c
#include <stdio.h>
#define SIZE 3

typedef struct {
    int a[SIZE];
    int front;
    int rear;
} Queue;

void enq(Queue* q, int val) {
    q->a[q->rear] = val;
    q->rear = (q->rear + 1) % SIZE; // 모듈러 연산
}

int deq(Queue* q) {
    int val = q->a[q->front];
    q->front = (q->front + 1) % SIZE;
    return val;
}

// 2025년 2회차, 원형 큐
int main(void) {
    
    Queue q = {{0}, 0, 0};

    enq(&q, 1); enq(&q, 2); deq(&q); enq(&q, 3);

    int first = deq(&q);
    int second = deq(&q);

    // 정답: 2 그리고 3
    printf("%d 그리고 %d", first, second);

    return 0;
}
```

### 🌱 핵심 개념
- `rear`, `front`가 `(idx+1)%SIZE`로 순환 → “원형” 구현
- enq/deq를 섞을 때는 **front/rear 이동 순서**를 추적해야 함

### 🔁 흐름 요약
- enq 1, enq 2 → 큐에 1,2
- deq → 1 빠짐
- enq 3 → 큐에는 2,3
- deq 2, deq 3 → 출력 `2 그리고 3`

### ✅ 출력 결과

```
2 그리고 3
```


---

## 🔟 구조체 배열 + 이중 포인터로 원소 대입 – 2025년 2회차

### 💻 코드
```c
#include <stdio.h>

struct dat {
    int x;
    int y;
};

// 2025년 2회차 구조체, 포인터
int main(void) {

    struct dat a[] = {{1, 2}, {3, 4}, {5, 6}};
    struct dat* ptr = a;
    struct dat** pptr = &ptr;

    (*pptr)[1] = (*pptr)[2];

    // 5 그리고 6
    printf("%d 그리고 %d", a[1].x, a[1].y);

    return 0;
}
```

### 🌱 핵심 개념
- `(*pptr)[1]`은 결국 `a[1]`
- 구조체 대입은 멤버를 따로 복사하는 게 아니라 **구조체 통째로 복사**가 일어남

### ✅ 출력 결과
```
5 그리고 6
```


---

## 1️⃣1️⃣ 연결 리스트 재연결: head를 c로 바꾸기 – 2025년 2회차

### 💻 코드
```c
#include <stdio.h>
#include <stdlib.h>

struct node {
    int p;
    struct node* n;
};

// 2025년 2회차, 연결 리스트
int main(void) {

    struct node a = {1, NULL};
    struct node b = {2, NULL};
    struct node c = {3, NULL};

    a.n = &b; b.n = &c; c.n = NULL; // a -> b -> c
    c.n = &a; a.n = &b; b.n = NULL; // c -> a -> b

    struct node* head = &c; // head -> c

    // 정답: 3 1 2
    printf("%d %d %d", head->p, head->n->p, head->n->n->p);
    
    return 0;
}
```

### 🌱 핵심 개념
- 포인터 재연결을 통해 리스트 시작을 c로 바꿈
- `head -> c -> a -> b` 구조를 체이닝으로 출력

### ✅ 출력 결과
```
3 1 2
```


---

## 1️⃣2️⃣ 연결 리스트 생성(앞에 붙이기) + putchar 출력 – 2025년 2회차

### 💻 코드
```c
#include <stdio.h>
#include <stdlib.h>

struct node {
    char c;
    struct node* p;
};

struct node* func(char* s) {
    struct node* h = NULL, *n;

    while (*s) {
        n = malloc(sizeof(struct node));
        n->c = *s++;
        n->p = h;
        h = n;
    }
    return h;
}

// 2025년 2회차, 연결리스트, 단일 문자 출력
int main(void) {

    // n -> node4(T) -> node3(S) -> node2(E) -> node1(B)
    struct node* n = func("BEST");

    // 정답: TSEB
    while (n) {
        putchar(n->c); // 한글자 출력
        struct node* t = n;
        n = n->p;
        free(t);
    }
    
    return 0;
}
```

### 🌱 핵심 개념
- `h` 앞에 새 노드를 계속 붙이므로 문자열이 **역순 리스트**로 만들어짐
- `putchar`는 한 글자 출력, 루프에서 출력하면 문자열처럼 찍힘
- 출력하면서 `free`까지 해서 메모리 해제도 같이 함

### ✅ 출력 결과
```
TSEB
```


---

## 🎯 오늘의 최종 정리

- **연결 리스트**: “값 swap”인지 “노드 재연결”인지 구분이 핵심
- **포인터/이중포인터**: `*(*p + i)`처럼 해석을 단계로 쪼개면 안전
- **static**: 함수 호출 간 누적되는 지역 변수 패턴
- **문자/ASCII**: 문자 비교는 결국 숫자 비교(삽입, 정렬류 문제에 자주 나옴)
- **비트 마스킹**: `& 0xA5` 같은 고정 마스크는 단골 출제
- **원형 큐**: `(idx+1)%SIZE`로 front/rear 순환 추적

---

## 💬 오늘의 소감

이번 12문제는 **포인터가 어디를 가리키는지**를 끝까지 추적하는 연습이 핵심이었다.

특히 연결 리스트/큐/비트 연산은 실수 포인트가 정해져 있기 때문에,
손으로 추적해보아서 다음부터 문제 푸는 속도가 훨씬 빨라질 것 같다.
