# 🗓️ 2025년 9월 4일 TIL


## 회원가입 과정
1. 사용자가 이메일 입력
2. 입력된 이메일에 인증코드 발송
3. 옳은 인증코드 입력 시 비밀번호 설정

- 이전에 1, 2번 과정 작성, 3번인 비밀번호 설정 차례.


## [FE] 비밀번호 설정
- 이전 과정을 정상적으로 수행했을 때 진행 가능

1. `input` 태그에 `onChange` 이벤트 핸들러를 연결
- 박스에 글자를 한 글자라도 입력하거나 지우는 등 어떤 변화를 줄 때마다
- `changeHandler` 함수가 자동으로 호출
```jsx
// PasswordInput.jsx
return (
  <>
    <p>Step 3: 안전한 비밀번호를 설정해주세요.</p>
    <input
      ref={passwordRef}
      type='password'
      value={password}
      onChange={changeHandler}
      className={errorMessage ? styles.invalidInput : ''}
      placeholder='Enter your password'
    />
    {errorMessage && <p className={styles.errorMessage}>{errorMessage}</p>}
  </>
);
```

2. `changeHandler` 함수
- 입력된 비밀번호를 `e.target.value`를 통해 받아옴
- `setPassword`를 통해 상태 변수 변경
- `validatePassword` 함수를 통해 패스워드 패턴검증
- 패턴 검증을 통과 및 실패하면 에러메시지 미설정, 부모가 내려준 onSuccess 함수 호출

```jsx
const [password, setPassword] = useState('');
const [errorMessage, setErrorMessage] = useState('');

const changeHandler = (e) => {
  const newPassword = e.target.value;
  setPassword(newPassword);

  if (validatePassword(newPassword)) {
    setErrorMessage('');
    onSuccess(true, newPassword);
  } else {
    setErrorMessage(
      '비밀번호는 8자 이상이며, 숫자, 문자, 특수문자를 모두 포함해야 합니다.'
    );
    onSuccess(false, newPassword);
  }
};
```

---

## [FE] 회원가입 완료

1. 함수 내려주기
- `signUpForm` 컴포넌트에서 `passwordSuccessHandler`를 `onSuccess`라는 이름으로 내려줌
- `PasswordInput`에서 `onSuccess` 함수 실행 시, `passwordSuccessHandler`가 실행됨
```jsx
// signUpForm.jsx
return (
  // ...
  {step === 3 && <PasswordInput onSuccess={passwordSuccessHandler} />}
  // ...
);
```

2. 회원가입 완료 버튼 가시화
- `PasswordInput`에서 입력이 패턴검증을 통과할 경우 `onSuccess(true, newPassword);` 실행
- 패턴검증에 실패할 경우 `onSuccess(false, newPassword);` 실행
- 따라서 회원가입 완료 버튼은 패턴검증 통과 여부에 따라 동적으로 가시화 됨
```jsx
// 패스워드 입력이 끝날 때 호출될 함수
const passwordSuccessHandler = (isValid, password) => {
  setEnteredPassword(password);
  // 회원가입버튼을 열어줄지 여부
  setIsActiveButton(isValid);
};

return (
  // ...
  {
    isActiveButton &&
    <div>
      <button onClick={handleSubmit}>회원가입 완료</button>
    </div>
  }
  // ...
);
```

3. `handleSubmit`: 완료 버튼 클릭 이벤트 핸들러 함수
- `navigate` 회원가입 완료 후, 사용자를 메인 페이지로 리디렉션

```jsx
// 회원가입 완료 이벤트
const handleSubmit = e => {
  e.preventDefault();

  (async () => {
    const response = await fetch(`${AUTH_API_URL}/join`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        email: enteredEmail,
        password: enteredPassword
      })
    });

    if (!response.ok) throw new Error('회원가입에 실패했습니다.');

    const data = await response.json();
    alert(data.message);
    navigate('/');

  })();
};
```

---

## [BE] 회원가입 마무리 처리
- 회원가입 완료 버튼을 누른 사용자는 이미 임시로 회원가입 되어있음
- 백엔드에서는 이메일과 패스워드를 받고
- 임시 회원가입된 회원의 패스워드와 생성시간을 채워넣으면 끝
- `EventUser` 엔티티에는 `confirm` 편의 메서드(비밀번호, 생성시간 채워넣기) 생성
```java
// EventUserService.java
public void confirmSignup(SignupRequest dto) {

    // 임시 회원가입된 회원정보를 조회
    EventUser foundUser = eventUserRepository.findByEmail(dto.email()).orElseThrow(
            () -> new RuntimeException("임시 회원가입된 정보가 없습니다.")
    );

    // 이메일 인증을 받았는지 확인
    if (!foundUser.isEmailVerified()) {
        throw new RuntimeException("이메일 인증이 완료되지 않은 회원입니다.");
    }
    
    // 데이터베이스에 임시 회원가입된 회원정보의 패스워드와 생성시간을 채워넣기
    foundUser.confirm(dto.password());
    eventUserRepository.save(foundUser);
}

// EventUser.java
public class EventUser {
    // ...
    public void confirm(String password) {
        this.password = password;
        this.createdAt = LocalDateTime.now();
    }
}
```

---

## [BE] 패스워드 암호화 처리
- 현재 DB에 패스워드가 그대로 들어가고 있음
- 보안에 심각한 문제이므로 해시 암호화 필요

1. 비밀번호 해시 암호화를 위해 의존성 추가
```groovy
// 스프링 시큐리티 모듈
implementation 'org.springframework.boot:spring-boot-starter-security'
```

2. Spring Security 비밀번호 암호화 설정 파일 생성(`PasswordEncoderConfig`)
- 비밀번호를 암호화하는 핵심적인 구성 요소를 설정
- `BCryptPasswordEncoder`를 빈으로 등록
- 이 코드가 없으면 비밀번호를 직접 암호화하는 코드를 매번 작성

```java
@Configuration
public class PasswordEncoderConfig {
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

3. 비밀번호 암호화하여 DB에 저장
- `passwordEncoder`를 통해 비밀번호 문자열을 해시 암호화
```java
// EventUserService.java
private final PasswordEncoder passwordEncoder;

public void confirmSignup(SignupRequest dto) {

    // ...
    // 데이터베이스에 임시 회원가입된 회원정보의 패스워드와 생성시간을 채워넣기
    foundUser.confirm(passwordEncoder.encode(dto.password()));
    eventUserRepository.save(foundUser);
}
```

---

## [BE] 로그인 검증

1. 로그인 검증 API
- `GET` 요청은 사용자 정보가 노출될 가능성이 있으므로 `POST` 요청으로 진행
- 프론트에서 이메일과 비밀번호를 JSON 형식으로 변환
- JSON을 HTTP 요청의 body에 담아 백엔드와 통신
- Request DTO인 `LoginRequest`와 정확히 동일한 형식의 JSON을 받아야 함
// - payload 객체를 JSON 형식으로 변환하여 HTTP 요청의 body에 담아 백엔드와 통신

```java
// LoginRequest.java
public record LoginRequest(
        String email,
        String password
) {
}

// AuthController.java
public class AuthController {
    // ...
    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequest dto) {

        try {
            return ResponseEntity.ok().body(eventUserService.authenticate(dto));
        } catch (RuntimeException e) {
            return ResponseEntity.status(422).body(Map.of(
                    "message", e.getMessage()
            ));
        }
    }
}
```

2. 로그인 검증 로직
- 적절한 에러 처리 필요
- `passwordEncoder.matches()` 메서드를 사용하여
- 사용자가 입력한 비밀번호(`dto.password()`)와
- DB에 저장된 암호화된 비밀번호(`foundUser.getPassword()`)가 일치하는지 확인

```java
// EventUserService.java
public class EventUserService {
    // ...
    public void authenticate(LoginRequest dto) {

        // 이메일을 통해 회원가입 여부 확인
        EventUser foundUser
                = eventUserRepository.findByEmail(dto.email()).orElseThrow(
                () -> new RuntimeException("가입된 회원이 아닙니다.")
        );

        // 회원가입을 중단한 회원에 대해서
        if (!foundUser.isEmailVerified() || foundUser.getPassword() == null) {
            throw new RuntimeException("회원가입이 완료되지 않은 회원입니다. 다시 가입해주세요.");
        }
        // 패스워드 일치 검사
        if (!passwordEncoder.matches(dto.password(), foundUser.getPassword())) {
            throw new RuntimeException("비밀번호가 틀렸습니다.");
        }
        
    }
}
```

3. 로그인 검증 후 성공하면 토큰 발급

JWT 관련 의존성 추가
```groovy
implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'
runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5'
```

```java
// EventUserService.java
public class EventUserService {
    // ...
    public Map<String, Object> authenticate(LoginRequest dto) {
        
        // ... 회원가입, 회원가입 중단 여부, 패스워드 일치 검사
        
        // 로그인 성공 - 토큰 발급
        String accessToken = tokenProvider.createAccessToken(dto.email());

        return Map.of(
                "token", accessToken,
                "message", "로그인에 성공했습니다.",
                "email", dto.email(),
                "role", foundUser.getRole().toString()
        );
    }
}
```

---

## [FE] 로그인 요청

1. 라우터의 페이지에 액션 함수 설정
- `WelcomePage` 안에 있는 `Form`이 `method="post"`로 제출되면 `loginAction`이 호출됨
```jsx
// route-config.jsx

const router = createBrowserRouter([
  {
    path: '/',
    element: <RootLayout />,
    // ...
    children: [
      {
        path: '',
        element: <HomeLayout />,
        children: [
          {
            index: true,
            element: <WelcomePage />,
            action: loginAction
          },
          // ...
        ]
      },
      // ...
    ]
  },
]);
```

2. 액션함수 아웃소싱
- `GET` 요청으로 진행하면 정보 유출의 위험이 있기 때문에 `POST`로 요청
- `request.formData()`: 폼에 입력한 값 가져오기
- `request.method`: 어떤 요청을 했는지
- `redirect()`: React Router가 제공하며, `action` 또는 `loader` 함수 내에서 `return`하면 원하는 페이지로 이동
- `action` 함수를 처리하는 컴포넌트는 `useActionData`라는 훅으로 리턴 데이터 사용 가능
```js
// 로그인 처리 액션함수
export const loginAction = async ({ request }) => {

  // 입력데이터 읽기
  const formData = await request.formData();

  const payload = {
    email: formData.get('email'),
    password: formData.get('password'),
  };

  const response = await fetch(`${AUTH_API_URL}/login`, {
    method: 'POST',
    headers: { 'Content-Type':'application/json' },
    body: JSON.stringify(payload)
  });

  const data = await response.json();
  
  // 오류가 발생한 경우
  if (response.status === 422) {
    // 서버에서 응답한 데이터를 컴포넌트에서 가져다 사용할 수 있게 데이터를 리턴.
    return data.message;
  }

  // 로그인에 성공했을 때 - 토큰을 저장
  localStorage.setItem('userData', JSON.stringify(data));

  return redirect('/');
};
```

3. `WelcomePage` 내부의 `LoginForm`
- `useActionData()`를 사용해서 action 함수가 리턴한 데이터 가져옴
- 리턴한 데이터를 이용해서 동적으로 오류 메시지 출력
```jsx
// LoginForm.jsx
const LoginForm = () => {
  
  const error = useActionData();

  return (
    <>
      <Form
        method="post"
        className={styles.form}>
        <h1>Log in</h1>
        <p>
          <label htmlFor="email">Email</label>
          <input
            id="email"
            type="email"
            name="email"
            required
          />
        </p>
        <p>
          <label htmlFor="password">Password</label>
          <input
            id="password"
            type="password"
            name="password"
            required
          />
        </p>
        <div className={styles.actions}>
          <button
            type="submit"
            className={styles.loginButton}>
            Login
          </button>
        </div>

        {error && <p className={styles.error}>{error}</p>}
        
      </Form>
    </>
  );
};
```

---




액션 함수는 여러개 못 걸음
-> 로그아웃을 하는 라우트를 새로 만들음


// 하위 컴포넌트에는 바로 전달 가능
loader: userDataLoader,
// loader의 리턴데이터는 children(Outlet)들에게는 전달되지 않는게 기본
// 그런데 id를 주면 Children들이 id로 가져갈 수 있음
id: 'user-token-data'

// 상위 레이아웃이 가지고 있는 로더의 데이터를 불러올 때는 id를 사용
const userData = useLoaderData('user-token-data');
