# 🗓️ 2025년 9월 11일 TIL

## 📌 오늘의 키워드
- 구글 소셜 로그인
- OAuth2 / CustomOAuth2UserService
- OAuth2SuccessHandler
- Access Token / Refresh Token
- 쿠키 동작 (HttpOnly, SameSite, Domain/Path)
- 토큰 재발급 / 로그아웃
- 라우트 가드 (loginLoader)
- Axios vs Fetch
- React Router (replace 옵션)
- Access Token 자동 갱신

---

## 🚀 구글 소셜 로그인 설정
1. 구글 클라우드 → 콘솔 접속 → 새 프로젝트 생성
2. API 및 서비스 → **OAuth 동의 화면** 설정
3. API 및 서비스 → 사용자 인증 정보 → **OAuth 클라이언트 ID** 발급
    - 유형: 웹 애플리케이션
    - 승인된 리디렉션 URI: `http://localhost:9005/login/oauth2/code/google`
    - 생성후 ID, 시크릿 메모!!
4. API 및 서비스 → OAuth 동의 화면 → 왼쪽 데이터 액세스 → 범위 추가 (`email`, `profile`, `openid`)

---

## 🛠️ OAuth2 & CustomOAuth2UserService
- OAuth2는 사용자 정보를 로드 후, 우리 서비스 사용자와 동기화
- `registrationId` 로 어떤 provider(구글, 카카오 등)인지 식별

```java
// 신규 로그인 vs 기존 로그인 확인
Optional<User> existing = userRepository.findByProviderAndProviderId(provider, providerId);

User user = existing.map(u -> {
    // 프로필 이미지 업데이트
    u.updateProfile(nickname, profileImageUrl);
    // 기존 사용자가 placeholder 이메일 상태이고, 이후 실제 이메일을 가져오게 된 경우 교체
    u.updateEmailIfPlaceholder(effectiveEmail, "@kakao.local");
    return u;
}).orElseGet(() -> User.builder()
        .email(effectiveEmail)
        .nickname(nickname)
        .profileImageUrl(profileImageUrl)
        .provider(provider)
        .providerId(providerId)
        .build());

userRepository.save(user);
````

---

## 🍪 OAuth2 로그인과 쿠키 동작

## 1. OAuth2SuccessHandler 역할

- 소셜 로그인(구글, 카카오 등) 성공 시 실행됨
- 액세스 토큰 / 리프레시 토큰 생성
- 토큰을 **쿠키(Cookie)** 에 담아 `response.addCookie()` 또는 `response.setHeader("Set-Cookie", ...)` 로 클라이언트에 전달

### 2. 쿠키 저장 과정
- 서버가 응답을 내려줄 때, **HTTP Response Header** 에 `Set-Cookie` 가 추가됨
- 예시:

```
HTTP/1.1 302 Found
Location: [http://localhost:3000/home](http://localhost:3000/home)
Set-Cookie: accessToken=abcd1234; Path=/; HttpOnly; Secure; SameSite=None
Set-Cookie: refreshToken=efgh5678; Path=/; HttpOnly; Secure; SameSite=None
```
- 브라우저는 이 헤더를 보고 **자동으로 쿠키를 저장**

### 3. 프론트엔드 리다이렉트

1. 서버 → `response.sendRedirect("http://localhost:3000/home")`
2. 브라우저가 `Set-Cookie` 해석 후 저장
3. 이후 요청 시, 도메인/경로 조건에 맞으면 자동 포함

### 4. 쿠키 자동 적용 조건

- **Domain/Path**: 프론트와 백엔드가 다른 도메인/포트면 공유 불가 → 프록시 설정 또는 `Domain` 값 지정 필요
- **SameSite 속성**: 기본값 `Lax` → cross-site 요청엔 쿠키 안 붙음  
  → 해결: `SameSite=None; Secure`
- **HttpOnly**: JS 코드(document.cookie)로 접근 불가  
  → 대신 브라우저가 자동으로 요청에 포함시킴 (보안 강화 목적)

✅ 요약: 서버에서 `Set-Cookie` 내려주면 브라우저가 자동 저장 & 적용

---

## 🔄 토큰 재발급

* `POST /api/auth/refresh`
  → Refresh Token 검증 후 새 Access Token 쿠키 내려줌
* `ResponseEntity.noContent().build()` (204 No Content) 가능
* 바디/헤더 X → **HttpOnly 쿠키 기반 처리**

---

## 🚪 로그아웃

* 쿠키 삭제 요청 전송
* 쿠키 수명을 `0` 으로 설정하면 삭제됨

---

## 🎛️ 프론트엔드 관련

* 소셜 로그인 버튼: `<a>` 태그 사용 (새 창 이동)
* Axios vs Fetch 차이
* **라우트 가드(loginLoader)** → 인증 여부 확인 후 페이지 접근 제어

```js
// 예시: 로그인 로더
export const loginLoader = async () => {
  try {
    const res = await apiClient.get('/users/me');
    if (res?.data?.success) {
      return redirect('/app');
    }
  } catch (_) {
    // 미인증이면 그대로 진행
  }
  return null;
};
```

---

## ✨ JS/리액트 팁

* `!!` 연산자 → 값의 truthy/falsy 판별

    * `!!0 → false`, `!0 → true`
* `navigate('/', { replace: true })`
  → 로그아웃 후 뒤로가기 방지 (히스토리 교체)
  → 히스토리 스택의 마지막(즉, 현재 페이지)을 새로운 경로로 "대체"

```js
const handleLogout = async () => {
  await logout();
  navigate('/', { replace: true });
};
```

---

## 🔄 Access Token 자동 갱신 플로우

1. API 요청 → Access Token 만료 시 `401 Unauthorized`
2. Refresh Token 으로 새 Access Token 발급
3. 새 Access Token 으로 실패했던 요청 재시도
4. 사용자는 끊김 없이 서비스 이용 가능

---

## 📌 오늘의 요약
- 구글 OAuth2 로그인 과정을 직접 설정해보고, **CustomOAuth2UserService** 를 통해 신규/기존 사용자를 처리하는 로직을 이해했다.
- 로그인 성공 시, **SuccessHandler** 에서 Access/Refresh Token을 발급해 쿠키에 저장하고, 쿠키는 **Set-Cookie 헤더**로 브라우저에 전달된 후 자동으로 저장됨을 확인했다.
- 쿠키는 도메인/경로, SameSite, HttpOnly 속성에 따라 브라우저에 의해 자동 전송되는 조건이 달라진다.
- 토큰 재발급은 **/api/auth/refresh** API를 통해 진행하며, HttpOnly 쿠키 기반으로만 처리한다.
- 로그아웃은 쿠키 수명을 `0`으로 설정하여 삭제 처리한다.
- 프론트엔드에서는 **라우트 가드(loginLoader)** 를 통해 인증 여부를 체크하고, `replace: true` 옵션으로 로그아웃 시 뒤로가기 방지를 구현했다.
- Access Token 만료 시 Refresh Token을 이용해 자동으로 새 토큰을 발급받고, 사용자가 끊김 없이 서비스를 이어갈 수 있는 **자동 갱신 플로우**를 학습했다.

