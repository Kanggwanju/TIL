# 🗓️ 2025년 9월 11일 TIL



## 구글 소셜 로그인

1. 구글 클라우드 접속

2. 콘솔 - 프로젝트 선택 - 우측 상단의 새 프로젝트 - 고유한 프로젝트 이름 설정 - 만들기

3. 프로젝트 선택하고, 왼쪽 메뉴 네비게이션 - API 및 서비스 - OAuth 동의 화면

4. 시작하기 누르고 프로젝트 구성 완료하기

5. API 및 서비스 - 사용자 인증 정보 - 사용자 인증 정보 만들기 - OAuth 클라이언트 ID 선택

6. 애플리케이션 유형(웹 애플리케이션) - 이름은 자유 - 승인된 리디렉션 URI 설정(http://localhost:9005/login/oauth2/code/google) - 생성후 ID, 시크릿 메모하기!! 

7. API 및 서비스 - OAuth 동의 화면 클릭, 왼쪽 데이터 액세스 클릭 - 범위 추가 - 이메일, 프로필, openid 설정


OAuth2 
- 사용자 정보를 로드하고 우리 도메인 사용자로 동기화하는 서비스

CustomOAuth2UserService.java

구글, 카카오가 가지고 있는 프로바이더 식별자
registrationId를 통해 구글인지 카카오인지 식별

```java
// 얘가 신규 로그인이냐 기존 로그인인지 판단
Optional<User> existing = userRepository.findByProviderAndProviderId(provider, providerId);

User user = existing.map(u -> {
    // 프로필 이미지 업데이트
    u.updateProfile(nickname, profileImageUrl);
    // 기존 사용자가 placeholder 이메일 상태이고, 이후 실제 이메일을 가져오게 된 경우 교체
    u.updateEmailIfPlaceholder(effectiveEmail, "@kakao.local");
    return u;
}).orElseGet(() -> User.builder()
        .email(effectiveEmail)
        .nickname(nickname)
        .profileImageUrl(profileImageUrl)
        .provider(provider)
        .providerId(providerId)
        .build());

userRepository.save(user);
```

---


토큰 발급, 쿠키 (서비스 이용)

쿠키는 두개, 각각의 쿠키에 Access 토큰, refresh 토큰을 넣어서 보냄
각각의 토큰은 수명이 다름.

로그인 성공했을때 보낼 주소: 홈
로그인 실패했을때 보낼 주소: 프론트쪽 에러 페이지 or 기타


# 🍪 OAuth2 로그인과 쿠키 동작 방식 정리

## 1. OAuth2SuccessHandler 역할
- 소셜 로그인(구글, 카카오 등) 성공 시 실행됨
- 액세스 토큰 / 리프레시 토큰 생성
- 토큰을 **쿠키(Cookie)** 에 담아 `response.addCookie()` 또는 `response.setHeader("Set-Cookie", ...)` 로 클라이언트에 전달

---

## 2. 쿠키는 어디에 끼워지는가?
- 서버가 응답을 내려줄 때, **HTTP Response Header** 에 `Set-Cookie` 가 추가됨
- 예시:

```
HTTP/1.1 302 Found
Location: [http://localhost:3000/home](http://localhost:3000/home)
Set-Cookie: accessToken=abcd1234; Path=/; HttpOnly; Secure; SameSite=None
Set-Cookie: refreshToken=efgh5678; Path=/; HttpOnly; Secure; SameSite=None
```
- 브라우저는 이 헤더를 보고 **자동으로 쿠키를 저장**

---

## 3. 프론트엔드로 리다이렉트 시 쿠키 동작
1. SuccessHandler → `response.sendRedirect("http://localhost:3000/home")`
2. 브라우저가 `Set-Cookie` 헤더를 해석하여 쿠키를 저장
3. 리다이렉트된 프론트엔드 페이지에서, 해당 도메인/경로 규칙에 맞으면 쿠키가 자동 포함됨

---

## 4. 우리가 보낸 쿠키가 자동 적용되는가?
✅ 자동 적용 (수동으로 할 필요 없음)

단, 조건이 맞아야 한다:
- **Domain/Path**: 프론트와 백엔드가 다른 도메인/포트면 공유 불가 → 프록시 설정 또는 `Domain` 값 지정 필요
- **SameSite 속성**: 기본값 `Lax` → cross-site 요청엔 쿠키 안 붙음  
→ 해결: `SameSite=None; Secure`
- **HttpOnly**: JS 코드(document.cookie)로 접근 불가  
→ 대신 브라우저가 자동으로 요청에 포함시킴 (보안 강화 목적)

---

## ✅ 최종 정리
- 서버에서 `Set-Cookie` 로 쿠키를 내려주면 브라우저가 자동 저장
- 프론트 리다이렉트 시에도 브라우저가 쿠키를 가지고 움직임
- 개발 시 자주 겪는 문제: `SameSite=None; Secure` 옵션 누락, 도메인/포트 불일치




---

토큰 재발급은 API 컨트롤러로 진행
* - /api/auth/refresh: 쿠키의 Refresh Token을 검증하고 새 Access Token 쿠키를 내려줍니다.
* - 이 컨트롤러는 HTTP-Only 쿠키 기반 재발급만 담당하며, 바디/헤더로 토큰을 주고받지 않습니다.

아래는 .ok()로 진행해도 무방
return ResponseEntity.noContent().build(); // 204 No Content 반환

---

로그아웃은 이제 로컬 스토리지만 관여하는게 아니라 쿠키를 삭제하는 요청 실시
쿠키의 수명을 0으로 설정하면 쿠키가 삭제됨

---

구글 로그인, 카카오 로그인 버튼을 눌렀을 때 새 창으로 가는 태그는 a 태그 사용

---

axios와 fetch 차이
라우트에 로더 함수로 설정하여 라우트가드
로그인이 되어있으면 로그인 화면으로 못감

```js
export const loginLoader = async () => {
  try {
    const res = await apiClient.get('/users/me');
    console.log('res: ', res.data?.data);

    if (res?.data?.success) {
      return redirect('/app');
    }
  } catch (_) {
    // 미인증이면 그대로 진행
  }
  return null;
};
```

```js
export const loginLoader = async () => {
  try {
    const res = await fetch('/api/users/me');
    console.log('res: ', res);
    const data = await res.json();
    console.log('data: ', data?.data);
    
    if (res?.data?.success) {
      return redirect('/app');
    }
  } catch (_) {
    // 미인증이면 그대로 진행
  }
  return null;
};
```

---

!! 사용 (논리값으로 변경시키기)
0 -> false (`falsy` 임.)
!0 -> true
!!0 -> false

---

replace: true 옵션은 navigate 함수가 현재 히스토리 스택의 마지막(즉, 현재 페이지)을 새로운 경로로 "대체"하도록 만듭니다.
즉, 뒤로가기를 눌렀을 때 로그아웃 전 페이지로 돌아가지 않게 하려면 replace: true를 사용합니다.

```js
// 주스탄드 전역 상태관리
const { isAuthenticated, user, logout } = useAuthStore();

const handleLogout = async () => {
  await logout();
  navigate('/', { replace: true });
};
```

---

아주 쉽게 보는 "Access Token 자동 갱신" 이야기

1) 우리가 서버에 요청을 보냈는데, Access Token 이 만료되면 401(인증 실패)이 와요.
2) 그러면 Refresh Token 으로 "새로운 Access Token"을 받아옵니다.
3) 새 Access Token 을 받으면, 방금 실패했던 요청을 그대로 다시 보내요.
4) 사용자는 서비스가 끊기지 않고 자연스럽게 이어집니다.










