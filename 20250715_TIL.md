# 🗓️ 2025년 7월 15일 TIL



REST API 개발

RESTful 서비스
정의
- REST는 자원을 기반으로 한 아키텍처 스타일로, 자원의 상태를 표현하고 전송하는 방법
- RESTful 서비스는 REST의 원칙을 준수하여 설계된 웹 서비스

REST의 6가지 원칙
1. 클라이언트-서버
- 클라이언트는 UI 담당, 서버는 데이터와 로직 처리
- 클라이언트와 서버는 독립적으로 동작
2. 스테이트리스(Stateless)
- 서버는 클라이언트의 상태를 유지하지 않음
- 각 요청은 필요한 모든 정보를 포함하여 독립적으로 처리
3. 캐시 가능(Cacheable)
- 클라이언트는 서버 응답을 캐싱하여 성능을 향상시킬 수 있음
- HTTP 헤더를 사용하여 응답이 캐시 가능한지 명시
4. 계층화 시스템
- 클라이언트는 서버에 직접 접근 x, 프록시나 로드 밸런서 같은 중간 계층을 통해 서버와 통신
5. 통합 인터페이스
- RESTful 서비스는 동일한 URI 형식과 HTTP 메서드를 사용하여 일관된 인터페이스를 제공
6. 코드 온 디맨드(Optional)
- 필요에 따라 서버에서 클라이언트로 실행 가능한 코드를 전송할 수 있습니다. (예: JavaScript)

RESTful 서비스의 장점

1. **확장성**: 클라이언트와 서버의 독립성을 유지하여 확장이 용이
2. **유연성**: 다양한 플랫폼에서 활용 가능하며, 언어나 기술에 종속되지 않음
3. **성능 향상**: 캐시를 통한 성능 최적화가 가능
4. **일관성**: 표준 HTTP 메서드와 URI 설계를 따름으로써 이해하기 쉬움


RESTful 요청 처리
@RestController 애노테이션
- Spring에서 RESTful 서비스를 구현하기 위해 사용되는 애노테이션
- @Controller과 달리 @ResponseBody가 기본적으로 포함
- 메서드의 반환 값을 JSON, XML 등으로 직렬화하여 클라이언트에 전송
- 주로 API 개발에 사용되며, HTML 뷰를 반환하지 않음


요청 데이터 처리 (@RequestBody)

- **@RequestBody**는 클라이언트로부터 전달된 **HTTP 요청 바디**를 메서드의 파라미터로 매핑
- 주로 JSON, XML과 같은 데이터를 객체로 변환하여 사용
- **Jackson 라이브러리**를 사용하여 JSON 데이터를 Java 객체로 자동 변환

JSON 요청 바디 읽기
서버에서 처리하는 코드
```java
@PostMapping
public String join(@RequestBody Member member) {
    member.setUid(UUID.randomUUID().toString());
    memberStore.put(member.getUid(), member);
    return "새로운 멤버 생성 - 닉네임: " + member.getNickname();
}
```

JSON 요청 예시:
Rest api 테스트
콘솔창 이용하여 join api 테스트
```javascript
fetch('http://localhost:9000/api/v3-2/members', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({
        account: 'power1234',
        password: '9944',
        nickname: '호랑이'
    })
});
```

프로그램을 이용하여 api 테스트
Postman 다운로드
collection 생성
Add request 생성
HTTP 요청 메서드 정하기
이후 메서드에 따라 행동


RESTful 응답 처리
- 클라이언트가 요청한 데이터를 적절한 형식과 상태 코드로 반환하는 과정

1. JSON 응답 반환 (@ResponseBody)
- 메서드의 반환 값을 HTTP 응답 본문(body)으로 직렬화하여 반환
- 일반적으로 객체를 JSON 형태로 변환하여 클라이언트에 응답할 때 사용
- Spring Boot는 기본적으로 Jackson 라이브러리를 사용하여 객체를 JSON으로 변환

2. HTTP 상태 코드 처리
- Spring MVC는 기본적으로 HTTP 상태 코드 200(OK)을 반환
- 다른 상태 코드를 반환하려면 ResponseEntity 사용

3. ResponseEntity를 사용한 응답
- ResponseEntity는 HTTP 응답 전체(상태 코드, 헤더, 본문)를 제어할 수 있는 유연한 객체


ResponseEntity 사용 예시 코드
```java
@GetMapping
public ResponseEntity<?> list() {

        /*try {
            String str = null;
            str.charAt(0);
        } catch (Exception e) {
            return ResponseEntity
                .internalServerError()
                .body("서버측 에러입니다 ㅈㅅ");
        }*/

    HttpHeaders httpHeaders = new HttpHeaders();
    httpHeaders.add("my-pet", "cat");
    httpHeaders.add("hobby", "baseball");


    return ResponseEntity
        .ok()
        .headers(httpHeaders)
        .body(new ArrayList<>(memberStore.values()));
}

```
주석 부분에서는 서버측 에러를 경험하기 위해
try 캐치로 억지로 에러를 발생시킴.
ResponseEntity가 제네릭인데 아래에서는 List 리턴,
에러 부분에선 String 리턴이므로 이런 경우에
제네릭의 타입에 ? 사용

HttpHeaders를 통해 전송 데이터의 응답 헤더에
데이터를 추가해서 전송할 수 있음
이 헤더의 데이터를 이용해서 추가 처리 가능













CORS 설정
- CORS: 한 도메인에서 실행 중인 웹 애플리케이션이 다른 도메인의 
리소스에 접근할 수 있도록 허용하는 메커니즘
- 브라우저의 보안 정책인 Same-Origin Policy로 인해 기본적으로 다른 도메인의 요청은 제한됨
- CORS는 서버에서 적절한 헤더를 설정하여 이러한 제한을 제어

같은 도메인이면 무조건 허용해주지만, 다른 도메인이면 CORS 설정을
통해 차단을 풀어줘야한다.

현재는 프론트, 백엔드가 같은 컴퓨터를 이용해서 진행하기 때문에
상관없지만, 실무에서는 무조건 다른 컴퓨터이기 때문에
풀어줘야함.

전역 크로스 오리진 설정 : 특정 클라이언트가 API를 사용하기 위한 정책 설정
@Configuration








JSP
오래된 기술로 간단한 서버 기반 렌더링에는 여전히
적합하지만, HTML과 Java 코드가 혼합되기 쉬워
관리가 어려울 수 있음.

클라이언트 사이드 렌더링
- 자바스크립트를 이용해서 서버로부터 데이터를 받고
- 그 데이터를 통해 html을 그려냄.
- 예시) 서버로부터 내부가 비어진 ul 태그 html을 받고,
- 자바스크립트로 데이터를 받아서 ul 태그 내부를 그려냄.

서버 사이드 렌더링
- 컨트롤러에서 데이터를 받아서 JSP 코드를 통해 화면을 그려냄.


Thymeleaf
서버사이드 HTML 템플릿 엔진
JSP를 대체 가능
뷰템플릿이 필요하면 사용

모던한 HTML5 템플릿 엔진으로, Spring Boot와의 긴밀한
통합과 유효 HTML 지원 덕분에 현재 더 많이 선호되는 기술

최근에는 백엔드와 프론트엔드를 분리시켜서
백엔드에서 JSON만 보내주고 클라이언트가 그려내는 추세이므로
JSP와 타임리프를 안 쓰고 리액트를 많이 쓰는 편이다. 

