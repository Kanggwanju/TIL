# 🗓️ 2025년 9월 2일 TIL


## **키워드 요약**

* **React Router:** `action` 함수, `loader` 함수, `Form` 컴포넌트, `useSubmit` 훅
* **Spring Boot:** QueryDSL, `Slice` 객체, 무한스크롤 구현

---

## **1. React Router `action` 함수**

* **정의**: 폼 제출이나 데이터 변경(`CUD`)을 처리하는 함수
* **역할**: 폼을 제출할 때 React Router가 폼 데이터를 자동으로 가로채서 전달
* **`loader` vs `action`**: `loader`는 데이터 읽기(`GET`), `action`은 데이터 변경(`CUD`)

### **주요 파라미터**

* `request`: 폼에 입력된 데이터, **HTTP 메서드** 등 요청에 대한 정보를 담는 객체
* `params`: URL 주소의 동적 세그먼트(예: `/:postId`) 값을 담는 객체

### **라우터 설정 (`route-config.jsx`)**

* `new` 경로에 `NewEventPage` 컴포넌트를 연결하고, 폼 제출 시 실행할 `saveAction` 함수를 `action` 속성에 지정
  ```jsx
  const router = createBrowserRouter([
    {
      path: 'new',
      element: <NewEventPage />,
      action: saveAction
    }
  ]);
  ```

---

### **`action` 함수 (`events-actions.js`)**

* `redirect` 함수를 사용해서 데이터 처리 후 페이지를 전환
* `request.formData()`: 폼에 입력한 값 가져오기
* `request.method`: 어떤 요청을 했는지
* `redirect()`: React Router가 제공하며, `action` 또는 `loader` 함수 내에서 `return`하면 원하는 페이지로 이동
  ```jsx
  import {redirect} from 'react-router-dom';

  export const saveAction = async ({ request }) => {
    const formData = await request.formData();
    const payload = { ... };

    const response = await fetch('http://localhost:9000/api/events', {
      method: request.method,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      throw new Error('이벤트 생성에 실패했습니다.');
    }

    return redirect('/events');
  };
  ```

---

### **폼 컴포넌트 (`EventForm.jsx`)**

* `Form` 컴포넌트: React Router가 제공하며, `action` 함수를 트리거하기 위해 사용
* `method` 속성: 필수 속성으로 HTTP 메서드 지정
* **버튼의 `type`**:
    * `Save` 버튼처럼 `type`을 명시하지 않으면 기본값은 `submit`이 되어 폼 제출 발생
    * `Cancel` 버튼처럼 `type="button"`으로 명시하면 폼 제출이 방지됨
      ```jsx
      <Form
        method='POST'
        className={styles.form}
        noValidate
      >
        <p>
          <label htmlFor='title'>Title</label>
          <input id='title' type='text' name='title' required />
        </p>
        <div className={styles.actions}>
          <button type='button'>Cancel</button>
          <button>Save</button>
        </div>
      </Form>
      ```

---

### **`useSubmit` 훅**

* `Form` 컴포넌트 없이 `action` 함수를 작동시키는 방법
* 주로 \*\*낙관적 업데이트(Optimistic UI)\*\*를 구현할 때 사용
* 사용자의 액션에 대한 서버 응답을 기다리지 않고 미리 UI를 업데이트하는 방식
* `submit(null, { method: 'DELETE' })`: `submit` 함수를 호출하여 `action`을 트리거
    * 첫 번째 파라미터: 폼 데이터. 필요 없을 경우 `null`
    * 두 번째 파라미터: 요청 정보

  ```jsx
  const submit = useSubmit();

  const deleteHandler = e => {
    submit(null, { method: 'DELETE' });
  };

  return (
    <article className={styles.event}>
      <menu className={styles.actions}>
        <Link to='edit'>Edit</Link>
        <button onClick={deleteHandler}>Delete</button>
      </menu>
    </article>
  );
  ```

---

## **2. Spring Boot QueryDSL 무한스크롤**

* **정의**: `Slice`를 이용해 백엔드에서 무한스크롤을 구현하는 로직
* **`Slice`**: `Page`와 다르게 전체 데이터의 총 개수를 알 필요 없이, 다음 페이지 존재 여부만 판단

### **핵심 원리**

* 서버는 실제로 가져갈 데이터보다 **1개 더 조회**하여 데이터의 끝을 확인
* `hasNext`: 다음 데이터가 있는지 여부를 나타내는 boolean 값

### **코드 분석 (`EventRepositoryImpl.java`)**

* `limit(pageable.getPageSize() + 1)`: 요청된 페이지 크기보다 1개 더 조회
* `if (eventList.size() > pageable.getPageSize())`: 조회된 데이터가 요청 개수보다 많으면 `hasNext`를 `true`로 설정
* `eventList.remove(eventList.size() - 1)`: 실제 반환할 데이터에서 불필요한 마지막 항목은 제거
* `return new SliceImpl<>(eventList, pageable, hasNext)`: `Slice` 객체 반환


```java
public class EventRepositoryImpl implements EventRepositoryCustom {

    private final JPAQueryFactory factory;

    @Override
    public Slice<Event> findEvents(Pageable pageable) {
        List<Event> eventList = factory
                .selectFrom(event)
                .orderBy(event.createdAt.desc())
                .offset(pageable.getOffset())
                .limit(pageable.getPageSize() + 1)
                .fetch();

        boolean hasNext = false;

        if (eventList.size() > pageable.getPageSize()) {
            hasNext = true;
            eventList.remove(eventList.size() - 1);
        }

        return new SliceImpl<>(eventList, pageable, hasNext);
    }
}
```
---

## ✅ 최종 정리
- React Router의 `action` 함수: 폼 제출 시 선언적으로 데이터를 변경(CUD)하는 방식
- `useSubmit` 훅: `Form` 없이 `action`을 호출해 낙관적 업데이트 구현에 활용
- Spring Boot `Slice`: 무한스크롤 구현 시 전체 개수 없이 다음 페이지 존재 여부만 확인하여 성능 최적화

