# 🗓️ 2025년 7월 16일 TIL

로그, 데이터 검증, Request DTO(Data Transfer Object), 입력값 검증(@Valid) 
,팩토리 메서드 패턴과 에러 메시지 커스텀 방법
,Response DTO와 응답 Json처리



로그의 기본 요소 - 감사, 모니터링, 재해복구
1. 로그 내용
2. 로그 레벨 - 중요도
- TRACE : 단순히 객체가 생성되거나, 함수가 호출되거나 하는 로그를 찍을 때
- DEBUG : 개발하면서 변수값을 추적하거나 디버깅 용도
- INFO : 운영서버의 일반적인 내용을 작성 (서버가 실행, 특정 핵심 요청이 들어오거나)
- WARN : 뭔가 이상이 생긴 경우, 다만 프로그램에 큰 위해는 아닌 경우
- ERROR : 커다란 예외가 발생하거나 프로그램에 치명적인 오류가 난 경우
- FATAL : 시스템 장애

3. 로그가 찍힌 시간
4. 로그가 찍힌 위치 (파일 경로)

application.properties에서 logging.level.root=로그레벨
을 해주면 설정한 로그 레벨 이상의 로그들이 보임.

우리 프로젝트는 DEBUG로 설정, 실무에서는 거의 DEBUG 이상의
로그만 씀.
logging.level.com.spring.basic=DEBUG

배포서버에서는 INFO로 변경
배포서버에서 로그 레벨을 INFO로 설정하는 이유는 
운영 환경에서의 안정성과 성능 최적화 때문

컨트롤러에 로그 라이브러리인 @Slf4j을 추가해줘야함
```java
// 전체 조회
@GetMapping
public ResponseEntity<?> memberList() {
    log.trace("memberList 메서드 호출됨");

    log.info("/api/v5-3/members : GET - 요청 시작!");

    List<Member> members = new ArrayList<>(memberStore.values());

    log.debug("member.size = {}", members.size());

    if (members.size() <= 0) {
        log.warn("회원 데이터가 없습니다.");
        return ResponseEntity.notFound().build();
    }

    log.debug("members[0].nickname = {}", members.get(0).getNickname());

    try {

    } catch (Exception e) {
        log.error("서버 에러입니다.");
        return ResponseEntity.internalServerError().body("서버 에러입니다.");
    }

    log.trace("memberList 메서드 호출 종료됨");
    return ResponseEntity
        .ok()
        .body(members);
}
```
---

데이터 검증과 Request DTO(Data Transfer Object)

# 📦 DTO(Data Transfer Object)란?

**DTO**는 "Data Transfer Object"의 약자로,
**계층 간(예: Controller ↔ Service ↔ Repository ↔ Frontend) 데이터를 주고받기 위한 객체**

쉽게 말하면,
👉 **데이터를 전달하기 위한 전용 상자**

---

## ✅ 왜 DTO를 사용할까? (사용 목적)

### 1. **Entity(도메인 객체)를 직접 노출하지 않기 위해**

* `Entity`는 DB와 연결된 중요한 비즈니스 객체임
* 직접 노출하면 보안 문제, 변경 불가, 유연성 저하 등의 문제가 발생함
* 그래서 **DTO를 통해 필요한 정보만 전달**하는 게 안전함

---

### 2. **필요한 데이터만 전달하기 위해**

* 예: `User` 엔티티에는 이름, 비밀번호, 주소, 생일 등 모든 정보가 있지만,
* 사용자 목록 조회 시에는 이름, 생일만 필요할 수도 있음
* DTO를 사용하면 **필요한 데이터만 골라서 담아 응답**할 수 있음

    * → 네트워크 효율 향상
    * → 민감한 정보 보호

---

### 3. **프론트엔드와 필드명이 다를 경우 대응하기 위해**

* 프론트에서는 `pwd`, 백엔드는 `password`를 사용하고 있을 수 있음.

```json
// 프론트 요청 예시
{
  "id": "panju123",
  "pwd": "1234"
}
```

```java
// DTO에서 필드명을 다르게 설정
public class UserRequestDTO {
    private String id;

    @JsonProperty("pwd") // JSON의 pwd → Java의 password로 매핑
    private String password;
}
```

* DTO에서는 `@JsonProperty`를 통해 이름이 달라도 **자유롭게 매핑 가능**
* 즉, **프론트와 협업 시 유연한 필드 처리**가 가능

---

### 4. **입력값 검증에 사용하기 위해**

* DTO는 사용자의 입력 값을 검증하는 데도 유용

```java
public class UserRequestDTO {

    @NotBlank
    private String username;

    @Email
    private String email;

    @Size(min = 8)
    private String password;
}
```

* `@Valid` 어노테이션과 함께 쓰면, 컨트롤러 단에서 자동으로 검증이 가능

---

### 5. **계층 간 의존성을 줄이기 위해**

* Entity를 직접 컨트롤러에 전달하거나 반환하게 되면,
  구조가 바뀔 때 **전체 코드에 영향을 주게 돼요**.
* DTO를 중간 계층에서 사용하면, **각 계층이 느슨하게 연결되어 유연성**이 생김.

---

## 🎯 실생활 비유

> 택배를 보낼 때, 집 안의 물건을 그대로 보내지 않고
> **필요한 물건만 안전하게 포장해서 박스에 담아 보내는 것**과 같음
> 이 박스가 바로 DTO

---

DTO의 장점
- **입력 데이터 캡슐화**: 요청 데이터를 명확하게 정의.
- **유효성 검증 분리**: 엔티티와 별도로 요청에 대한 데이터 검증 가능.
- **가독성 향상**: 코드가 더 명확하고 유지보수가 쉬워짐.

---

## 📌 정리: DTO를 사용하는 이유

| 목적           | 설명                         |
| ------------ | -------------------------- |
| 🔒 Entity 보호 | DB 구조가 외부에 노출되지 않도록 방지     |
| 🎯 데이터 필터링   | 필요한 데이터만 전달하고 응답에 포함       |
| 🔁 필드명 매핑    | 프론트와 백의 필드명이 다를 때 유연하게 매핑  |
| ✅ 입력값 검증     | DTO에 유효성 검사를 붙여 안전하게 처리    |
| 🔗 계층 분리     | 각 계층 간 결합도를 낮춰 구조를 유연하게 유지 |

---

@Valid 입력값 검증
에러 메시지 커스텀
아래 코드는 나중에 스프링을 통해 자동화 가능
```java
// 회원 생성
@PostMapping
public ResponseEntity<?> create(
        @RequestBody @Valid MemberCreateDto dto
        // 입력값 검증 오류 내용을 갖고있는 객체
        , BindingResult bindingResult
) {
    if (bindingResult.hasErrors()) { // 검증 결과 에러가 있다면
        Map<String, String> errorMap = new HashMap<>();
        bindingResult.getFieldErrors().forEach(err -> {
            errorMap.put(err.getField(), err.getDefaultMessage());
        });

        log.warn("회원가입 입력값 오류가 발생함!");
        return ResponseEntity.badRequest().body(errorMap);
    }
}
```
검증할 파리미터에 @Valid를 써줘야한다.

```java

public class MemberCreateDto {

    @Email(message = "계정명은 이메일 형식을 지켜주세요.")
    @NotBlank(message = "계정명은 필수입니다.")
    private String userAcc;

    @NotBlank(message = "비밀번호는 필수입니다.")
//    @Size(min = 8, message = "8자리 이상으로 작성하세요.")
    @Pattern(regexp = "^(?=.*[A-Z])(?=.*[0-9])(?=.*[a-z])(?=.*[!@#$%^&*()-+=]).{8,}$", message = "비밀번호는 특수문자와 숫자 영문을 포함해야 합니다.")
    private String pw;

    @NotBlank(message = "닉네임은 필수입니다.")
    private String nick;
    
    // DTO를 Entity로 변환하는 메서드
    // 정적 팩토리 메서드 패턴
    public static Member from(MemberCreateDto dto) {
        return Member.builder()
            .account(dto.getUserAcc())
            .password(dto.getPw())
            .nickname(dto.getNick())
            .build();
    }
}
```
정적 팩토리 메서드 패턴과 에러 메시지 커스텀 방법을 알 수 있었음
두개를 따로 풀어서 설명해줬으면 좋겠다.




Response DTO와 응답 Json처리

Response DTO
요청을 받을 때 Entity를 가져오면 필요없는 데이터까지
받음 그래서 DTO를 받아서 처리했음.
하지만 응답을 할 때도 Entity를 전송하면 중요한 데이터들을
클라이언트가 받게 되며, 보안상 문제가 된다.
그러므로 응답도 DTO를 만들어서 전송해줘야함.

1. MemberListResponse DTO 생성
클라이언트에게 멤버 목록을 보내줄 때 사용할 응답 DTO
```java 
@Getter @Setter
@ToString
@EqualsAndHashCode
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class MemberListResponse {
    private String id;
    private String email; // account에 대응
    private String nick; // 가운데 글자를 마스킹 (첫글자랑 마지막글자 빼고)

    // 엔터티를 전달받아서 dto로 변환하는 정적 팩토리 메서드
    public static MemberListResponse from(Member member) {
        return MemberListResponse.builder()
                .id(member.getUid())
                .email(member.getAccount())
                .nick(maskingNickName(member.getNickname()))
                .build();
    }
  
    private static String maskingNickName(String originNick) {
        return originNick.charAt(0) + "*" + originNick.charAt(originNick.length() - 1);
    }
}
```

2. 컨트롤러에서 DTO를 응답 데이터로 전송
- 전체 조회
```java
@GetMapping
public ResponseEntity<?> memberList() {
    log.trace("memberList 메서드 호출됨");
  
    log.info("/api/v5-3/members : GET - 요청 시작!");
  
    List<MemberListResponse> responses = memberStore.values()
            .stream()
            .map(m -> MemberListResponse.from(m))
            .collect(Collectors.toList());
  
    if (responses.size() <= 0) {
        log.warn("회원 데이터가 없습니다.");
        return ResponseEntity.notFound().build();
    }
  
    return ResponseEntity
            .ok()
            .body(responses);
}
```
마지막에는 직접 Member 리스트를 반환해주는게 아니라
MemberListResponse 리스트를 반환해준다.
이렇게 함으로써 직접 Entity를 반환하지 않고 DTO를 
전달할 수 있었다. 그리하여 보안이나 클라이언트가
필요하지 않는 정보를 전송하지 않을 수 있음.







응답 Json 처리

@JsonProperty
- 클래스 필드와 JSON 응답 데이터의 필드 이름을 다르게 설정할 때 사용.
```java
@JsonProperty("account")
private String email;
```

@JsonIgnore
- 특정 필드를 JSON 응답에서 제외.
- 민감한 정보(예: 비밀번호, 카드 번호 등)를 클라이언트로 보내지 않기 위해 사용.
```java
@JsonIgnore
private String cardNo;
```

@JsonFormat
- 날짜/시간 데이터를 JSON으로 변환할 때 특정 형식을 지정.
```java
@JsonFormat(pattern = "yyyy년 MM월 dd일")
private LocalDate creationTime;
```




