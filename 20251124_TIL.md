# 🗓️ 2025년 11월 24일 TIL - C언어

## 📌 오늘의 키워드

`구조체 (struct)` `typedef` `포인터` `동적 할당` `Call by Value` `Call by Reference` `-> 연산자`

---

## 1️⃣ 구조체의 개념

### 💡 개념 정리

* **구조체(Structure)** 는 **서로 다른 자료형을 하나의 단위로 묶은 사용자 정의 자료형**이다.
* 예를 들어 이름, 그룹, 출생년도 등 서로 다른 속성을 하나의 **아이돌 구조체**로 묶어 표현할 수 있다.
* 구조체는 새로운 "데이터 타입"처럼 사용할 수 있다.

---

## 2️⃣ 구조체 정의 및 사용

### 💻 예시 코드

```c
struct Idol {
    char name[20];
    char group[30];
    int birth_year;
};
```

### 📘 설명

* 구조체 내부의 변수들을 **멤버(Member)** 라고 부른다.
* 구조체 변수를 선언하면, 그 안의 멤버들이 메모리에 함께 생성된다.

```c
struct Idol yujin = {"안유진", "아이브", 2003};
```



### ✅ 멤버 접근

* 구조체 변수의 멤버에 접근할 때는 **점(.) 연산자**를 사용한다.

```c
printf("%s의 출생년도는 %d입니다.\n", yujin.name, yujin.birth_year);
```

---

## 3️⃣ typedef를 이용한 구조체 단순화

### 💡 typedef의 역할

* `struct` 키워드를 매번 쓰지 않기 위해 **별칭(alias)** 을 붙일 수 있다.

```c
typedef struct Idol IdolInfo;
typedef struct {
    char name[20];
    char group[30];
    int birth_year;
} IdolInformation;
```

이후에는 `struct Idol` 대신 `IdolInfo`만으로 구조체를 선언할 수 있다.

```c
IdolInfo chaewon = {"김채원", "르세라핌", 2000};
IdolInformation wonyoung = {"장원영", "아이브", 2004};
```



---

## 4️⃣ 구조체 포인터와 동적 할당

### 💡 개념

* 구조체도 `malloc()`을 이용해 **동적으로 생성**할 수 있다.
* 포인터를 통해 구조체 멤버에 접근할 때는 **화살표(->) 연산자**를 사용한다.

```c
IdolInfo* ptr_idol = (IdolInfo*) malloc(sizeof(IdolInfo));
strcpy(ptr_idol->name, "사쿠라");
strcpy(ptr_idol->group, "르세라핌");
ptr_idol->birth_year = 1998;
```

* 여러 개의 구조체를 한 번에 만들 때는 다음처럼 사용한다.

```c
int n = 5;
IdolInfo* ive_members = (IdolInfo*)malloc(n * sizeof(IdolInfo));
```

* 사용이 끝난 후에는 반드시 `free()`로 메모리 해제해야 한다.

```c
free(ptr_idol);
free(ive_members);
```



---

## 5️⃣ 구조체와 함수 전달 방식

### 💡 Call by Value vs Call by Reference

* **Call by Value**: 구조체 전체가 복사되어 전달되므로, 함수 내 수정이 원본에 반영되지 않는다.
* **Call by Reference**: 주소를 전달하므로, 함수 내에서 원본 데이터를 직접 수정할 수 있다.

### 💻 예시 코드

```c
void printIdolInfoV1(IdolInfo idol) {
    printf("%s (%s)\n", idol.name, idol.group);
    idol.birth_year = 3000; // 복사본만 변경됨
}

void printIdolInfoV2(IdolInfo* idol) {
    printf("%s (%s)\n", idol->name, idol->group);
    idol->birth_year = 3000; // 원본 변경됨
}
```



### 🧠 실행 결과 요약

| 함수 호출 방식 | 코드                         | 결과                     |
| -------- | -------------------------- | ---------------------- |
| 값 전달     | `printIdolInfoV1(karina)`  | 원본 `birth_year` 변하지 않음 |
| 참조 전달    | `printIdolInfoV2(&karina)` | 원본 `birth_year` 변경됨    |

---

## 🎯 최종 정리

| 개념      | 설명                       | 키 포인트                              |
| ------- | ------------------------ | ---------------------------------- |
| 구조체     | 여러 자료형을 묶은 사용자 정의 타입     | `.`, `typedef`                     |
| typedef | 구조체에 별칭 부여               | `typedef struct { ... } TypeName;` |
| 구조체 포인터 | 구조체 주소를 가리킴              | `->` 연산자로 접근                       |
| 동적 할당   | `malloc()`으로 구조체 생성      | `free()`로 해제                       |
| 함수 전달   | 값 전달 시 복사, 참조 전달 시 직접 수정 | 효율성 차이 있음                          |

---

## 💬 오늘의 소감

오늘은 구조체를 통해 **데이터를 하나의 논리 단위로 묶는 방법**을 배웠다.
특히 `typedef`와 `->` 연산자를 활용해 코드의 가독성을 높이고,
`malloc()`을 이용해 **동적 구조체를 생성**하는 과정이 인상 깊었다.
마지막으로 Call by Value와 Call by Reference의 차이를 직접 비교하며,
메모리 효율성과 함수 설계에 대해 한 단계 더 이해하게 되었다.
