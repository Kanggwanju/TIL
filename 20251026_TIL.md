# 🗓️ 2025년 10월 26일 TIL

## 오늘의 키워드
`WebSocket Disconnect 이벤트` `이벤트 기반 자동 퇴장` `리소스 정리` `커스텀 훅 리팩토링` `Janus WebRTC` `메모리 누수 방지`

---

## 배경

퀴즈 게임의 대기방과 게임 페이지에서 퇴장 로직을 구현하면서, 백엔드의 퇴장 처리 방식과 프론트엔드의 리소스 정리 패턴에 대해 학습했다. 특히 600줄이 넘는 대기방 컴포넌트를 리팩토링하고, 게임 페이지의 퇴장 로직을 완성하는 과정에서 여러 개념을 다뤘다.

---

## 핵심 개념

### 1. 이벤트 기반 자동 퇴장 처리

백엔드는 명시적인 퇴장 API(`/leave`, `/exit` 등)를 제공하지 않는다. 대신 WebSocket의 DISCONNECT 이벤트를 감지하여 자동으로 퇴장을 처리한다.

**처리 흐름**
```
클라이언트: disconnect() 호출
    ↓
WebSocket DISCONNECT 이벤트 발생
    ↓
WebSocketEventsListener가 이벤트 감지
    ↓
WebSocketSessionService에서 세션 검증 및 정리
    ↓
GameRoomLeaveService에서 방 퇴장 처리
    ↓
다른 참가자들에게 자동 알림 전송
```

**장점**
- 클라이언트는 단순히 `disconnect()`만 호출하면 된다
- 네트워크 장애, 브라우저 강제 종료 등 모든 경우를 자동 처리
- 트랜잭션 안전성이 보장된다
- 스테일 세션 방지 메커니즘이 내장되어 있다

### 2. 세션 관리와 스테일 세션

**활성 세션 검증**
백엔드는 퇴장 처리 전에 해당 세션이 활성 상태인지 검증한다. 이를 통해 오래된(stale) 세션의 DISCONNECT 이벤트는 무시하고, 현재 활성 세션만 처리한다.

```java
if (!isActiveSession(userId, sessionId)) {
    log.info("비활성 세션의 DISCONNECT 무시");
    return false;
}
```

이는 중복 처리를 방지하고, 재접속 시 이전 세션의 지연된 이벤트로 인한 문제를 막는다.

### 3. 방장 vs 일반 참가자 퇴장

**일반 참가자 퇴장**
- 참가자 정보만 DB에서 삭제
- 방의 현재 참가자 수 감소
- 게임 진행 중이면 캐시에서 해당 유저 제거
- `PARTICIPANT_LEFT` 이벤트 전송

**방장 퇴장 (방 종료)**
- 모든 참가자를 한 번의 쿼리로 Bulk Delete
- 방 상태를 `CLOSED`로 변경
- 남은 참가자들의 세션 일괄 정리
- `ROOM_CLOSED` 이벤트 전송

### 4. 게임 중 퇴장 처리

게임이 진행 중일 때 참가자가 퇴장하면 추가 작업이 필요하다.

**처리 내용**
- 캐시에서 해당 유저의 점수 제거
- 모든 문제(1~8)의 도전 순서에서 유저 제거
- 현재 도전 차례였다면 다음 도전자에게 자동 전환
- 다음 도전자에게 이벤트 전송

```java
// 현재 도전 차례인지 확인
Long currentChallenger = roomState.getCurrentChallenger(questionNumber);
boolean wasCurrentChallenger = userId.equals(currentChallenger);

// 도전 순서에서 제거
roomState.removeChallenger(questionNumber, userId);

// 도전 차례였다면 다음 도전자에게 넘김
if (wasCurrentChallenger) {
    Long nextChallenger = roomState.getNextChallenger(questionNumber);
}
```

### 5. 프론트엔드 리소스 정리 순서

퇴장 시 여러 리소스를 올바른 순서로 정리해야 메모리 누수를 방지할 수 있다.

**Janus WebRTC 정리 순서**
```
1. Remote feeds detach (원격 피드 해제)
2. Plugin handle detach (플러그인 핸들 해제)
3. Janus session destroy (Janus 세션 종료)
4. Refs 초기화
5. State 초기화
```

**게임 페이지 추가 정리 항목**
- 녹화 중단 (isRecordingRef.current = false)
- Animation frame 취소 (cancelAnimationFrame)
- FastAPI WebSocket 연결 해제
- 각종 플래그 초기화 (fastApiConnectedRef, metaSentRef 등)

### 6. 커스텀 훅을 통한 리팩토링

600줄이 넘는 단일 컴포넌트를 여러 커스텀 훅으로 분리하여 관심사를 분리한다.

**분리된 훅들**
- `useRoomExit`: 공통 퇴장 로직 (Janus, 웹캠, WebSocket 정리)
- `useWaitingRoom`: 상태 관리 (roomInfo, participants, allReady)
- `useWaitingWebSocket`: WebSocket 통신 및 이벤트 처리
- `useWaitingJanus`: Janus WebRTC 연결 및 스트림 관리

**장점**
- 로직별 응집도 증가
- 재사용성 향상 (대기방과 게임 페이지에서 useRoomExit 공유)
- 테스트 용이성 증가
- 가독성 개선

### 7. onBeforeExit 콜백 패턴

`useRoomExit` 훅은 페이지별 추가 정리 로직을 주입받을 수 있도록 설계한다.

```javascript
const { cleanupAndExit } = useRoomExit({
  janusRef,
  pluginHandleRef,
  // ... 기타 refs
  onBeforeExit: async () => {
    // 게임 페이지 전용 정리 로직
    if (isRecordingRef.current) {
      isRecordingRef.current = false;
      cancelAnimationFrame(recordingRef.current);
    }
    if (quizFastApi) {
      quizFastApi.disconnect();
    }
  },
  navigateTo: '/main',
});
```

이를 통해 공통 로직은 훅 내부에서 처리하고, 페이지별 특수 로직만 콜백으로 주입한다.

### 8. 에러 처리와 Graceful Degradation

각 정리 단계를 독립적인 try-catch로 감싸서, 한 단계가 실패해도 다음 단계가 계속 실행되도록 한다.

```javascript
try {
  // Janus 정리
} catch (error) {
  console.error('Janus 정리 실패:', error);
  // 계속 진행
}

try {
  // 웹캠 정리
} catch (error) {
  console.error('웹캠 정리 실패:', error);
  // 계속 진행
}

try {
  // WebSocket 해제
} catch (error) {
  console.error('WebSocket 해제 실패:', error);
}

// 최종적으로는 항상 페이지 이동
finally {
  navigate('/main');
}
```

최종 `finally` 블록에서 페이지 이동을 보장하여, 일부 정리가 실패해도 사용자가 페이지에 갇히지 않도록 한다.

---

## 구현 시 주의사항

### 잘못된 패턴
```javascript
// ❌ 명시적 퇴장 API 호출 시도 (존재하지 않음)
await websocketService.leaveRoom(roomId);
websocketService.sendMessage('/app/room/leave', {});

// ❌ 잘못된 Janus 정리 순서 (메모리 누수 발생)
janusRef.current.destroy();  // 세션 먼저 종료
remoteFeedsRef.current.forEach(feed => feed.detach()); // 실패
```

### 올바른 패턴
```javascript
// ✅ 단순히 disconnect만 호출
websocketService.disconnect();

// ✅ 올바른 Janus 정리 순서
// 1. Remote feeds detach
// 2. Plugin handle detach
// 3. Janus session destroy
```

---

## 성능 최적화

### useCallback 메모이제이션
퇴장 함수는 여러 곳에서 참조될 수 있으므로 `useCallback`으로 메모이제이션한다.

```javascript
const cleanupAndExit = useCallback(async () => {
  // 정리 로직
}, [dependencies]);
```

### 병렬 처리
독립적인 정리 작업은 병렬로 실행하여 시간을 단축한다.

```javascript
await Promise.all([
  cleanupJanus(),
  cleanupWebcam(),
  cleanupFastApi()
]);
```

### 비동기 타임아웃
Janus leave 요청에 타임아웃을 설정하여 응답 지연 시에도 진행한다.

```javascript
await new Promise((resolve) => {
  pluginHandleRef.current.send({ 
    message: { request: 'leave' },
    success: resolve,
    error: resolve
  });
  setTimeout(resolve, 500); // 500ms 타임아웃
});
```

---

## 리팩토링 효과

### 코드 품질
- 가독성: 600줄 → 150-200줄로 단순화
- 유지보수성: 로직 분리로 수정 용이
- 재사용성: 공통 훅으로 코드 재사용
- 테스트 용이성: 각 훅을 독립적으로 테스트 가능

### 사용자 경험
- 안정성: 리소스 누수 방지
- 응답성: 빠른 페이지 전환
- 일관성: 모든 페이지에서 동일한 퇴장 경험

### 개발 생산성
- 신규 기능 추가 용이
- 버그 수정 용이
- 코드 리뷰 용이

---

## 최종 정리

오늘 학습한 핵심은 다음과 같다.

**백엔드 관점**
- 이벤트 기반 자동 퇴장 처리가 명시적 API보다 강력하다
- WebSocket DISCONNECT 이벤트 하나로 모든 퇴장 시나리오를 커버할 수 있다
- 활성 세션 검증을 통해 스테일 세션 문제를 예방한다
- 방장 퇴장 시 Bulk Delete로 효율적으로 처리한다

**프론트엔드 관점**
- 리소스 정리는 올바른 순서가 중요하다 (Remote → Plugin → Session)
- 커스텀 훅으로 관심사를 분리하면 가독성과 재사용성이 증가한다
- 에러가 발생해도 사용자 경험이 깨지지 않도록 Graceful Degradation이 필요하다
- 콜백 패턴을 통해 공통 로직과 페이지별 로직을 분리할 수 있다

**설계 원칙**
- 단순함이 최고다 (프론트엔드는 disconnect만 호출)
- 자동화가 수동 처리보다 안전하다
- 작은 단위로 분리하면 관리가 쉽다
- 항상 최악의 경우를 대비한다 (네트워크 장애, 강제 종료 등)

이번 작업을 통해 WebSocket 기반 멀티플레이어 애플리케이션에서 퇴장 로직을 설계할 때 고려해야 할 점들을 깊이 이해하게 되었다.