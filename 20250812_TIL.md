# 🗓️ 2025년 8월 12일 TIL


QueryDsl 복습

1. 종속성 추가

```groovy
// QueryDSL
implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
annotationProcessor 'com.querydsl:querydsl-apt:5.0.0:jakarta'
annotationProcessor 'jakarta.annotation:jakarta.annotation-api:2.1.1'
annotationProcessor 'jakarta.persistence:jakarta.persistence-api:3.1.0'
```

---

2. QueryDSL 설정 클래스 추가
- JPAQueryFactory를 Spring Bean으로 등록하여 QueryDSL 사용을 위한 설정
```java
@Configuration
@RequiredArgsConstructor
public class QueryDslConfig {

    private final EntityManager entityManager;

    /**
     * JPAQueryFactory Bean 등록
     * QueryDSL을 사용하기 위한 핵심 컴포넌트
     */
    @Bean
    public JPAQueryFactory jpaQueryFactory() {
        return new JPAQueryFactory(entityManager);
    }
}
```
---

3. 기존에 존재하던 Jpa를 사용하는 TripRepository에
   인터페이스 `TripRepositoryCustom` 추가 extends

```java
public interface TripRepository extends JpaRepository<Trip, Long>, TripRepositoryCustom {
}
```

---

4. TripRepositoryCustom 인터페이스 구현
- QueryDSL과 Native Query등을 사용하는 메서드를 명세하는 인터페이스
```java
public interface TripRepositoryCustom {
    // 동적 쿼리로 검색 조건별 여행 목록 조회 메서드 (페이징 포함)
    Page<Trip> getTripList(User user, TripSearchCondition condition, Pageable pageable);
}
```

5. 검색 조건이 여러가지이므로, `TripSearchCondition` 객체로 관리
- 여행 검색 조건들을 담는 클래스
```java
@Getter
@Builder
public class TripSearchCondition {

    private TripStatus status; // 여행 상태로 검색
    private String destination; // 목적지로 검색
    private String title;       // 제목으로 검색

    // 정렬 조건
    @Builder.Default
    private String sortBy = "createdAt"; // createdAt, startDate, endDate, destination, title

    // 내림차 오름차 여부
    @Builder.Default
    private String sortDirection = "DESC"; // ASC, DESC
}
```

6. `TripRepositoryCustom`의 구현체 `TripRepositoryImpl`
- QueryDSL이나 JDBC 네이티브쿼리 자유롭게 사용가능
- 인터페이스에 있던 메서드를 오버라이딩

7. WHERE절 동적으로 만들기, `BooleanBuilder`
```java
BooleanBuilder whereClause = new BooleanBuilder();
whereClause.and(trip.user.eq(user));

// 나머지는 검색조건 동적으로 생성
// 1. 상태 검색
if (condition.getStatus() != null) {
    whereClause.and(trip.status.eq(condition.getStatus()));
}
// 2. 목적지 검색
if (condition.getDestination() != null && !condition.getDestination().trim().isEmpty()) {
    // contains - LIKE %?% ,  IgnoreCase LOWER()
    // AND destination LIKE LOWER('%검색어%')
    whereClause.and(trip.destination.containsIgnoreCase(condition.getDestination()));
}

// 3. 제목 검색
if (condition.getTitle() != null && !condition.getTitle().trim().isEmpty()) {
    whereClause.and(trip.title.containsIgnoreCase(condition.getTitle()));
}
```

8. 순서 지정자 `OrderSpecifier`
- 조건 객체를 파라미터로 넣어주면 그 안에서 
- 정렬 조건, 방향을 뽑아서 순서 지정자를 만들고 리턴

```java
private OrderSpecifier<?> getOrderSpecifier(TripSearchCondition condition) {
        // 정렬조건
        String sortBy = condition.getSortBy();
        // 정렬방향
        String sortDirection = condition.getSortDirection();
        OrderSpecifier<?> specifier;

        switch (sortBy.toLowerCase()) {
            case "startdate":
                specifier = sortDirection.equalsIgnoreCase("DESC")
                        ? trip.startDate.desc()
                        : trip.startDate.asc();
                break;
            // ...
            
            default:
                specifier = sortDirection.equalsIgnoreCase("DESC")
                        ? trip.createdAt.desc()
                        : trip.createdAt.asc();
                break;
        }

        return specifier;
    }
```

9. Pageable
- 역할: 클라이언트가 page, size, sort를 넘기면,
- 이를 한 덩어리로 담아 리포지토리까지 전달.
- 구현체: 보통 PageRequest.of(page, size, sort...) 를 사용


10. 7~9번을 이용하여 여행 목록 조회, 목록 개수 얻음
```java
List<Trip> tripList = factory
        .selectFrom(trip)
        .where(whereClause)
        .orderBy(getOrderSpecifier(condition))
        .offset(pageable.getOffset())
        .limit(pageable.getPageSize())
        .fetch();

Long totalCount = factory
        .select(trip.count())
        .from(trip)
        .where(whereClause)
        .fetchOne();
```

11. 최종 리턴 new PageImpl<>(tripList, pageable, totalCount);

* content = tripList
  → offset/limit(=pageable)와 정렬을 적용해서 이번 페이지에 담길 실제 데이터 목록

* pageable = pageable
  → 요청한 페이지 번호(page, 0부터), 페이지 크기(size), 정렬(sort) 정보를 담은 객체
  → PageImpl은 이걸 보고 메타데이터를 계산/채웁니다.

* total = totalCount (null이면 0)
  → 전체 레코드 수(조건을 모두 적용한 뒤의 총 개수).
  → totalPages, isLast, hasNext 계산의 근거가 됩니다.


















