# 🗓️ 2025년 9월 19일 TIL



Spring AI 문맥 유지

한도 끝도 없이 모든 맥락을 AI에게 제안할 수 없음
`토큰 제한` 때문.

토큰제한 (둘 모두 과금 대상)
- 입력 토큰
- 출력 토큰

문맥을 유지하기 위해서는 `입력 토큰`에 이전 질문과 현재 질문을 넣어줌

최소한의 문맥유지를 위해서 이전 질문을 얼마나 넣을지가 관건

이전 질문들을 요약해서 넣어주는 방법도 있음.
예) 이전 질문 10개 or 이전 질문들 30개 요약


`@Lob`
- 대용량 텍스트 or 이미지를 처리할 때에 좋은 아노테이션
```java
// 보낸 프롬프트(질문/요청)
@Lob
@Column(name = "prompt", nullable = false)
private String prompt;
```

이미지를 직접 DB에 저장하기보단 따로 파일서버에 두는 것을 추천



Spring AI 정식 버전을 이용하기 위해서
Spring 3.4 이상을 사용해야한다.
ai-study-mate에서는 스프링 버전을 낮게 잡아서 마일스톤 버젼으로 진행했음.


AI 요청 사용자 제한
```java
@Service
public class RateLimiterService {

    private static final int REQUESTS_PER_MINUTE = 3;
    private static final int REQUESTS_PER_DAY = 10;
    private static final int TOKENS_PER_DAY = 100000;

    private final Map<String, MinuteWindow> minuteWindows = new ConcurrentHashMap<>();
    private final Map<String, DayCounter> dayCounters = new ConcurrentHashMap<>();

    /**
     * 사용자별 요청 한도를 검사하고 사용량을 기록합니다.
     *
     * @return 허용되면 true, 한도 초과 시 false
     */
    public boolean tryConsume(String providerId, int estimatedTokens) {
        if (providerId == null || providerId.isBlank()) {
            return false;
        }
        // 각 메소드가 true를 반환해야만 전체 요청이 허용됩니다.
        boolean minuteOk = checkMinuteLimit(providerId);
        boolean dayOk = checkDayLimit(providerId, estimatedTokens);

        return minuteOk && dayOk;
    }

    /**
     * 분당 요청 한도를 검사하고 갱신합니다.
     */
    private boolean checkMinuteLimit(String providerId) {
        long nowMillis = System.currentTimeMillis();
        // 1. 사용자의 분당 카운터를 가져오거나, 없으면 새로 만듭니다.
        MinuteWindow window = minuteWindows.computeIfAbsent(providerId, k -> new MinuteWindow(nowMillis));

        // 2. 분이 바뀌었는지 확인하고, 바뀌었다면 카운터를 리셋합니다.
        if (!window.isSameMinute(nowMillis)) {
            window.reset(nowMillis);
        }
        // 3. 현재 카운터가 한도를 넘었는지 확인합니다.
        if (window.count.get() >= REQUESTS_PER_MINUTE) {
            return false; // 한도 초과!
        }
        // 4. 한도 내라면 카운터를 1 증가시키고 통과시킵니다.
        window.count.incrementAndGet();
        return true;
    }

    /**
     * 일일 요청 및 토큰 한도를 검사하고 갱신합니다.
     */
    private boolean checkDayLimit(String providerId, int estimatedTokens) {
        long nowMillis = System.currentTimeMillis();
        DayCounter day = dayCounters.computeIfAbsent(providerId, k -> new DayCounter(nowMillis));

        if (!day.isSameDay(nowMillis)) {
            day.reset(nowMillis);
        }
        if (day.requests.get() >= REQUESTS_PER_DAY) {
            return false; // 일일 요청 한도 초과!
        }
        if (day.tokens.get() + estimatedTokens > TOKENS_PER_DAY) {
            return false; // 일일 토큰 한도 초과!
        }
        day.requests.incrementAndGet();
        day.tokens.addAndGet(estimatedTokens);
        return true;
    }

    /**
     * 현재 분(Window)에서 남아있는 요청 가능 횟수.
     */
    public int getRemainingRequestsPerMinute(String providerId) {
        long now = System.currentTimeMillis();
        MinuteWindow w = minuteWindows.get(providerId);
        if (w == null || !w.isSameMinute(now)) return REQUESTS_PER_MINUTE;
        return Math.max(0, REQUESTS_PER_MINUTE - w.count.get());
    }

    /**
     * 오늘(Day) 남은 요청 가능 횟수.
     */
    public int getRemainingRequestsPerDay(String providerId) {
        long now = System.currentTimeMillis();
        DayCounter d = dayCounters.get(providerId);
        if (d == null || !d.isSameDay(now)) return REQUESTS_PER_DAY;
        return Math.max(0, REQUESTS_PER_DAY - d.requests.get());
    }

    /**
     * 오늘(Day) 남은 토큰 가능 수.
     */
    public int getRemainingTokensPerDay(String providerId) {
        long now = System.currentTimeMillis();
        DayCounter d = dayCounters.get(providerId);
        if (d == null || !d.isSameDay(now)) return TOKENS_PER_DAY;
        return Math.max(0, TOKENS_PER_DAY - d.tokens.get());
    }


    // --- 내부 카운터 클래스들 ---

    private static final class MinuteWindow {
        long windowStartMillis;
        AtomicInteger count = new AtomicInteger(0);

        MinuteWindow(long now) {
            this.windowStartMillis = now;
        }
        
        boolean isSameMinute(long now) {
            return (this.windowStartMillis / 60000) == (now / 60000);
        }

        void reset(long now) {
            this.windowStartMillis = now;
            this.count.set(0);
        }
    }

    private static final class DayCounter {
        long dayStartMillis;
        AtomicInteger requests = new AtomicInteger(0);
        AtomicInteger tokens = new AtomicInteger(0);

        DayCounter(long now) {
            this.dayStartMillis = now;
        }

        /**
         * "일" 비교는 타임존 때문에 복잡해서 ZonedDateTime을 쓰는 것이 안전합니다.
         * (예: 새벽 1시에 KST는 같은 날, UTC는 다른 날일 수 있음)
         */
        boolean isSameDay(long now) {
            ZoneId zone = ZoneId.systemDefault();
            ZonedDateTime a = Instant.ofEpochMilli(this.dayStartMillis).atZone(zone);
            ZonedDateTime b = Instant.ofEpochMilli(now).atZone(zone);
            return a.toLocalDate().isEqual(b.toLocalDate());
        }

        void reset(long now) {
            this.dayStartMillis = now;
            this.requests.set(0);
            this.tokens.set(0);
        }
    }
}
```


Spring 클라이언트 요청이 올 때마다 자동 검사를 수행하는 AOP
1. Filter
2. Interceptor

Filter
Spring의 디스페쳐 서블릿이 요청을 받기 전에 필터 체인에서 검사를 진행
시큐리티 필터, 토큰검사 필터 등...
모든 요청에 대하여 검사를 진행

Interceptor
- 
```java
/**
 * 레이트 리미트(Rate Limit)를 적용하기 위한 스프링 MVC 인터셉터입니다.
 *
 * 초보자 가이드
 * - 왜 필요한가?
 *   1) 비용 보호: LLM 호출은 토큰 사용량에 따라 비용이 발생합니다. 무분별한 요청/긴 요청은 비용 폭탄이 될 수 있습니다.
 *   2) 공정성: 특정 사용자가 과도하게 호출하면 다른 사용자 경험이 나빠집니다. 사용자별 한도를 두어 공정하게 나눕니다.
 *   3) 안정성: 갑작스런 트래픽 급증(예: 스팸/봇)으로 서버가 불안정해지는 것을 막습니다.
 *
 * 동작 개요
 * - 이 인터셉터는 컨트롤러가 실행되기 "이전"에 동작(preHandle).
 * - SecurityContext 에서 인증된 사용자 식별자(providerId; JWT subject)를 추출합니다.
 * - 요청 본문 길이를 직접 읽지 않고(Content-Length 헤더 기반) 대략적인 토큰 사용량을 추정합니다.
 * - {@link RateLimiterService#tryConsume(String, int)} 로 분당/일일 요청 수, 일일 토큰 한도를 함께 검사합니다.
 * - 한도를 초과하면 {@link BusinessException} 을 던져 요청을 즉시 차단합니다.
 *
 * 주의사항(학습 포인트)
 * - 현재 구현은 "인메모리" 카운터입니다. 서버 인스턴스가 여러 대일 경우 한도가 서버 간에 공유되지 않습니다.
 *   운영 환경에서는 Redis 같은 외부 저장소를 사용한 분산 레이트 리미팅으로 대체하세요.
 * - 토큰 추정은 매우 단순화된 근사치입니다. 모델/프롬프트/언어에 따라 실제 토큰 수는 달라질 수 있습니다.
 * - 이 인터셉터는 설정 클래스(WebMvcConfig)에서 "/api/ai/**" 경로에만 적용되도록 등록되어 있습니다.
 */
@Component
@RequiredArgsConstructor
public class RateLimitInterceptor implements HandlerInterceptor {

    private final RateLimiterService rateLimiterService; // 사용자별 요청/토큰 한도를 관리하는 서비스(인메모리)

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        // (1) 인증 주체에서 providerId(subject) 추출: JwtAuthenticationFilter 가 미리 SecurityContext 를 채워둡니다.
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null || auth.getPrincipal() == null) {
            // 인증이 없다면 AI API 를 호출할 수 없습니다.
            throw new BusinessException(ErrorCode.UNAUTHORIZED, ErrorCode.UNAUTHORIZED.getDefaultMessage());
        }
        String providerId = String.valueOf(auth.getPrincipal()); // 문자열 키로 사용

        // (2) 단순 토큰 추정: POST 요청의 Content-Length 헤더 기반(본문을 직접 읽지 않음)
        int estimatedTokens = 0;
        if ("POST".equalsIgnoreCase(request.getMethod())) {
            int contentLength = request.getContentLength(); // 없으면 -1
            if (contentLength < 0) {
                String cl = request.getHeader("Content-Length");
                if (cl != null) {
                    try { contentLength = Integer.parseInt(cl); } catch (NumberFormatException ignore) { contentLength = -1; }
                }
            }
            if (contentLength > 0) {
                estimatedTokens = Math.max(0, contentLength / 4); // 매우 단순한 근사치: 4바이트 ≈ 1토큰
            }
        }

        // (3) 사용자별 레이트 리미트 소진 시도: 분당/일일 요청 수, 일일 토큰 한도 검사
        boolean allowed = rateLimiterService.tryConsume(providerId, estimatedTokens);
        if (!allowed) {
            // 한도 초과: GlobalExceptionHandler 가 429(Too Many Requests) 로 변환하여 클라이언트에 응답합니다.
            throw new BusinessException(ErrorCode.RATE_LIMIT_EXCEEDED, ErrorCode.RATE_LIMIT_EXCEEDED.getDefaultMessage());
        }
        return true; // 허용: 컨트롤러로 진행
    }
}

```

스프링 MVC 인터셉터를 ai 요청에 연결
```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    private final RateLimitInterceptor rateLimitInterceptor;

    public WebMvcConfig(RateLimitInterceptor rateLimitInterceptor) {
        this.rateLimitInterceptor = rateLimitInterceptor;
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(rateLimitInterceptor)
                .addPathPatterns("/api/ai/**");
    }
}
```


swagger (스웨거)
- RESTful API를 설계, 문서화, 테스트하고 소비하는 데 사용되는 오픈 소스 프레임워크

의존성 추가
- Spring AI가 정식 버젼이 아니라 개발자가 생성한
- AI 의존성 내부에 있는 Swagger를 제거, 스웨거 의존성 추가
```groovy
// Spring AI (Google AI via OpenAI compatible API)
implementation("org.springframework.ai:spring-ai-openai-spring-boot-starter:${springAiVersion}") {
    // Swagger 구버전/중복 충돌 방지를 위해 spring-ai에서 끌고오는 Swagger 관련 의존성 제외
    exclude group: 'io.swagger.core.v3', module: 'swagger-annotations'
    exclude group: 'io.swagger', module: 'swagger-annotations'
    exclude group: 'io.swagger', module: 'swagger-models'
    exclude group: 'com.github.victools', module: 'jsonschema-module-swagger-2'
}

// Spring Boot 3용 OpenAPI UI 
implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.3.0'
```

스웨거 경로 변경
```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    
    @Override
    public void addViewControllers(@NonNull ViewControllerRegistry registry) {
        // 루트 경로(/) 접근 시 Swagger UI로 리다이렉트
        registry.addRedirectViewController("/", "/swagger-ui/index.html");
    }
}
```

주석을 따로 달아서 사용자 친화적인 스웨거를 작성 가능


OpenAPI 3.0 (Swagger) 설정
- Swagger의 메인을 README처럼 꾸밀 수 있음
- API 문서 메타데이터 정의
- Bearer 토큰 인증 스키마 설정
- Swagger UI에서 "Authorize" 버튼을 통해 토큰 입력 가능


