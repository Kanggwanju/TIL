
# 🗓️ 2025년 7월 21일 TIL

## ✅ 오늘의 핵심 키워드

* 예외란 무엇인가?
* 체크 예외 vs 언체크 예외
* Spring MVC의 예외 처리 흐름
* `@ExceptionHandler`, `@RestControllerAdvice`
* 사용자 정의 예외, 에러 코드 Enum, 에러 응답 DTO

---

## 📌 예외란?

* **예상치 못한 상황**으로 인해 프로그램이 정상 흐름을 벗어나는 것
* 예시: 네트워크 끊김, DB 연결 실패, 중복된 아이디 등

### 체크 예외 (Checked Exception)

> **반드시 처리해야 하는 예외**. 컴파일러가 확인함.

* 예시:

    * 파일이 존재하지 않음
    * DB 연결 실패
    * 외부 API 호출 실패
* 비유: 자동차 운전 전 **안전벨트 착용 여부 확인**

### 언체크 예외 (Unchecked Exception)

> **프로그래머 실수로 발생하는 예외**. 컴파일러가 확인하지 않음.

* 예시:

    * 배열 범위 초과
    * null 객체 사용

---

## ⚠️ 예외 처리가 필요한 이유

| 나쁜 처리 방식      | 좋은 처리 방식               |
| ------------- | ---------------------- |
| 프로그램이 갑자기 종료됨 | 사용자에게 문제를 안내하고 대안을 제시함 |

---

## 🛠️ 예외 처리 흐름 (Spring MVC 기준)

1. 컨트롤러/서비스에서 예외 발생
2. 예외가 `DispatcherServlet`까지 전달됨
3. `@ExceptionHandler` 또는 `@ControllerAdvice`가 예외 처리
4. 클라이언트에게 응답 반환

---

## 🔐 기본 예외 처리 방식

### 1. try-catch 예시

```java
try {
    데이터베이스에서_회원정보_조회();
} catch (Exception e) {
    관리자에게_문제_발생_알리기();
}
```

### 2. throws 예시

```java
public void readFile() throws IOException {
    // 예외는 호출한 쪽에서 처리하도록 던짐
}
```

---

## 🎯 Spring의 예외 처리 도구

### @ExceptionHandler

```java
@ExceptionHandler(ProductNotFoundException.class)
public ResponseEntity<String> handleProductNotFound() {
    return ResponseEntity.status(404).body("죄송합니다. 찾으시는 상품이 없습니다.");
}
```

### @ControllerAdvice vs @RestControllerAdvice

| 항목    | @ControllerAdvice | @RestControllerAdvice |
| ----- | ----------------- | --------------------- |
| 사용 환경 | 웹 페이지             | REST API              |
| 응답 형식 | View, JSON, XML   | JSON                  |
| 특징    | HTML 반환 가능        | `@ResponseBody` 자동 포함 |

> ✅ 웹사이트 → `@ControllerAdvice`
> ✅ API 서버 → `@RestControllerAdvice`

---

## 💡 예외 처리 패턴 실습

> 아래 코드는 `MemberService` 클래스에서 회원 정보를 조회할 때 발생할 수 있는 다양한 예외 상황을 처리하는 예제입니다.

```java
@Service
@Slf4j
@RequiredArgsConstructor
public class MemberService {

    private final MemberRepository memberRepository;

    public MemberListResponse findOneMember(String account) {
        log.info("회원 개별 조회 요청");
```

> 👉 **로깅**으로 요청 흐름을 추적할 수 있도록 로그를 남김

---

### 🔹 \[1단계] 입력값 검증

```java
        if (account.length() > 10) {
            throw new MemberException(ErrorCode.ACCOUNT_TOO_LONG);
        }
```

> * **사용자 입력값 검증 (Validation)**
> * 계정명이 너무 길면 `ACCOUNT_TOO_LONG`이라는 커스텀 예외를 던짐
> * 이렇게 하면 컨트롤러에서 if문을 반복하지 않고, 비즈니스 로직에 집중할 수 있음

---

### 🔹 \[2단계] DB 조회 & 널 체크

```java
        Member foundMember = memberRepository.findByAccount(account);

        if (foundMember == null) {
            throw new MemberException(ErrorCode.MEMBER_NOT_FOUND);
        }
```

> * **레포지토리(DAO)에서 데이터 조회**
> * 만약 사용자가 존재하지 않으면, `MEMBER_NOT_FOUND` 예외 발생
> * 즉, **입력은 맞는데 데이터가 없음** → 적절한 예외 처리 필요

---

### 🔹 \[3단계] DTO 변환 및 응답 반환

```java
        return MemberListResponse.from(foundMember);
    }
}
```

> * **Entity를 직접 반환하지 않고 DTO로 변환**
> * 외부에 노출하면 안 되는 정보(User password 등)는 걸러내고,
    >   필요한 정보만 정제해서 응답에 담음

---

### 📌 이 패턴이 중요한 이유

| 포인트        | 설명                              |
| ---------- | ------------------------------- |
| ❗입력값 검증    | 오류를 빠르게 차단하고, 불필요한 DB 조회를 방지    |
| ❗명확한 예외 분기 | 어떤 상황에서 어떤 예외가 발생했는지 명확하게 구분 가능 |
| ❗DTO 변환    | 응답의 일관성과 보안성을 유지                |

---

### 🔄 흐름 요약

```
[입력값 검증] → [DB조회] → [널 체크] → [DTO 응답]
      ↓               ↓             ↓
  커스텀 예외     커스텀 예외     정상 응답
```

---

```java
@Service
@Slf4j
@RequiredArgsConstructor
public class MemberService {

    private final MemberRepository memberRepository;

    public MemberListResponse findOneMember(String account) {
        log.info("회원 개별 조회 요청");

        if (account.length() > 10) {
            throw new MemberException(ErrorCode.ACCOUNT_TOO_LONG);
        }

        Member foundMember = memberRepository.findByAccount(account);
        if (foundMember == null) {
            throw new MemberException(ErrorCode.MEMBER_NOT_FOUND);
        }

        return MemberListResponse.from(foundMember);
    }
}
```

---

## 🧱 사용자 정의 예외 클래스

```java
@Getter
public class MemberException extends RuntimeException {

    private final int status;
    private final String errorName;

    public MemberException(ErrorCode errorCode) {
        super(errorCode.getErrorMessage());
        this.status = errorCode.getStatusCode();
        this.errorName = errorCode.toString();
    }
}
```

---

## 📦 GlobalExceptionHandler 예제

- API에서 발생하는 수많은 예외상황들을 도맡아서 처리하는 클래스

```java
@Slf4j
@ControllerAdvice
public class GlobalExceptionHandler {

    // 예외처리 메서드
    @ExceptionHandler(MemberException.class)
    public ResponseEntity<?> handleMemberException(
            MemberException e,
            HttpServletRequest request
    ) {
        log.warn("예외 발생: {}", e.getMessage());

        // 구체적인 에러 정보 객체를 생성
        ErrorResponse errorResponse = ErrorResponse.builder()
            .status(e.getStatus())
            .error(e.getErrorName())
            .message(e.getMessage())
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();

        return ResponseEntity.status(e.getStatus()).body(errorResponse);
    }
}
```

* `@ControllerAdvice`: 컨트롤러 대신 예외처리를 해주는 라이브러리

---

## 🔁 에러 코드 Enum 관리

```java
@Getter
@AllArgsConstructor
public enum ErrorCode {
    MEMBER_NOT_FOUND(404, "회원을 찾을 수 없습니다."),
    ACCOUNT_TOO_LONG(400, "계정명은 10글자 이내여야 합니다.");
    
    private final int statusCode;
    private final String errorMessage;
}
```

---

## 📤 ErrorResponse DTO 구조

```java
public class ErrorResponse {
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
}
```

---

## 🧠 오늘의 요약

* 예외 처리는 사용자 경험과 시스템 안정성을 위해 필수
* Spring에서는 `@ExceptionHandler`, `@ControllerAdvice`, `@RestControllerAdvice`로 구조적으로 처리 가능
* 사용자 정의 예외 + 에러 코드 Enum + DTO 패턴으로 확장성과 유지보수성 확보
* 에러는 “로그로 기록하고, 메시지로 안내하고, 응답으로 구조화”하는 것이 핵심



