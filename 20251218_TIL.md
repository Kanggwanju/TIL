# 🗓️ 2025년 12월 18일 TIL - Java 캡슐화(Encapsulation) & 접근 제어자

## 📌 오늘의 키워드

`캡슐화(Encapsulation)` `정보 은닉(Information Hiding)` `접근 제어자`
`private` `public` `default(package-private)` `getter` `setter` `검증 로직`

---

## 1️⃣ 캡슐화(Encapsulation)란?

### 💡 한 줄 정의

**객체의 내부 상태(필드)를 숨기고, 필요한 방법(메서드)으로만 접근하게 만드는 것**

* 왜 숨기나?
  👉 외부에서 마음대로 값을 바꾸면 **객체가 망가질 수 있어서**
* 그래서 보통 이렇게 설계한다:

  1. 필드는 `private`로 숨김
  2. 읽기/수정은 `getter/setter` 같은 메서드로만 허용
  3. `setter` 안에서 **검증**해서 “유효한 값만” 들어오게 함

📌 비유로 기억하기

* 객체 내부 상태 = **VIP 라운지**
* `private` = **출입문 잠금**
* `getter/setter` = **직원이 확인 후 입장/변경 처리**
* 검증 로직 = **회원권 체크(조건 불만족이면 거절)**

---

## 2️⃣ 접근 제어자 정리 (public / private / default)

| 접근 제어자                | 접근 범위      | 핵심 느낌               |
| --------------------- | ---------- | ------------------- |
| `public`              | 어디서든 접근 가능 | “완전 공개”             |
| `private`             | 같은 클래스 내부만 | “완전 숨김”             |
| `default` (아무 것도 안 씀) | 같은 패키지에서만  | “우리 팀(패키지) 안에서만 공유” |

오늘 예제에서 **default가 ‘패키지 경계’에서 막히는 것**을 직접 확인했다.
`Idol.introduce()`는 `public`이라 다른 패키지에서도 호출 가능하지만, `introduce(String)`는 `default`라 다른 패키지에서 호출 불가였다.

---

## 3️⃣ private로 필드 숨기기 + getter/setter로 접근 통제

### ✅ `Idol` 예제 핵심

* `name`, `groupName`을 `private`로 숨김
* 외부에서 직접 수정 시도는 컴파일 에러(주석으로 표시)
* 대신 `getName()`, `getGroupName()`으로 읽고, `setGroupName()`으로 변경

### ✅ setter의 진짜 가치: “검증 로직”

`setGroupName()` 내부에서

* `null`이거나 빈 문자열이면 에러 출력 후 `return`
* 정상 값만 실제로 반영

👉 즉, 외부가 이상한 값을 넣으려 해도 **객체 상태를 안전하게 유지**할 수 있다.

---

## 4️⃣ default(package-private)로 “패키지 안에서만” 공개하기

`Arena`는 `chap50.concert` 패키지이고, `Idol`은 `chap50.entertainment` 패키지다.

* `introduce()`는 `public` → 다른 패키지에서도 호출 가능 ✅
* `introduce(String)`는 `default` → 다른 패키지에서 호출 불가 ❌ (그래서 주석 처리)

이게 “접근 제어자”가 실제로 어떤 효과를 내는지 체감 포인트였다.

---

## 5️⃣ 미니 퀴즈로 본 캡슐화 패턴

### ✅ Quiz1: private + getter (읽기만 허용)

* `age`를 `private`로 숨기고
* `getAge()`로만 조회

### ✅ Quiz2: setter에 검증 넣기 (객체 불변 조건 유지)

* `balance`를 `private`로 숨김
* `setBalance()`에서 음수면 0으로 보정

---

## 🎯 최종 정리

| 오늘 배운 것 | 한 줄 요약               |
| ------- | -------------------- |
| 캡슐화     | 내부 상태를 숨기고 메서드로만 접근  |
| private | 필드 직접 접근 차단(정보 은닉)   |
| getter  | 외부에 “읽기”만 제공         |
| setter  | 외부의 “수정”을 통제 + 검증 가능 |
| default | 같은 패키지에서만 접근 가능      |
| public  | 어디서든 접근 가능           |

---

## 💻 실습 코드

### `Idol.java`

```java
package chap50.entertainment;

public class Idol {

    // 접근 제어자 private, 같은 클래스 내에서만 접근 가능
    private String name;
    private String groupName;

    Idol() {
    }

    public Idol(String name, String groupName) {
        this.name = name;
        this.groupName = groupName;
    }

    Idol(String name) {
        this(name, "솔로가수");
    }

    // 아이돌의 기능 : 메서드
    public void introduce() {
        System.out.println("안녕하세요! " + this.groupName + "의 " + this.name + "입니다.");
    }

    // 다른 패키지에서는 사용 불가능한 default 제한자
    void introduce(String initMessage) {
        System.out.println(initMessage);
        this.introduce();
    }

    // getter 메서드: 필드의 값을 외부에서 읽을 수 있게끔 함.
    public String getGroupName() {
        return this.groupName;
    }

    public String getName() {
        return name;
    }

    // setter 메서드
    // 그룹명을 변경하기 위한 메서드
    public void setGroupName(String newGroupName) {
        // setter 내부에 검증 로직을 추가할 수 있습니다.
        if (newGroupName == null || newGroupName.isEmpty()) {
            System.out.println("오류: 그룹명은 필수입니다.");
            return;
        }
        this.groupName = newGroupName;
        System.out.println("소속 그룹이 " + this.groupName
            + "으로 변경되었습니다.");
    }
}

class Main {

    public static void main(String[] args) {

        Idol chaewon = new Idol("김채원", "르세라핌");

        // private 접근 차단 효과: 컴파일 에러
        // chaewon.name = "하하호호티니핑";
        // chaewon.groupName = "에스파";

        chaewon.setGroupName("아이즈원");

        System.out.println("이름: " + chaewon.getName());
        System.out.println("그룹명: " + chaewon.getGroupName());

        chaewon.introduce();

    }
}
```

### `Arena.java`

```java
package chap50.concert;

import chap50.entertainment.Idol;

public class Arena {

    public static void main(String[] args) {

        Idol yujin
            = new Idol("안유진", "아이브");

        yujin.introduce();
//        yujin.introduce("하하호호");
    }
}
```

### `Quiz1.java`

```java
package chap50;

public class Quiz1 {

}

class Member {

    // 1. 정보 은닉을 위한 private
    private int age;

    public Member(int age) {
        this.age = age;
    }

    // 2. 나이 정보 조회를 위한 메서드 getAge
    public int getAge() {
        return this.age;
    }


}
```

### `Quiz2.java`

```java
package chap50;

public class Quiz2 {
}

class Account {
    private int balance;

    public Account(int balance) {
        this.balance = balance;
    }

    public int getBalance() {
        return this.balance;
    }

    // 파라미터의 값에 따른 내부 검증 로직
    public void setBalance(int newBalance) {
        if (newBalance >= 0) {
            this.balance = newBalance;
        } else {
            this.balance = 0;
        }
    }
}
```

---

## 💬 오늘의 소감

* `private → getter/setter` 흐름이 “코딩 관례”가 아니라, **객체를 안전하게 지키는 설계**라는 걸 확실히 이해했다.
* 특히 `default`가 패키지 밖에서 막히는 걸 `Arena` 예제로 보니까 접근 제어자가 더 실감났다.
