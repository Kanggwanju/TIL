# 🗓️ 2025년 9월 16일 TIL

## 📌 오늘의 키워드
`STOMP` `WebSocket 이벤트` `EventListener` `SimpMessagingTemplate` `UserSessionRegistry` `PresenceService` `동시성 제어` `ConcurrentHashMap` `인메모리 저장소` `실시간 상태 관리` `중복 알림 방지`

---

## 개요: 실시간 채팅방 상태 관리 시스템

### 해결해야 할 문제

**문제 1: 중복 알림**
```
사용자가 3개의 브라우저 탭에서 같은 채팅방 접속
    ↓
WebSocket 세션이 3개 생성
    ↓
"홍길동님이 입장했습니다" 메시지가 3번 전송 ❌
```

**문제 2: 상태 불일치**
```
사용자가 2개 탭 접속 → 1개 탭만 종료
    ↓
"홍길동님이 퇴장했습니다" 메시지 전송 ❌
    ↓
하지만 아직 다른 탭에서 접속 중
```

---

### 해결 방안: 3개의 핵심 컴포넌트

```
┌─────────────────────────────────────────────────────────┐
│  WebSocketEventsListener (관찰자)                       │
│  - WebSocket 이벤트 감지 및 처리                        │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│  UserSessionRegistry (기록관)                           │
│  - 세션과 사용자 매핑 관리                              │
│  - 중복 알림 방지                                       │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│  PresenceService (상태 관리자)                          │
│  - 사용자 온라인/오프라인 상태 관리                     │
│  - 실시간 상태 브로드캐스트                             │
└─────────────────────────────────────────────────────────┘
```

---

## 1. WebSocketEventsListener (이벤트 관찰자)

### 역할
- WebSocket 세션의 **구독, 구독 해제, 연결 종료** 이벤트를 감지
- 채팅방 입장/퇴장 시스템 메시지 생성 및 브로드캐스트
- UserSessionRegistry와 PresenceService 조율

---

### 주요 이벤트 타입

| 이벤트 | 발생 시점 | 처리 내용 |
|--------|-----------|-----------|
| **SessionSubscribeEvent** | 클라이언트가 토픽 구독 시 | 입장 메시지, 온라인 상태 |
| **SessionUnsubscribeEvent** | 클라이언트가 구독 해제 시 | 퇴장 메시지, 오프라인 상태 |
| **SessionDisconnectEvent** | WebSocket 연결 종료 시 | 모든 구독 정리 |

---

### 구독 이벤트 처리 (onSubscribe)

```java
@EventListener
public void onSubscribe(SessionSubscribeEvent event) {
    StompHeaderAccessor accessor = StompHeaderAccessor.wrap(event.getMessage());
    String destination = accessor.getDestination();
    String providerId = (String) accessor.getSessionAttributes().get("providerId");
    
    // 채팅 토픽 구독 처리
    if (isChatTopic(destination, roomId)) {
        // 1. 레지스트리에 세션 등록 및 첫 입장 여부 확인
        boolean firstJoin = registry.handleSubscribe(
            accessor.getSessionId(),
            accessor.getSubscriptionId(),
            roomId,
            providerId
        );
        
        // 2. 첫 입장일 때만 JOIN 메시지 브로드캐스트
        if (firstJoin) {
            String nickname = usersService.findMeByProviderId(providerId).getNickname();
            messagingTemplate.convertAndSend(
                "/topic/rooms/" + roomId,
                new SystemMessagePayload("JOIN", providerId, nickname + " 님이 입장했습니다.")
            );
        }
    }
    
    // 프레즌스 토픽 구독 처리
    if (isPresenceTopic(destination, roomId)) {
        // 1. 프레즌스 구독 등록 및 첫 입장 여부 확인
        boolean firstPresence = registry.handlePresenceSubscribe(
            accessor.getSessionId(),
            accessor.getSubscriptionId(),
            roomId,
            providerId
        );
        
        // 2. 첫 입장일 때만 ONLINE 상태로 변경
        if (firstPresence) {
            presenceService.online(roomId, providerId);
        }
    }
}
```

**동작 흐름**:
```
클라이언트가 /topic/rooms/1 구독
    ↓
isChatTopic() 확인 → true
    ↓
registry.handleSubscribe() 호출
    ↓
firstJoin == true ? (첫 입장인가?)
    ↓ (예)
"홍길동 님이 입장했습니다" 브로드캐스트
```

---

### 토픽 구분

```java
private boolean isChatTopic(String destination, Long roomId) {
    return destination.equals("/topic/rooms/" + roomId);
}

private boolean isPresenceTopic(String destination, Long roomId) {
    return destination.equals("/topic/rooms/" + roomId + "/presence");
}
```

**주소 체계**:
- `/topic/rooms/1`: 채팅 메시지 토픽
- `/topic/rooms/1/presence`: 사용자 상태 토픽

---

## 2. UserSessionRegistry (세션 기록관)

### 역할
- WebSocket 세션과 사용자의 **매핑 정보** 관리
- 사용자별 **활성 세션 수** 카운트
- 중복 알림 방지를 위한 **첫 입장/마지막 퇴장** 판별

---

### 데이터 구조

```java
@Component
public class UserSessionRegistry {
    
    // 세션별 구독 정보 (세션 ID → {구독 ID → 방 ID})
    private final Map<String, Map<String, Long>> sessionToSubscriptions 
        = new ConcurrentHashMap<>();
    
    // 세션별 프레즌스 구독 정보
    private final Map<String, Map<String, Long>> sessionToPresenceSubscriptions 
        = new ConcurrentHashMap<>();
    
    // 방별 사용자 카운트 (방 ID → {사용자 ID → 세션 수})
    private final Map<Long, Map<String, Integer>> roomToProviderCount 
        = new ConcurrentHashMap<>();
    
    // 구독 ID → 사용자 ID 매핑
    private final Map<String, String> subscriptionToProvider 
        = new ConcurrentHashMap<>();
}
```

**계층 구조**:
```
roomToProviderCount (방별 사용자 관리)
    ├─ 방 1
    │   ├─ user_A: 3 (3개 탭 접속)
    │   └─ user_B: 1 (1개 탭 접속)
    └─ 방 2
        └─ user_C: 2 (2개 탭 접속)
```

---

### 구독 처리 (handleSubscribe)

```java
public boolean handleSubscribe(String sessionId, String subscriptionId, 
                               Long roomId, String providerId) {
    // 1. 세션의 구독 정보 저장
    sessionToSubscriptions
        .computeIfAbsent(sessionId, k -> new ConcurrentHashMap<>())
        .put(subscriptionId, roomId);
    
    // 2. 구독 ID → 사용자 ID 매핑 저장
    subscriptionToProvider.put(subscriptionId, providerId);
    
    // 3. 이 세션이 이 방을 처음 구독하는지 확인
    long roomCountForSession = sessionToSubscriptions.get(sessionId)
        .values()
        .stream()
        .filter(rid -> rid.equals(roomId))
        .count();
    
    // 4. 세션 기준 첫 구독이 아니면 사용자 카운트 증가 안 함
    if (roomCountForSession > 1) {
        return false;
    }
    
    // 5. 사용자별 세션 카운트 증가
    int afterCount = increaseProviderCount(roomId, providerId);
    
    // 6. 사용자의 첫 입장인지 반환 (카운트가 1이면 첫 입장)
    return afterCount == 1;
}
```

---

### 사용자 카운트 증가 (동시성 안전)

```java
private int increaseProviderCount(Long roomId, String providerId) {
    // computeIfAbsent: 키가 없으면 새 맵 생성 (동시성 안전)
    Map<String, Integer> providerMap = roomToProviderCount
        .computeIfAbsent(roomId, k -> new ConcurrentHashMap<>());
    
    // merge: 기존 값이 있으면 +1, 없으면 1로 설정 (동시성 안전)
    return providerMap.merge(providerId, 1, Integer::sum);
}
```

**ConcurrentHashMap의 동시성 안전 메서드**:
- `computeIfAbsent(key, function)`: 키가 없을 때만 함수 실행 (원자적 연산)
- `merge(key, value, remappingFunction)`: 값 병합 (원자적 연산)

---

### 실제 시나리오 예시

#### 시나리오 1: 사용자 A가 3개 탭으로 방 1 접속

```
탭 1 접속:
    handleSubscribe(session1, sub1, room1, userA)
    → roomToProviderCount: {room1 → {userA: 1}}
    → return true ✅ (JOIN 메시지 전송)

탭 2 접속:
    handleSubscribe(session2, sub2, room1, userA)
    → roomToProviderCount: {room1 → {userA: 2}}
    → return false ❌ (JOIN 메시지 전송 안 함)

탭 3 접속:
    handleSubscribe(session3, sub3, room1, userA)
    → roomToProviderCount: {room1 → {userA: 3}}
    → return false ❌ (JOIN 메시지 전송 안 함)
```

**결과**: "사용자 A님이 입장했습니다" 메시지는 **1번만** 전송 ✅

---

#### 시나리오 2: 사용자 A가 탭 2개 중 1개 종료

```
초기 상태:
    roomToProviderCount: {room1 → {userA: 2}}

탭 1 종료:
    handleUnsubscribe(sub1)
    → roomToProviderCount: {room1 → {userA: 1}}
    → return false ❌ (LEAVE 메시지 전송 안 함)

탭 2 종료:
    handleUnsubscribe(sub2)
    → roomToProviderCount: {room1 → {userA: 0}}
    → return true ✅ (LEAVE 메시지 전송)
```

**결과**: "사용자 A님이 퇴장했습니다" 메시지는 **마지막 탭 종료 시에만** 전송 ✅

---

### 구독 해제 처리 (handleUnsubscribe)

```java
public boolean handleUnsubscribe(String subscriptionId) {
    // 1. 구독 ID로 방 ID와 사용자 ID 조회
    Long roomId = findRoomBySubscription(subscriptionId);
    String providerId = subscriptionToProvider.get(subscriptionId);
    
    if (roomId == null || providerId == null) {
        return false;
    }
    
    // 2. 세션에서 구독 정보 제거
    removeSubscriptionFromSession(subscriptionId);
    
    // 3. 사용자별 세션 카운트 감소
    int afterCount = decreaseProviderCount(roomId, providerId);
    
    // 4. 마지막 세션 종료인지 반환 (카운트가 0이면 마지막)
    return afterCount == 0;
}

private int decreaseProviderCount(Long roomId, String providerId) {
    Map<String, Integer> providerMap = roomToProviderCount.get(roomId);
    if (providerMap == null) return 0;
    
    // merge로 -1, 0 이하면 제거
    Integer newCount = providerMap.merge(providerId, -1, (oldVal, delta) -> {
        int result = oldVal + delta;
        return result <= 0 ? null : result;  // null 반환 시 키 제거
    });
    
    return newCount == null ? 0 : newCount;
}
```

---

## 3. PresenceService (상태 관리자)

### 역할
- 사용자의 **실시간 온라인/오프라인 상태** 관리
- 상태 변경 시 클라이언트에게 즉시 브로드캐스트
- **heartbeat** 신호로 접속 상태 유지

---

### 데이터 구조

```java
@Service
@RequiredArgsConstructor
public class PresenceService {
    
    // 방별 사용자 상태 저장 (방 ID → {사용자 ID → 상태})
    private final Map<Long, Map<String, ParticipantStatus>> store 
        = new ConcurrentHashMap<>();
    
    private final SimpMessagingTemplate messagingTemplate;
}
```

**상태 예시**:
```
store
    ├─ 방 1
    │   ├─ user_A: ONLINE
    │   └─ user_B: AWAY
    └─ 방 2
        └─ user_C: ONLINE
```

---

### 온라인 상태 설정

```java
public void online(Long roomId, String providerId) {
    // 1. computeIfAbsent로 방 맵이 없으면 생성 (동시성 안전)
    store
        .computeIfAbsent(roomId, k -> new ConcurrentHashMap<>())
        .put(providerId, ParticipantStatus.ONLINE);
    
    // 2. 상태 변경을 브로드캐스트
    broadcast(roomId, providerId, ParticipantStatus.ONLINE);
}
```

**computeIfAbsent의 장점**:
```java
// ❌ 일반적인 방법 (NullPointerException 위험)
Map<String, ParticipantStatus> map = store.get(roomId);
if (map == null) {
    map = new HashMap<>();
    store.put(roomId, map);
}
map.put(providerId, status);

// ✅ computeIfAbsent 사용 (안전하고 간결)
store
    .computeIfAbsent(roomId, k -> new ConcurrentHashMap<>())
    .put(providerId, status);
```

---

### 상태 업데이트

```java
public void updateStatus(Long roomId, String providerId, ParticipantStatus status) {
    Map<String, ParticipantStatus> roomPresence = store.get(roomId);
    if (roomPresence == null) {
        return;
    }
    
    // 현재 상태와 다를 때만 업데이트
    ParticipantStatus currentStatus = roomPresence.get(providerId);
    if (currentStatus != status) {
        roomPresence.put(providerId, status);
        broadcast(roomId, providerId, status);
    }
}
```

---

### 오프라인 상태 설정

```java
public void offline(Long roomId, String providerId) {
    Map<String, ParticipantStatus> roomPresence = store.get(roomId);
    if (roomPresence != null) {
        // 1. 사용자 상태 제거
        roomPresence.remove(providerId);
        
        // 2. OFFLINE 상태 브로드캐스트
        broadcast(roomId, providerId, ParticipantStatus.OFFLINE);
        
        // 3. 방에 아무도 없으면 방 정보도 제거 (메모리 정리)
        if (roomPresence.isEmpty()) {
            store.remove(roomId);
        }
    }
}
```

---

### 브로드캐스트

```java
private void broadcast(Long roomId, String providerId, ParticipantStatus status) {
    // 프레즌스 토픽으로 상태 변경 브로드캐스트
    messagingTemplate.convertAndSend(
        "/topic/rooms/" + roomId + "/presence",
        new PresencePayload(providerId, status)
    );
}
```

**흐름**:
```
사용자 A 상태 변경 (ONLINE → AWAY)
    ↓
PresenceService.updateStatus() 호출
    ↓
store에 상태 업데이트
    ↓
broadcast() 호출
    ↓
/topic/rooms/1/presence로 메시지 전송
    ↓
같은 방을 구독한 모든 클라이언트가 상태 변경 수신
```

---

### Heartbeat (상태 유지)

```java
public void heartbeat(Long roomId, String providerId) {
    Map<String, ParticipantStatus> roomPresence = store.get(roomId);
    if (roomPresence != null && roomPresence.containsKey(providerId)) {
        // 사용자가 여전히 온라인임을 확인
        // 필요시 타임스탬프 업데이트 등 추가 로직
    }
}
```

**사용 목적**:
- 클라이언트가 주기적으로(예: 30초마다) heartbeat 전송
- 서버는 사용자가 여전히 접속 중임을 확인
- 일정 시간 heartbeat 없으면 자동으로 오프라인 처리 가능

---

## 동시성 문제와 해결 방법

### 문제: Race Condition (경쟁 상태)

```java
// ❌ 동시성 문제 발생 코드
Map<String, Integer> map = new HashMap<>();

// 스레드 A와 B가 동시에 실행
int count = map.get("user1");  // A: 1, B: 1
count++;                        // A: 2, B: 2
map.put("user1", count);        // 최종값: 2 (올바른 값: 3)
```

**문제점**:
- 두 스레드가 동시에 읽고 쓰면서 데이터 손실 발생
- 예상 결과(3)와 실제 결과(2)가 다름

---

### 해결: ConcurrentHashMap의 원자적 연산

```java
// ✅ 동시성 안전 코드
Map<String, Integer> map = new ConcurrentHashMap<>();

// merge는 원자적 연산 (읽기-수정-쓰기를 한 번에)
map.merge("user1", 1, Integer::sum);
```

**ConcurrentHashMap의 주요 메서드**:

| 메서드 | 설명 | 사용 예시 |
|--------|------|-----------|
| `computeIfAbsent(key, fn)` | 키가 없을 때만 값 생성 | 맵 초기화 |
| `merge(key, value, fn)` | 값 병합 (카운트 증가) | 세션 수 카운트 |
| `compute(key, fn)` | 값 재계산 | 복잡한 업데이트 |
| `putIfAbsent(key, value)` | 키가 없을 때만 추가 | 중복 방지 |

---

### 실전 예시: 카운트 증가

```java
// ❌ HashMap (동시성 문제)
synchronized (map) {
    Integer count = map.get(key);
    map.put(key, count == null ? 1 : count + 1);
}

// ✅ ConcurrentHashMap (간결하고 안전)
map.merge(key, 1, Integer::sum);
```

---

## 인메모리 저장소의 장단점

### 장점 ✅
- **빠른 속도**: DB 조회 없이 메모리에서 즉시 접근
- **낮은 지연 시간**: 실시간 상태 관리에 적합
- **간단한 구현**: 복잡한 DB 스키마 불필요

### 단점 ❌
- **휘발성**: 서버 재시작 시 데이터 손실
- **확장성 제한**: 단일 서버에만 유효 (멀티 서버 환경 부적합)
- **메모리 사용**: 사용자 수가 많아지면 메모리 부족 가능

---

### 개선 방안 (프로덕션 환경)

**1. Redis 사용**
```java
// Redis로 분산 저장
redisTemplate.opsForHash().put("room:1:presence", "userA", "ONLINE");
```
- 여러 서버가 같은 Redis 공유
- 데이터 영속성 보장
- Pub/Sub 기능으로 서버 간 동기화

**2. 하이브리드 접근**
```
인메모리 캐시 (빠른 읽기)
    ↓
Redis (서버 간 공유)
    ↓
DB (영속성 보장)
```

---

## 💡 팁: 외부 API와 캐싱

**외부 API 호출은 비용 발생** (시간, 돈, 리소스)

```java
// ❌ 매번 API 호출 (비효율적)
public User getUser(String id) {
    return externalAPI.fetchUser(id);  // 매번 네트워크 요청
}

// ✅ 캐싱 사용 (효율적)
private final Map<String, User> cache = new ConcurrentHashMap<>();

public User getUser(String id) {
    return cache.computeIfAbsent(id, 
        key -> externalAPI.fetchUser(key)  // 최초 1회만 호출
    );
}
```

**캐싱 전략**:
- TTL(Time To Live): 일정 시간 후 자동 삭제
- LRU(Least Recently Used): 가장 오래된 데이터부터 삭제
- Write-Through: 쓰기 시 캐시와 DB 동시 업데이트

---

## 🎯 최종 정리

- **WebSocketEventsListener(관찰자)**: WebSocket 이벤트 감지 → 세션 관리 → 메시지 브로드캐스트
- **UserSessionRegistry(기록관)**: 세션-사용자 매핑 관리 → 중복 알림 방지 → 첫 입장/마지막 퇴장 판별
- **PresenceService(상태 관리자)**: 실시간 온라인/오프라인 상태 관리 → 상태 변경 브로드캐스트
- **ConcurrentHashMap**: `computeIfAbsent`, `merge` 등 원자적 연산으로 동시성 문제 해결
- **인메모리 저장**: 빠른 속도와 낮은 지연 시간 제공, 프로덕션에서는 Redis 등으로 확장 고려
- **핵심 포인트**: 3개 컴포넌트의 유기적 결합, 동시성 안전, 중복 알림 방지, 실시간 상태 동기화