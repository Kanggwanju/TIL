# 🗓️ 2025년 9월 16일 TIL


## 구독 및 해제 이벤트 처리와 사용자 상태 관리

### 📌 오늘의 키워드
- STOMP 
- WebSocket
- EventListener
- SimpMessagingTemplate
- UserSessionRegistry
- PresenceService
- 동시성 문제
- 인메모리

---

### 개념 정리

* **WebSocket 이벤트 리스너(WebSocketEventsListener.java)**

  * `SessionSubscribeEvent`, `SessionUnsubscribeEvent`, `SessionDisconnectEvent`와 같은 WebSocket 세션 이벤트를 감지
  * 사용자의 **채팅방 입장/퇴장** 상태를 시스템 메시지로 변환해 클라이언트에게 브로드캐스트
  * \*\*`UserSessionRegistry`\*\*를 사용하여 한 사용자가 여러 탭에서 접속해도 중복 알림이 발생하지 않도록 제어
  * \*\*`PresenceService`\*\*를 호출하여 사용자의 온라인 상태를 관리

* **사용자 세션 레지스트리(UserSessionRegistry.java)**

  * **목적**
    * 웹소켓 세션이 브라우저 탭마다 생성되는 문제를 해결하기 위해, 사용자 기준으로 \*\*"방 참여 수"\*\*를 관리
    * 이를 통해 중복된 **`JOIN`** 또는 **`LEAVE`** 메시지 브로드캐스트를 방지
  * **주요 기능**
    * `ConcurrentHashMap`을 사용해 `sessionId`, `subscriptionId`, `roomId`, `providerId` 간의 매핑 정보를 **인메모리**로 저장
    * 사용자(providerId)가 특정 방(roomId)에 접속한 **총 세션 수**를 카운트
    * 첫 접속(세션 수 1) 시에만 `JOIN` 알림을 위한 `true` 반환
    * 마지막 접속 해제(세션 수 0) 시에만 `LEAVE` 알림을 위한 `true` 반환

* **프레즌스 서비스(PresenceService.java)**

  * **목적**
    * 사용자의 \*\*실시간 온라인 상태(Presence)\*\*를 관리하고, 상태 변경을 클라이언트에게 즉시 알림
  * **주요 기능**
    * `ConcurrentHashMap`을 사용해 `{roomId → {providerId → status}}` 형태로 상태 정보 저장
    * `online`, `updateStatus`, `offline` 메서드를 통해 사용자의 상태를 관리하고, 변경 시 해당 방으로 **브로드캐스트**
    * `heartbeat` 기능을 통해 클라이언트가 주기적으로 보내는 신호를 받고 접속 상태를 유지

-----

### 코드 분석

* **`WebSocketEventsListener.java`**

  ```java
  @EventListener
  public void onSubscribe(SessionSubscribeEvent event) {
      // ... (생략)
      if (isChatTopic(destination, roomId)) {
          // 채팅 토픽 구독: 첫 입장인지 레지스트리에서 확인 후, JOIN 메시지 전송
          boolean firstJoin = registry.handleSubscribe(accessor.getSessionId(), accessor.getSubscriptionId(), roomId, providerId);
          if (firstJoin) {
              messagingTemplate.convertAndSend("/topic/rooms/" + roomId,
                  new SystemMessagePayload("JOIN", providerId, usersService.findMeByProviderId(providerId).getNickname() + " 님이 입장했습니다."));
          }
      }
      // ... (생략)
      if (isPresenceTopic(destination, roomId)) {
          // 프레즌스 토픽 구독: 첫 입장인지 확인 후, PresenceService를 통해 ONLINE 상태로 변경
          boolean firstPresence = registry.handlePresenceSubscribe(accessor.getSessionId(), accessor.getSubscriptionId(), roomId, providerId);
          if (firstPresence) {
              presenceService.online(roomId, providerId);
          }
      }
  }
  ```

  * `onSubscribe` 메서드에서 채팅 토픽(`isChatTopic`)과 프레즌스 토픽(`isPresenceTopic`)을 구분하여 처리
  * `UserSessionRegistry`의 `handleSubscribe` 및 `handlePresenceSubscribe` 메서드로 첫 입장 여부를 확인
  * `firstJoin` 또는 `firstPresence`가 `true`일 때만 `JOIN` 메시지 또는 `ONLINE` 상태를 전송하여 중복 알림을 방지

* **`UserSessionRegistry.java`**

  ```java
  // 사용자 단위 카운트 (예: 같은 사람이 탭 3개로 room 10을 구독하면 {10 → {userA: 3}})
  private final Map<Long, Map<String, Integer>> roomToProviderCount = new ConcurrentHashMap<>();

  public boolean handleSubscribe(String sessionId, String subscriptionId, Long roomId, String providerId) {
      // 세션 기준으로 이 방에 대한 첫 구독일 때만 사용자 카운트 증가
      int newCount = roomCountMap.merge(roomId, 1, Integer::sum);
      if (newCount > 1) return false;
      // 사용자 카운트가 1이라면 이 사용자가 "방 전체 기준"으로 첫 입장
      int after = increaseProviderCount(roomId, providerId);
      return after == 1;
  }

  private int increaseProviderCount(Long roomId, String providerId) {
      // `computeIfAbsent`와 `merge`를 활용하여 동시성 문제 해결
      Map<String, Integer> map = roomToProviderCount.computeIfAbsent(roomId, k -> new ConcurrentHashMap<>());
      return map.merge(providerId, 1, Integer::sum);
  }
  ```

  * `roomToProviderCount` 맵은 \*\*사용자(providerId)\*\*당 세션 수를 관리하여, 여러 탭 접속 시에도 정확한 입장/퇴장 상태를 파악
  * `handleSubscribe` 메서드에서 이 세션이 해당 방을 처음 구독할 때만 사용자 단위 카운트를 증가시킴
  * `increaseProviderCount` 메서드는 `ConcurrentHashMap`의 동시성 안전 메서드를 활용하여 \*\*데이터 경쟁(Race Condition)\*\*을 방지

* **`PresenceService.java`**

  ```java
  // 방마다 사용자별 현재 상태를 저장하는 인메모리 스토어
  private final Map<Long, Map<String, ParticipantStatus>> store = new ConcurrentHashMap<>();

  public void online(Long roomId, String providerId) {
      // `computeIfAbsent`를 사용해 해당 방의 맵이 없으면 새로 생성 후 상태 저장
      store
          .computeIfAbsent(roomId, k -> new ConcurrentHashMap<>())
          .put(providerId, ParticipantStatus.ONLINE);
      broadcast(roomId, providerId, ParticipantStatus.ONLINE);
  }
  ```

  * `store` 맵에 사용자의 현재 상태를 기록
  * `computeIfAbsent`는 키가 존재하지 않을 경우에만 맵을 생성하므로, NullPointerException을 방지하고 코드를 간결하게 만듦
  * 상태 변경 시 `broadcast` 메서드를 호출하여 클라이언트에게 실시간으로 업데이트된 상태를 전송

---

## 팁: 외부 API를 사용할 때는 한번의 요청마다 비용이 발생하기 때문에 주로 캐싱을 사용한다.

---

## 최종 정리

* **웹소켓 이벤트 리스너**는 사용자의 구독 및 해제 이벤트를 처리하는 **관찰자** 역할을 수행
* **세션 레지스트리**는 사용자가 여러 탭에서 접속해도 **중복 알림**이 발생하지 않도록 세션과 사용자 정보를 관리하는 **기록관** 역할
* **프레즌스 서비스**는 사용자의 **온라인/오프라인 상태**를 실시간으로 추적하고 알리는 **상태 관리자** 역할

이 세 가지 컴포넌트가 유기적으로 결합되어 실시간 채팅방의 정확하고 효율적인 **입장/퇴장 알림** 및 **프레즌스 상태 관리** 기능을 구현합니다.

