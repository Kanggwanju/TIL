# 🗓️ 2025년 9월 9일 TIL


## 오늘의 키워드

* React.memo
* 컴포넌트화
* useCallback
* key props
* useState 초기값
* Zustand
* Zustand persist

---

## 리액트 성능 최적화 테크닉

## 1. React.memo

카운터에 숫자를 입력 등의 동작을 했는데, 글자만 써져있는
헤더는 리렌더링 할 필요가 없지만, 리렌더링 됨.

강제로 리렌더링 하지 못하게 하는 React.memo

```jsx
const Header = () => {
  return (
    <header id='main-header'>
      <h1>React Optimizing</h1>
    </header>
  );
};
export default React.memo(Header);
```

---

## 2. 컴포넌트화
- 기존에 존재하던 카운터를 컴포넌트로 따로 분리
- 불필요한 리렌더링 방지, `memo` 보다 추천되는 방식, 잘게 쪼개는게 중요
- 이전에는 App에서 상태변수가 변경되어 모든 컴포넌트들이 리렌더링
- `ConfigureCounter` 컴포넌트 내부에서 상태가 변경되면서 해당 컴포넌트만 리렌더링  
```jsx
const App = () => {
  // ...
  return (
    <>
      <Header />
      <main>
        <ConfigureCounter onSet={setCounterHandler} />
        <Counter initialCount={chosenCount} />
      </main>
    </>
  );
};
```

---

## 3. useCallback
- 컴포넌트가 리렌더링 되면, 컴포넌트 내에 정의된 모든 함수들도 다시 생성
- `useCallback`을 사용하여 함수 재생성 방지
- 무분별하게 사용시 성능 저하

### 기존
```jsx
const decrementHandler = () => {
  setCounter((prevCounter) => prevCounter - 1);
};

const incrementHandler = () => {
  setCounter((prevCounter) => prevCounter + 1);
};
```

### useCallback 사용
```jsx
const decrementHandler = useCallback(() => {
  setCounter((prevCounter) => prevCounter - 1);
}, []);

const incrementHandler = useCallback(() => {
  setCounter((prevCounter) => prevCounter + 1);
}, []);
```

---

## 4. key props
- key props를 동적으로 설정하면 리렌더링이 잘못 일어나는 문제 발생
- key는 항상 고정값으로 설정

---

## 5. useState 초기값
- 일반적인 리렌더링은 상태값이 변하지 않음
- 하지만 key 값이 변경되는 리렌더링은 상태값이 초기값으로 변경됨.

컴포넌트에 키 속성을 넣어줌, chosenCount는 입력으로 변경되는 값
```jsx
const App = () => {
  // ...
  return (
    <>
      <Header />
      <main>
        <ConfigureCounter onSet={setCounterHandler} />
        <Counter key={chosenCount} initialCount={chosenCount} />
      </main>
    </>
  );
};
```

키가 변경 -> 상태값이 초기값으로 변경
하지만, 키와 프롭스가 동일, 내가 정한 초기값으로 바꿔줌
- 키 변경 말고도 useEffect 사용도 가능
```jsx
const Counter = ({ initialCount }) => {
  log('<Counter /> rendered', 1);

  const initialCountIsPrime = isPrime(initialCount);

  const [counterChanges, setCounterChanges]
    = useState([{id: Math.random().toString(), value: initialCount}]);

// useEffect(() => {
//   setCounterChanges([{id: Math.random().toString(), value: initialCount}]);
// }, [initialCount]);
  
};
```

---

## Zustand 개념
- 전역상태 관리 라이브러리

1. Provider 불필요
  - Context처럼 트리 상단에 Provider를 두지 않아도 됨
  - 전역 스토어(가게의 본사 창고)를 만들고, 컴포넌트는 훅으로 필요한 재고만 꺼내 씀

2. 보일러플레이트 최소화
  - reducer, action type 없이 간결한 API(`create`, `set`)

3. 미들웨어 지원
  - persist(보관함), devtools(CCTV), immer(안전 작업대)
  - 실전에서 유용한 도구들을 바로 얹을 수 있음

## Context API와의 비교(핵심 포인트)

1. 구성 방식
  - Context: Provider 트리 설계가 필요, 범위를 나누려면 다중 Provider 설계도 필요
  - Zustand: Provider 없이 모듈 하나로 전역 스토어 구성

2. 리렌더링


### Zustand 라이브러리 설치
```shell
npm install zustand
```

---


### Zustand 중앙 상태 저장소
- 생성
```js
// counterStore.js
import {create} from 'zustand';

// 중앙 상태 저장소 생성
export const useCounterStore
  = create((set) => ({

  // 전역 관리할 상태값들을 배치
  count: 99,
  showCounter: true
}));
```
팁: 객체 리턴을 하려면 중괄호를 소괄호로 묶으면 된다!


- 상태 구독(사용)
  - useCounterStore에 상태값이 들어있고 바로 사용 가능
```jsx
const { count, showCounter } = useCounterStore();
```


### Zustand 액션함수

1. 액션함수 설정
- 상태값을 변경하는 액션함수들을 객체 형태로 배치
- set 함수로 상태값을 변경할 수 있음
- 콜백의 파라미터 state는 이전상태값 모음 객체를 의미

```js
export const useCounterStore
  = create((set) => ({

  count: 0,
  showCounter: true,
  
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  multiply: (amount) => set((state) => ({ count: state.count * amount })),
  toggle: () => set((state) => ({ showCounter: !state.showCounter })),
}));
```

2. 액션함수 사용
```jsx
// ZustandCounter.jsx
// 상태 구독
const { count, showCounter, increment, decrement, multiply, toggle } = useCounterStore();

return (
    // ...
    <button onClick={increment}>Increment</button>
    <button onClick={decrement}>Decrement</button>
    <button onClick={() => multiply(3)}>×3</button>
    // ...
    <button onClick={toggle}>Toggle Counter</button>
);
```

---

### 상태 영속화 (persist)
- Zustand의 `persist` 미들웨어는 특정 상태를 저장/복원
- 예) 로그인 여부, 사용자 환경 설정(다크 모드, 언어)
- 로컬스토리지에 정보 저장
- 주의점은 민감정보 저장하지 말 것

인증 관련 상태값 중앙 저장소
```js
// counterStore.js
export const useAuthStore = create(
  persist((set) => ({

    // 관리할 상태값
    isLoggedIn: false,

    // 상태변경 함수 (액션 함수)
    login: () => set(() => {
      return ({isLoggedIn: true});
    }),
    logout: () => set(() => ({ isLoggedIn: false })),
  }),
    {
      name: 'auth', // localStorage Key
      // 절대 민감정보 (ex - token) 로컬스토리지에 저장하면 안됨
      partialize: (state) => ({ isLoggedIn: state.isLoggedIn })
    })
);
```

---

## 📌 오늘의 요약

* **리액트 성능 최적화**: **컴포넌트 분리**로 상태 변화의 영향을 받는 범위를 최소화
  `React.memo`, `useCallback`으로 불필요한 리렌더링을 방지
* `Zustand`: `Provider` 없이 간결하게 전역 상태를 관리하고,
  `persist` 미들웨어를 통해 상태를 로컬 스토리지에 저장 가능
* `key` props: 리렌더링 문제가 발생하지 않도록 항상 고정값으로 설정해야 함

