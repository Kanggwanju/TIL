# 🗓️ 2025년 11월 5일 TIL - c언어

## 📌 오늘의 키워드

`strlen()` `sizeof()` `strcpy()` `strncpy()` `strcmp()` `fgets()` `버퍼 오버플로우`

---

## 문자열의 길이 확인 (`strlen`, `sizeof`)

### 개념 정리

* `strlen()` : 문자열의 **글자 수(널 문자 제외)** 반환
* `sizeof()` : **배열의 전체 바이트 수(널 문자 포함)** 반환

### 예시 코드

```c
char a[] = "apple";        // 글자수 5, 널 포함 6바이트
char b[] = "Hong Gildong"; // 글자수 11, 널 포함 12바이트
char c[20] = "hello";      // 글자수 5, 배열 크기 20바이트

printf("'%s'의 sizeof 결과: %lu 바이트\n", a, sizeof(a));   // 6
printf("'%s'의 strlen 결과: %lu 글자\n", a, strlen(a));     // 5
printf("'%s'의 strlen 결과: %lu 글자\n", b, strlen(b));     // 11
printf("'%s'의 strlen 결과: %lu 글자\n", c, strlen(c));     // 5
printf("'%s'의 sizeof 결과: %lu 바이트\n", c, sizeof(c));   // 20
```

### 포인트

* `strlen()`은 문자열의 끝(`'\0'`)까지 세지 않음.
* `sizeof()`는 배열 전체 크기(할당된 바이트 수)를 반환.
* `strlen()`은 문자열의 실제 길이를, `sizeof()`는 배열 크기를 확인할 때 사용함

---

## 문자열 복사 (`strcpy`)

### 개념 정리

* `strcpy(목적지, 원본)` : 문자열을 통째로 복사함.
* 단, **버퍼 크기보다 큰 문자열을 복사하면 오버플로우 위험**이 있음.

### 예시 코드

```c
char origin[] = "apple";
char copy[10];

strcpy(copy, origin);

printf("원본: %s\n", origin);
printf("사본: %s\n", copy);
```

### 포인트

* 문자열은 `=`으로 복사할 수 없음 (`copy = origin;` 불가능).
* `strcpy()` 사용 시 목적지 배열의 크기를 반드시 확인해야 함

---

## 안전한 문자열 복사 (`strncpy`)

### 개념 정리

* `strncpy(목적지, 원본, 복사할 글자 수)` : 복사할 최대 길이를 지정 가능.
* 단, 자동으로 `'\0'`을 추가하지 않으므로 **직접 넣어야 함**.

### 예시 코드

```c
char origin[] = "strawberry";
char copy[6];

strncpy(copy, origin, 5);
copy[5] = '\0';

printf("안전하게 복사된 문자열: %s\n", copy);
```

### 포인트

* `strncpy()`는 오버플로우 방지에 유용하지만 **널 문자 처리**를 꼭 확인해야 함.
* 복사 후 항상 `copy[n] = '\0';`로 수동 종료해야 함

---

## 문자열 비교 (`strcmp`)

### 개념 정리

* `strcmp(문자열1, 문자열2)` : 두 문자열의 내용을 비교.
* 반환값:

  * `0` → 두 문자열이 같음
  * `< 0` → 첫 번째 문자열이 사전 순으로 앞
  * `> 0` → 첫 번째 문자열이 사전 순으로 뒤

### 예시 코드

```c
char password[] = "pass1234";
char input[20];

printf("비밀번호를 입력하세요: ");
scanf("%s", input);

if (strcmp(password, input) == 0)
    printf("로그인 성공!\n");
else
    printf("비밀번호가 틀렸습니다.\n");
```

### 포인트

* `==` 연산자는 문자열의 **주소**를 비교하므로 사용하면 안 됨.
* 문자열 내용 비교는 반드시 `strcmp()`로 해야 함

---

## 문자열 입력 (`fgets`)

### 개념 정리

* `fgets(배열, 크기, stdin)` : 공백 포함 문자열을 입력받을 수 있음.
* 엔터(`\n`)까지 함께 저장되므로 마지막 글자를 `'\0'`으로 변경해야 함.

### 예시 코드

```c
char intro[50];

printf("자기 소개를 한 줄 입력해주세요!\n");
fgets(intro, 50, stdin);

// 개행 문자 제거
intro[strlen(intro) - 1] = '\0';

printf("\n--- 자기 소개 ---\n");
printf("%s\n", intro);
```

### 포인트

* `scanf("%s")`는 공백 입력 불가하지만 `fgets()`는 가능.
* 버퍼 크기를 지정해 **오버플로우 방지** 가능

---

## 문자열 복사의 위험성 (메모리 구조)

### 개념 정리

* 문자열 복사 시 **널 문자(`'\0'`)가 누락되면**
  프로그램이 메모리 끝까지 계속 읽게 되어 예기치 않은 결과 발생.

### 예시 코드

```c
char src[] = "123";
char dest[5] = "abcde";

strncpy(dest, src, 3);
printf("%s", dest); // '123de' 또는 쓰레기 값 출력
```

### 포인트

* `'\0'`이 없으면 문자열이 끝나는 지점을 알 수 없음.
* 배열 크기와 복사 길이를 항상 정확히 지정해야 함

---

## 🎯 최종 정리

* `strlen()` : 문자열의 **길이(널 제외)**
* `sizeof()` : 배열의 **총 크기(널 포함)**
* `strcpy()` : 문자열 복사 (위험)
* `strncpy()` : 안전한 복사 (단, 널 문자 직접 추가 필요)
* `strcmp()` : 문자열 비교 (주소 비교 `==` 금지)
* `fgets()` : 공백 포함 입력 가능, 버퍼 크기로 오버플로우 방지

---

### 오늘의 소감

오늘은 문자열 함수들을 학습하면서,
**C언어에서 문자열이 단순한 텍스트가 아니라 메모리 배열이라는 사실**을 다시 한 번 실감했다.
특히 `'\0'` 누락이나 버퍼 크기 실수로 인한 오작동이 쉽게 발생한다는 점에서,
입력 함수(`fgets`)나 안전한 복사 함수(`strncpy`)의 중요성을 체감할 수 있었다.
문자열 처리 시 **항상 메모리의 경계를 의식하는 습관**을 들이는 것이 핵심이다.
