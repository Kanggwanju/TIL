# 🗓️ 2025년 10월 23일 TIL

## 📌 오늘의 키워드
`순환 참조` `생성자 주입` `Spring Events` `@Lazy` `ApplicationEventPublisher` `이벤트 기반 아키텍처` `의존성 주입` `@EventListener` `발행-구독 패턴`

---

## 순환 참조 (Circular Dependency)

### 개념

**순환 참조(Circular Dependency)** 는 두 개 이상의 빈(Bean)이 서로를 의존하는 상황을 말한다.

```java
class A {
    private B b;  // A는 B를 필요로 함
}

class B {
    private A a;  // B는 A를 필요로 함
}
```

### 왜 문제가 될까?

Spring 컨테이너가 Bean을 생성하는 과정:

```
1. A를 생성하려면 → B가 필요
2. B를 생성하려면 → A가 필요
3. A를 생성하려면 → B가 필요 (무한 반복!)
```

결과: `BeanCurrentlyInCreationException` 발생

### 순환 참조의 종류

#### 1) 생성자 주입 순환 참조
```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final OrderService orderService;  // ❌ 즉시 예외 발생
}

@Service
@RequiredArgsConstructor
public class OrderService {
    private final UserService userService;  // ❌ 즉시 예외 발생
}
```

**특징**: 컴파일/실행 시점에 즉시 감지됨 (좋은 것!)

#### 2) 필드/Setter 주입 순환 참조
```java
@Service
public class UserService {
    @Autowired
    private OrderService orderService;  // ⚠️ 런타임에 문제 발생 가능
}

@Service
public class OrderService {
    @Autowired
    private UserService userService;  // ⚠️ 런타임에 문제 발생 가능
}
```

**특징**: 초기화 후 사용 시점에 문제 발견될 수 있음 (나쁜 것)

### 순환 참조 해결 방법

#### 방법 1: 구조 개선 (권장)
```java
// Before: 순환 참조
UserService ⟷ OrderService

// After: 의존성 재구성
UserService → OrderFacade ← OrderService
```

#### 방법 2: @Lazy 사용 (임시 방편)
```java
@Service
@RequiredArgsConstructor
public class UserService {
    @Lazy  // 실제 사용 시점까지 초기화 지연
    private final OrderService orderService;
}
```

#### 방법 3: Setter 주입으로 변경 (권장하지 않음)
```java
@Service
public class UserService {
    private OrderService orderService;
    
    @Autowired
    public void setOrderService(OrderService orderService) {
        this.orderService = orderService;
    }
}
```

#### 방법 4: 이벤트 기반으로 전환 (권장)
```java
// A → B 직접 호출 대신
// A → Event 발행 → B가 수신
```

---

## 생성자 주입 (Constructor Injection)

### 의존성 주입(DI)의 3가지 방법

#### 1) 필드 주입 (Field Injection)
```java
@Service
public class UserService {
    @Autowired  // 리플렉션을 사용해 주입
    private UserRepository userRepository;
}
```

**단점**:
- 불변성 보장 안됨 (언제든 변경 가능)
- 순환 참조를 늦게 발견
- 테스트 시 Mock 주입이 번거로움
- final 키워드 사용 불가

#### 2) Setter 주입 (Setter Injection)
```java
@Service
public class UserService {
    private UserRepository userRepository;
    
    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

**단점**:
- 불변성 보장 안됨
- NPE 위험 (setter 호출 전 사용 가능)
- 선택적 의존성에만 사용 권장

#### 3) 생성자 주입 (Constructor Injection) - 권장
```java
@Service
@RequiredArgsConstructor  // Lombok이 생성자 자동 생성
public class UserService {
    private final UserRepository userRepository;  // final 사용 가능!
    
    // 생성자를 통해 주입
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

### 생성자 주입의 장점

#### 1. 불변성 보장
```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository repository;  // final → 재할당 불가
    
    public void someMethod() {
        // this.repository = new UserRepository();  // 컴파일 에러
    }
}
```

#### 2. 순환 참조 조기 발견
```java
// 생성자 주입: 애플리케이션 시작 시 즉시 예외 발생
@RequiredArgsConstructor
public class A {
    private final B b;
}

@RequiredArgsConstructor
public class B {
    private final A a;  // BeanCurrentlyInCreationException 발생
}
```

#### 3. 테스트 용이성
```java
@Test
void testUserService() {
    // Mock 객체를 생성자로 주입하기 쉬움
    UserRepository mockRepository = mock(UserRepository.class);
    UserService service = new UserService(mockRepository);
    
    // 테스트 수행
}
```

#### 4. 의존성 명시
```java
// 생성자를 보면 어떤 의존성이 필요한지 한눈에 파악 가능
public UserService(
    UserRepository userRepository,
    EmailService emailService,
    LogService logService
) {
    // 의존성이 많으면 → 클래스 책임이 과도할 수 있다는 신호!
}
```

### 생성자 주입 베스트 프랙티스

```java
// Good: @RequiredArgsConstructor + final
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final EmailService emailService;
}

// Good: 명시적 생성자 (의존성이 복잡한 경우)
@Service
public class UserService {
    private final UserRepository userRepository;
    private final EmailService emailService;
    
    public UserService(
        UserRepository userRepository,
        EmailService emailService
    ) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }
}

// Bad: 필드 주입
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
}
```

---

## Spring Events

### 이벤트 기반 아키텍처란?

**발행-구독 패턴(Pub-Sub Pattern)** 을 사용하여 컴포넌트 간 결합도를 낮추는 방식

```
발행자(Publisher) --[이벤트 발행]--> Spring Event System --[이벤트 전달]--> 구독자(Listener)
```

### 기본 구성 요소

#### 1. 이벤트 클래스 (Event)
```java
// 1) 일반 클래스로 정의 (Spring 4.2+)
public class UserRegisteredEvent {
    private final Long userId;
    private final String email;
    
    public UserRegisteredEvent(Long userId, String email) {
        this.userId = userId;
        this.email = email;
    }
    
    // Getter
}

// 2) Lombok 활용
@Getter
@RequiredArgsConstructor
public class UserRegisteredEvent {
    private final Long userId;
    private final String email;
}
```

#### 2. 이벤트 발행자 (Publisher)
```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final ApplicationEventPublisher eventPublisher;  // Spring이 자동 주입
    
    public void registerUser(String email, String password) {
        // 1. 비즈니스 로직 수행
        User user = userRepository.save(new User(email, password));
        
        // 2. 이벤트 발행
        eventPublisher.publishEvent(new UserRegisteredEvent(user.getId(), email));
        
        // 3. 이후 로직 계속 실행 (동기)
        log.info("User registered: {}", email);
    }
}
```

#### 3. 이벤트 리스너 (Listener)
```java
@Component
@Slf4j
public class UserEventListener {
    
    // 방법 1: @EventListener (권장)
    @EventListener
    public void handleUserRegistered(UserRegisteredEvent event) {
        log.info("환영 이메일 발송: {}", event.getEmail());
        // 이메일 발송 로직
    }
    
    // 방법 2: @TransactionalEventListener (트랜잭션 제어)
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleAfterCommit(UserRegisteredEvent event) {
        log.info("DB 커밋 후 실행: {}", event.getEmail());
        // 외부 API 호출 등
    }
    
    // 방법 3: 조건부 실행
    @EventListener(condition = "#event.userId > 1000")
    public void handleVipUser(UserRegisteredEvent event) {
        log.info("VIP 사용자 처리: {}", event.getUserId());
    }
}
```

### Spring Events 주요 특징

#### 1. 동기 vs 비동기

```java
// 기본: 동기 실행
@EventListener
public void handle(UserRegisteredEvent event) {
    // 발행자 스레드에서 실행
    // 이 메서드가 끝나야 발행자가 다음 코드 실행
}

// 비동기 실행 (@EnableAsync 필요)
@Async
@EventListener
public void handle(UserRegisteredEvent event) {
    // 별도 스레드에서 실행
    // 발행자는 기다리지 않고 즉시 다음 코드 실행
}
```

#### 2. 트랜잭션 제어

```java
@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
public void handleAfterCommit(UserRegisteredEvent event) {
    // DB 트랜잭션이 커밋된 후에만 실행
    // 롤백되면 실행 안됨!
}

@TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT)
public void handleBeforeCommit(UserRegisteredEvent event) {
    // 커밋 직전 실행
}

@TransactionalEventListener(phase = TransactionPhase.AFTER_ROLLBACK)
public void handleAfterRollback(UserRegisteredEvent event) {
    // 롤백 후 실행
}
```

#### 3. 여러 리스너 등록 가능

```java
// 리스너 1: 이메일 발송
@Component
class EmailListener {
    @EventListener
    public void sendEmail(UserRegisteredEvent event) {
        // 이메일 발송
    }
}

// 리스너 2: 통계 업데이트
@Component
class StatisticsListener {
    @EventListener
    public void updateStats(UserRegisteredEvent event) {
        // 통계 업데이트
    }
}

// 리스너 3: 알림 전송
@Component
class NotificationListener {
    @EventListener
    public void sendNotification(UserRegisteredEvent event) {
        // 알림 전송
    }
}

// 하나의 이벤트 발행 → 세 리스너 모두 실행!
```

#### 4. 우선순위 지정

```java
@Component
class MyListener {
    
    @EventListener
    @Order(1)  // 먼저 실행
    public void handleFirst(UserRegisteredEvent event) {
        // 1순위 처리
    }
    
    @EventListener
    @Order(2)  // 나중에 실행
    public void handleSecond(UserRegisteredEvent event) {
        // 2순위 처리
    }
}
```

### Spring Events 활용 패턴

#### 패턴 1: 도메인 이벤트
```java
// 주문 생성 시
@Service
public class OrderService {
    @Transactional
    public void createOrder(Order order) {
        orderRepository.save(order);
        eventPublisher.publishEvent(new OrderCreatedEvent(order.getId()));
    }
}

// 재고 감소 (리스너)
@Component
class InventoryListener {
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void decreaseStock(OrderCreatedEvent event) {
        // 주문 커밋 후 재고 감소
    }
}
```

#### 패턴 2: 횡단 관심사 (Cross-Cutting Concerns)
```java
// 모든 비즈니스 이벤트 로깅
@Component
@Slf4j
class AuditListener {
    @EventListener
    public void logEvent(ApplicationEvent event) {
        log.info("Event occurred: {}", event.getClass().getSimpleName());
    }
}
```

#### 패턴 3: 순환 참조 해결
```java
// Before: 순환 참조
A → B → A  // ❌

// After: 이벤트 사용
A → Event → B  // ✅
```

---

## 실전 예제: 순환 참조 해결하기

### 문제 상황

```java
@Service
@RequiredArgsConstructor
public class WebSocketSessionService {
    private final GameRoomLeaveService leaveService;  // ← GameRoomLeaveService 의존
    
    public void handleDisconnect(Long userId) {
        leaveService.leaveCurrentRoomByUser(userId);
    }
}

@Service
@RequiredArgsConstructor
public class GameRoomLeaveService {
    private final WebSocketSessionService sessionService;  // ← WebSocketSessionService 의존
    
    public void handleHostLeave(Long roomId, List<Long> userIds) {
        sessionService.cleanupSessions(userIds);  // 💥 순환 참조!
    }
}
```

**결과**: `BeanCurrentlyInCreationException` 발생

### 1단계 해결: @Lazy 적용

```java
@Service
public class GameRoomLeaveService {
    private final WebSocketSessionService sessionService;
    
    // @RequiredArgsConstructor 대신 명시적 생성자
    public GameRoomLeaveService(@Lazy WebSocketSessionService sessionService) {
        this.sessionService = sessionService;  // 지연 초기화
    }
}
```

**장점**: 빠르게 문제 해결  
**단점**: 순환 참조는 여전히 존재 (기술 부채)

### 2단계 해결: Spring Events 적용

#### Step 1: 이벤트 정의
```java
@Getter
@RequiredArgsConstructor
public class RoomClosedEvent {
    private final Long roomId;
    private final List<Long> remainingUserIds;
}
```

#### Step 2: 발행자 수정
```java
@Service
@RequiredArgsConstructor
public class GameRoomLeaveService {
    private final ApplicationEventPublisher eventPublisher;  // sessionService 제거!
    
    public void handleHostLeave(Long roomId, List<Long> userIds) {
        // 1. 방 종료 로직
        closeRoom(roomId);
        
        // 2. 이벤트 발행 (세션 정리는 리스너가 처리)
        eventPublisher.publishEvent(new RoomClosedEvent(roomId, userIds));
    }
}
```

#### Step 3: 구독자 추가
```java
@Service
@RequiredArgsConstructor
public class WebSocketSessionService {
    // leaveService 의존성은 그대로 유지 (단방향이므로 OK)
    
    @EventListener
    public void handleRoomClosed(RoomClosedEvent event) {
        // 이벤트 수신 → 세션 정리
        cleanupSessions(event.getRemainingUserIds());
    }
}
```

### 결과 비교

```
[Before: 순환 참조]
WebSocketSessionService ⟷ GameRoomLeaveService
└─ 실행 불가

[1단계: @Lazy]
WebSocketSessionService ⟷ GameRoomLeaveService (지연)
└─ 실행 가능, but 순환 참조 여전히 존재

[2단계: Events]
WebSocketSessionService → GameRoomLeaveService
                              ↓ (이벤트)
                   WebSocketSessionService (리스너)
└─ 단방향 의존성, 순환 참조 완전 제거
```

---

## 최종 정리

### 핵심 개념 요약

**1. 순환 참조 (Circular Dependency)**
```
- 정의: 두 개 이상의 빈이 서로를 의존하는 상황
- 문제: Bean 생성 불가 → BeanCurrentlyInCreationException
- 해결: 구조 개선, @Lazy, 이벤트 기반 전환
```

**2. 생성자 주입 (Constructor Injection)**
```
장점:
   - 불변성 보장 (final 사용)
   - 순환 참조 조기 발견
   - 테스트 용이성
   - 의존성 명시
   
권장: @RequiredArgsConstructor + final 조합
지양: 필드 주입 (@Autowired)
```

**3. Spring Events**
```
핵심: 발행-구독 패턴으로 결합도 낮춤
구성: Event 클래스 + Publisher + Listener
특징:
   - 동기/비동기 선택 가능
   - 트랜잭션 제어 가능
   - 여러 리스너 등록 가능
   - 순환 참조 해결
```

### 언제 무엇을 사용할까?

| 상황 | 해결 방법 | 우선순위 |
|------|----------|---------|
| 순환 참조 발생 | 구조 개선 또는 Events | 높음 |
| 긴급 배포 필요 | @Lazy 임시 적용 | 중간 |
| 의존성 주입 | 생성자 주입 | 높음 |
| 비동기 처리 필요 | @Async + Events | 높음 |
| 여러 후속 작업 | Events (여러 리스너) | 높음 |

### 오늘의 교훈

**1. 순환 참조는 설계 냄새(Code Smell)다**
- 두 클래스가 서로를 참조한다면, 책임 분리를 다시 생각해보자
- `@Lazy`는 임시방편일 뿐, 근본 해결책이 아니다

**2. 생성자 주입을 항상 사용하자**
- 불변성, 안정성, 테스트 용이성 모두 확보
- Lombok의 `@RequiredArgsConstructor`를 적극 활용

**3. 이벤트 기반은 강력하다**
- 서비스 간 결합도를 낮추는 가장 우아한 방법
- 확장성과 유지보수성이 크게 향상됨
- 처음엔 복잡해 보이지만, 익숙해지면 매우 유용함

### 다음 학습 주제

- Spring의 트랜잭션 전파 (Transaction Propagation)
- @Async 심화 (ThreadPoolTaskExecutor 설정)
- 도메인 주도 설계 (DDD)의 도메인 이벤트
- CQRS 패턴과 이벤트 소싱

### 참고 자료

- [Spring Framework - Core Technologies](https://docs.spring.io/spring-framework/reference/core.html)
- [Spring Events Documentation](https://docs.spring.io/spring-framework/reference/core/beans/context-introduction.html#context-functionality-events)
- [Baeldung - Constructor Injection](https://www.baeldung.com/constructor-injection-in-spring)
- [Baeldung - Spring Events](https://www.baeldung.com/spring-events)

---

## 📝 오늘의 정리

오늘은 실제 프로젝트에서 발생한 순환 참조 문제를 해결하면서 Spring의 의존성 관리와 이벤트 시스템을 깊이 있게 공부할 수 있었다.

특히 **"왜 생성자 주입을 사용해야 하는가?"** 와 **"이벤트 기반 아키텍처의 진정한 가치"** 를 몸소 체험했다.

처음엔 `@Lazy`로 빠르게 해결했지만, 이것이 임시방편이라는 걸 깨닫고 Spring Events로 리팩토링하면서 더 나은 코드 구조를 만들 수 있었다.

앞으로는 두 클래스가 서로를 참조하는 상황이 생기면, 무조건 **"설계가 잘못된 건 아닐까?"** 를 먼저 고민해보는 습관을 가져야겠다.

**"좋은 코드는 빠르게 작동하는 코드가 아니라, 유지보수하기 좋은 코드다."**
