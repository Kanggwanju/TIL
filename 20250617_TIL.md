# 🗓️ 2025년 6월 17일 TIL


클로저 실습 - 용사 전투

클로저 함수에서 나는 체력만 관리하는 용도로 함수를 정의했으나, 
선생님은 용사 데이터들을 생성하는 클로저 함수로 정의함.
클로저 함수 리턴은 아래와 같은 형식으로 정의하셨다.
이를 통해 각 버튼을 눌렀을 때 클로저 함수를 통해 상태 제어가 가능해짐.
```js
return {
  takeDamage: () => {}, // 피해를 입었을 때 발동
  heal: () => {}, // 회복했을 때 발동
  attack: () => {}, // 일반공격시 발동
  useSpecialMove: () => {}, // 필살기 발동
  getStatus: () => ({ name, health, maxHealth }), // 자기 정보 가져오기
};
```


용사 소환 로그, 버튼 클릭 로그 출력을 하나의 함수로 만들음
나는 버튼 클릭 이벤트 마다 로그 출력 코드를 적어 넣었는데,
파라미터를 통해 각 버튼에 따라 다른 동작을 하게 만든게 인상깊음.
```js
// 로그를 화면에 출력하는 함수 정의
function addLog($logDiv, message) {
  const $logEntry = document.createElement('div');
  $logEntry.textContent = message;
  $logEntry.classList.add('log-entry');

  $logDiv.append($logEntry);

  // 새 로그가 찍히면 자동으로 스크롤을 최하단에 위치
  $logDiv.scrollTop = $logDiv.scrollHeight;
}
```

새 로그가 찍히면 자동으로 스크롤을 최하단에 위치 시키는 법을
새로 배웠음.
```js
// 새 로그가 찍히면 자동으로 스크롤을 최하단에 위치
$logDiv.scrollTop = $logDiv.scrollHeight;
```



나는 용사 스테이터스 가시화를 처음 생성 버튼을 눌렀을 때,
체력에 변화가 생겼을 때만 코드로 바꿔주었음.
선생님은 함수로 만들어서 파라미터를 $statusDiv, hero를 넘겨줬다.
여기서 hero는 함수 객체이고, hero.heal(), hero.getStatus() 등을 사용 가능

```js
// 생성 버튼 이벤트 바인딩 내부

// 용사 생성
const hero = createHero(heroName, specialMove);

// 영웅 상태정보 UI 업데이트 함수
function updateHeroStatus($statusDiv, hero) {
  // 현재 영웅의 체력이나 이름정보를 알아와야 하는데
  // 이건 클로저가 생성한 영웅정보를 받아와야 알 수 있다.
  const { name, health, maxHealth } = hero.getStatus();
  $statusDiv.textContent = `🛡️ ${name} | HP: ${health} / ${maxHealth}`;
}

// 스테이터스 업데이트 처리
updateHeroStatus($statusDiv, hero);
```


옵저버 스크롤
하단 감지 바를 display: none 으로 하지말고 아이콘을 안보이게 만들음.

Intersection Observer 설정
- 옵저버에게 특정 **태그를 지속적**으로 감시하게 하여
해당 태그가 뷰포트에 보이는 순간 특정 행동을 실행하도록 명령
callback : 감시대상을 제어하는 함수



validation
이메일 유효성 검사 이벤트는 debounce를 입력이 끝나고 살짝의 딜레이를
준 후 실행함.



## 🎮 UP & DOWN 게임 구현 개선 내용 정리

### 🔹 1. 콘솔 로그가 두 번 찍히는 이유
- `index.html`에서 같은 JavaScript 파일 (`app.js`)을 `<script>`로 두 번 import했기 때문.
- `defer`를 붙인 script 하나만 남겨두면 해결됨.
  
```html
<!-- ✅ 이렇게만 남겨야 함 -->
<script src="js/app.js" defer></script>
```

---

### 🔹 2. 사용자 입력이 난수와 같은지 비교하는 방법

* `submit` 이벤트에서 input 값을 읽고, 클로저 내부의 `secret` 값과 비교.
* `form.submit()`을 실행하면 새로고침되므로 사용하지 말고 `e.preventDefault()`로 제출만 막는다.

```js
$form.addEventListener('submit', e => {
  e.preventDefault();
  const userGuess = +$input.value;

  if (userGuess === random.getStatus().secret) {
    alert('정답입니다!');
  }
});
```

---

### 🔹 3. `.modal-overlay.show`의 의미

* `.modal-overlay`는 기본적으로 숨겨진 모달창.
* `.show` 클래스가 추가되면 `display: flex`로 보여지도록 설정함.

```css
.modal-overlay {
  display: none;
}

.modal-overlay.show {
  display: flex;
}
```

---

### 🔹 4. 구조 분해 할당의 위험성

* `const { minValue, maxValue, chance, secret } = random.getStatus();` 처럼 구조 분해하면 값이 고정됨.
* `chance`나 `minValue`, `maxValue`는 매번 변하므로, `random.getStatus()`로 **실시간 상태를 직접 호출**해야 함.

```js
// ❌ 초기값 고정됨
const { chance } = random.getStatus();

// ✅ 항상 최신 상태를 반영함
if (random.getStatus().chance === 0) {
  gameOver();
}
```

---

### 🔹 5. gameOver 함수가 실행되지 않던 이유

* 구조 분해로 가져온 `chance` 값이 업데이트되지 않기 때문.
* 해결: `random.getStatus().chance`를 통해 최신 값을 비교.

---

### 🔹 6. 입력값 검증에서 minValue와 maxValue도 구조 분해하면 안 되는 이유

* `minValue`, `maxValue`는 게임 중 바뀌는 값.
* 따라서 구조 분해가 아닌, `random.getStatus().minValue` 등으로 **직접 접근해야 정확한 범위 검증** 가능.

```js
const { minValue, maxValue } = random.getStatus();
if (userGuess < minValue || userGuess > maxValue) {
  alert(`범위는 ${minValue} ~ ${maxValue} 입니다.`);
}
```

---

### 📝 배운 점 요약

* 구조 분해 할당은 상태가 "고정된 값"에만 사용해야 한다.
* `form.submit()`은 새로고침을 유발하므로 사용하지 말고 이벤트 핸들링으로 제어한다.
* `.modal-overlay.show`처럼 클래스 조합으로 UI 표시를 제어하는 방식은 유용하다.
* 게임 상태(`minValue`, `maxValue`, `chance`)는 항상 `getStatus()`를 통해 실시간으로 가져오는 습관을 들이자.

