# 🗓️ 2025년 12월 10일 TIL - C언어

## 📌 오늘의 키워드

`BFS (너비 우선 탐색)` `Queue(큐)` `인접 리스트`
`DFS vs BFS` `그래프 탐색` `레벨 탐색(Level Order)`

---

## 1️⃣ BFS(너비 우선 탐색, Breadth First Search)란?

### 💡 개념

* **BFS**는 그래프 탐색 알고리즘으로
  **시작점에서 가까운 정점부터(=레벨별로)** 방문하는 방식이다.
* 즉, **넓게 퍼져 나가듯** 탐색한다.

### 📌 핵심 특징

| 항목    | 설명              |
| ----- | --------------- |
| 탐색 방향 | 깊게 → 아니라 **넓게** |
| 기준    | 거리(레벨)가 가까운 순   |
| 사용 도구 | 큐(Queue)        |
| 방문 방식 | FIFO (선입선출)     |

---

## 2️⃣ BFS에 큐(Queue)를 사용하는 이유

### 📦 큐의 특징

* 큐는 **선입선출(FIFO)**
* 즉, **먼저 발견된 정점을 먼저 탐색**한다.
* 이것이 BFS의 **“가까운 정점 먼저” 탐색 원리**와 딱 맞다.

---

## 3️⃣ BFS의 동작 원리 (핵심 흐름)

```plaintext
[발견하면 큐에 넣고 → 큐에서 꺼낸 순서대로 방문]
```

### 단계 요약

1. **시작 정점을 방문 처리**하고 큐에 삽입
2. 큐에서 **가장 오래 대기한 정점**을 꺼낸다
3. 그 정점의 **이웃을 확인**
4. **미방문 이웃 → 큐에 삽입 & 방문 처리**
5. 큐가 빌 때까지 반복

---

## 4️⃣ BFS 코드 핵심 이해 (Linked Queue 버전)

```c
// 1) 시작 정점 방문, 큐에 enqueue
visited[v] = 1;
enqueue(&q, v);

// 2) 큐가 빌 때까지 반복
while(!is_empty(&q)) {

    // 3) 가장 오래 기다린 정점 꺼내서
    v = dequeue(&q);

    // 4) 그 정점의 모든 이웃 탐색
    for (w = g->adj_list[v]; w != NULL; w = w->link) {

        // 5) 처음 발견한 이웃이면
        if (!visited[w->vertex]) {
            visited[w->vertex] = 1;

            // 6) 큐에 넣고 방문 출력
            enqueue(&q, w->vertex);
        }
    }
}
```



---

## 5️⃣ 출력 결과 예시

```
===== bfs queue 버전 =====  
vertex 0 -> vertex 1 -> vertex 2 -> vertex 3 -> vertex 4 -> vertex 5 -> vertex 6 ->  
```

### 해석

* 0과 가까운 것부터 방문한 순서
* 즉 **“거리(깊이)”가 같은 노드끼리 묶어서 탐색**

### 📌 주의할 점
BFS는 큐(FIFO)를 이용해 “가까운 정점부터” 탐색하지만,  
실제 출력 방문 순서는 "인접 리스트에 저장된 순서"에 따라 달라질 수 있다.  
즉, BFS 알고리즘 자체의 원리가 변하는 것이 아니라  
그래프의 저장 방식과 연결 순서가 결과에 영향을 줄 수 있다.

---

## 6️⃣ DFS vs BFS 비교 표

| 기준     | DFS         | BFS           |
| ------ | ----------- | ------------- |
| 탐색 흐름  | **깊게** 들어감  | **넓게(레벨)** 탐색 |
| 자료구조   | 스택(Stack)   | 큐(Queue)      |
| 방문 순서  | 깊은 경로 우선    | 가까운 정점부터      |
| 장점     | 경로 탐색, 백트래킹 | 최단 거리 탐색 가능   |
| 공간 효율  | 재귀 → 스택 부담  | 큐 크기가 커질 수 있음 |
| 구현 난이도 | 쉬움(재귀)      | 중간 (큐 직접 구현)  |

---

## 7️⃣ 특히 중요한 차이점 (정리력 UP!)

### DFS는 “트리의 형태”로 퍼진 구조

* 마치 **길 찾기를 하다가 끝까지 가보고 막히면 뒤로 돌아오는 느낌**

### BFS는 “동심원 형태”로 확장

* 시작점에서 **1칸 거리 → 2칸 거리 → 3칸 거리 순으로** 탐색

> 그래서 **“최단 거리 탐색”** 문제에는 BFS가 사용된다.

---

## 🎯 최종 정리

| 핵심 내용                                       |
| ------------------------------------------- |
| BFS는 큐(FIFO)를 이용해 **가까운 정점부터 너비 우선 탐색**     |
| DFS는 스택(LIFO)을 이용해 **깊이 우선 탐색**             |
| BFS는 **레벨 기반**, DFS는 **경로 기반**              |
| BFS는 **최단 경로 탐색**, DFS는 **경로 존재 여부 확인에 적합** |

---

## 💬 오늘의 소감

오늘은 DFS에 이어 **BFS를 큐 기반으로 구현**하며
그래프 탐색 방식의 완전한 이해가 가능해졌다.

특히 DFS와 BFS의 가장 큰 차이가
“스택 기반 vs 큐 기반”이 아니라
**“깊게 vs 넓게”** 라는 개념적 차이라는 것을 몸소 느꼈다.
