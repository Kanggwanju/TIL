### 2025년 5월 12일 TIL

Git `Merge`는 여러 브랜치에 분산된 코드 변경 사항을 한 브랜치로 합치는 과정

Fast-Forward Merge란? (FF Merge)
빨리 감기 병합
v3가 메인이고, v5가 마음에 들 때 가지가 하나인 경우 v3->v5로 변경, 앞으로 두칸 가면 된다.
헤드가 최신 커밋에서 병합하려는 브랜치의 최신 커밋으로 빠르게 이동한다는 개념
조건: 메인에서 가지가 두종류로 분화해서는 안된다.
병합이 끝나면 v3(main)과 v5가 동기화되었다고 하며, v5는 삭제해야함.
즉, 별도의 병합 커밋 없이 커밋 포인터만 이동

깔끔하게 한 줄로 된 커밋 히스토리를 유지할 수 있지만, 병합되는 모든 커밋이 동일한 라인에 있으므로, 어떤 작업이 어떤 브랜치에서 이루어졌는지에 대한 정보를 알 수 없게 된다.
따라서 정보를 보전하려면 --no-ff옵션을 사용해서 FF 머지를 방지하고, 3-Way Merge를 강제할 수 있음.

3-Way Merge
일반적으로 git에서 merge라고 하는 것
메인도 가만히 있지 않고 다른 커밋과 병합, 새로운 브랜치 + 메인을 합치려고 할 때 새로운 커밋을 먼저 생성하고 메인을 병합시켜야함.

동일한 파일의 동일한 부분이 두 브랜치에서 다르게 변경되지 않았다면, Git은 자동으로 병합
동일한 파일의 동일한 부분이 두 브랜치에서 다르게 변경되었다면, Git은 충돌을 발생시키고 사용자에게 해결을 요청
이 과정에서 생성되는 새 커밋은 두 부모 커밋을 가지며, 이를 병합 커밋이라고 함

병합이 끝난 브랜치는 삭제해서 정리
`git branch -d branch_name`


Git `Conflict`는 두 개 이상의 변경 사항이 Git 병합 과정에서 서로 충돌할 때 발생하는 문제
예시: Alice의 브랜치 파일에선 brown, Bob의 브랜치 파일에선 blue라고 보이면 Git은 어느 변경사항을
우선시해야 할지 결정할 수 없음. 그러므로 사용자가 직접 해결해야함. Git은 이를 유도한다.

Git에서 충돌이 발생하면, Git은 conflict marker를 사용하여 사용자에게 어디에서 문제가 발생했는지 알려줍니다.
충돌 마커는 보통 다음과 같은 형태를 가집니다:
<<<<<<< HEAD
The quick brown fox...
=======
The quick blue fox...
>>>>>>> new_branch

Conflict 해결 방법
1. git status를 실행하여 충돌이 발생한 파일 확인
2. 파일을 열고 충돌 마커를 찾음
3. 어떤 변경 사항을 유지할지 결정.
4. 충돌이 해결되면, 충돌 마커를 모두 제거
5. 파일을 저장하고 닫음
6. git add를 사용하여 충돌이 해결된 파일을 스테이징
7. git commit를 실행하여 충돌이 해결된 상태를 커밋



Git Diff(보통은 툴로 사용함, 알고만 넘어가)
소스코드 또는 파일에서 변경된 부분을 비교하고 이를 시각적으로 표시해주는 역할
아직 staging 하지 않은(= add 하기 전) 내용의 변경사항을 추적

git diff HEAD : 현재 작업 디렉토리와 가장 최근 커밋(HEAD) 사이의 차이점을 보여줌
스테이징된 변경 사항과 스테이징되지 않은 변경 사항을 모두 보여줍니다.
결국 git diff HEAD를 대부분 많이 사용함!


git diff [--staged | --cached ] <- (중요도 낮음)
어떤 변경사항이 스테이징 되었는지, 즉 다음 커밋에 어떤 변경사항이 포함될 것인지를 확인하는 데 사용

git diff [--staged | HEAD] <file-name>...
특정 파일에 대한 변경사항을 확인하는 데 사용

git diff branch1..branch2
두 개의 브랜치 간에 발생한 변경사항을 확인하는 데 사용
예) git diff master..feature 명령을 실행하면 master 브랜치와 feature 브랜치에서 발생한 변경사항을 확인할 수 있다.

git diff commit1..commit2
두 개의 커밋 간에 발생한 변경사항을 확인하는 데 사용
각 커밋은 고유한 커밋 해시를 가지며, 이를 사용하여 특정 커밋을 참조할 수 있음
예) git diff 1b6d... a47c3...



Git Stash(활용하면 아주 유용함, 강력한 기능, 임시보관장소)
git stash는 Git에서 제공하는 일시적인 작업 저장소이며, 완료되지 않은 변경사항을 일시적으로 저장할 수 있다.
1. 작업 중인 브랜치 전환: 현재 브랜치에서 작업하던 중이지만, 다른 브랜치로 전환해야 할 때 사용
2. 테스트와 디버깅: 코드 변경사항이 문제인지 확인하기 위해 변경사항을 일시적으로 제거, 코드의 이전 상태를 테스트 가능
3. 중요하지 않은 변경사항 보관: get stash를 사용하면 중요하지 않거나, 아직 커밋하고 싶지 않은 변경사항을 일시적으로 보관, 필요할 때 다시 로드할 수 있음.


Commit하지 않고 브랜치를 이동했을 때 발생하는 2가지 시나리오
1. 첫번째 시나리오는 변경사항이 이동한 브랜치에 따라온다는 점입니다.
2. 두번째 시나리오는 잠재적 Conflict를 예상하여 switching을 거부하는 것(커밋이나 스태쉬를 하고 브랜치를 옮겨야함)



git stash [save], save는 생략가능
변경사항을 새로운 stash로 저장하고, 워킹 디렉토리를 이전 커밋 상태로 되돌림
예: git stash save "half-done feature"

git stash pop은 꺼내고 지움
git stash apply는 꺼내고 안지움, 리스트에 남아있음

여러 개의 스태시중에 원하는 것을 불러서 적용하는법
git stash list를 했을 때 왼쪽에 보이는 stash id를 이용
ex) git stash apply stash@{2}


git stash drop <stash-id>는 특정 스태시를 제거함
git stash clear는 stash 스택에 있는 모든 stash를 제거



Detached HEAD 상태란, 특정 브랜치가 아닌 커밋에 직접 체크아웃한 상태
ex) git checkout <commit-hash>와 같은 명령을 실행하면 git은 해당 커밋으로 체크아웃하고, Detached HEAD 상태가 된다.
Detached HEAD 상태에서는 다음과 같은 작업을 고려할 수 있습니다:
- **단순히 이전 커밋 내역 둘러보기**: 그냥 헤드를 분리시킨 상태로 이전 커밋의 파일들을 둘러볼 수 있음
- **새 브랜치 생성**: git switch -c <new-branch> 명령을 사용하여 현재 커밋을 기반으로 새 브랜치를 생성
- **작업 내역 저장 후 체크아웃**: git stash를 사용하여 변경사항을 저장한 다음, 원하는 브랜치로 체크아웃할 수 있음.

- 단순히 둘러보기만 하고 원래 브랜치로 되돌아가기: `git switch <branch-name>`, `git switch -`
- git checkout HEAD~1 명령어를 실행하면, 현재 HEAD 커밋의 직전 커밋으로 이동하게 됨.
- git switch -c <new_branch> HEAD~1 명령은 현재 HEAD의 한 단계 이전 커밋으로 새 브랜치 new_branch를 생성하고 체크아웃


`git restore`
1. 작업 디렉토리의 파일을 복원: `git restore <file>`를 실행하면, 지정된 파일의 변경사항을 HEAD의 상태로 되돌림. 즉, 최근 커밋 상태로 해당 파일을 복원함.
2. 스테이징한 파일 언스테이징하기: git restore --staged <file>을 실행하면, 지정된 파일의 인덱스(즉, 스테이징 영역) 상태를 HEAD의 상태로 되돌림.
* `git restore`는 되돌릴 수 없는 명령어이며, 사용하여 파일을 복원하면 그 이전의 변경사항은 복구할 수 없다. 따라서 신중하게 사용하여야 한다.

git restore --source 옵션은 설명만.










