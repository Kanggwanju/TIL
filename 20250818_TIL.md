# 🗓️ 2025년 8월 18일 TIL




Service에서 JPA를 사용할 경우 @Transactional 어노테이션을 붙여줘야함.
하지만 GET 요청만 보내는 경우에는 rollback을 염려해야 할 필요가 없다.
따라서 GET 요청만 실행하는 메서드는 @Transactional(readOnly = true)를
붙여주어 성능 UP


해시태그 생성 처리(travel-log-form.js)


     TravelLogTags
TravelLog        Tag
    M       :     N

1. 첨부된 사진을 Photo Table에 insert

2. 사용자가 입력한 해시태그를 Tag에 insert
DB에 이미 있는 해시태그는 insert 하지 않음

3. 전체 작성 내용을 TravelLog에 insert

4. 생성된 TravelLog의 id, Tag의 id를 기준으로
   TravelLogTags에 insert


멱등 처리 (race condition 처리)
혹시나 프론트에서 당연히 한번 중복을 검증하지만 서버에서 한번 더 검증
```java
if (tagRepository.existsByName(requestDto.getName())) {
    throw new BusinessException(ErrorCode.HASHTAG_EXISTS);
}
```



    1. 해시태그를 데이터베이스 서버에 저장
      ex)  3개의 해시태그가 저장되었다. 그 중에 2개는 이미 있는 거였고 1개가 신규 해시태그였다.
             기존의 2개는 이미 ID(PK)가 부여된상태 새로운 1개는 INSERT이후에 PK가 생성됨.

              기존 2개의 ID가 (3, 7) ,  새로운 1개가 (11번으로 생성)

    2. 해시태그 저장 이후에 클라이언트에게 지금 등록된 해시태그 포함 ID를 알려줘야 함.

    3. 여행 일지 등록시 여행일지의 ID가 생성됨 (17번)

    4. 여행일지와 해시태그를 중간에서 처리하는 테이블에

  travel_log_id    tag_id
===============================
        17            3
        17            7
        17            11


해시태그에 있는 # 을 제거하는 코드
#은 0번, 해시태그 내용은 1번부터.
const keyword = value.slice(1);


프론트에서 #백숙 엔터를 쳤을 때는 직접 해시태그 생성 API 요청을 보낸
것은 아직 아니다. 

태그가 있다면 
```java
// 기존 태그 검색 후 있으면 해당 태그로, 없으면 로컬(신규 예정)로 칩만 추가
const suggestions = await searchTags(name);
const existing = suggestions.find(
    (t) => t.name.toLowerCase() === name.toLowerCase()
);

if (existing) {
    addTagChip(existing);
} else { // 검색결과가 없으면 id 를 null로 해서 자바스크립트 배열에 추가
    addTagChip({ id: null, name, category, color: '#6c757d' });
}
```

id가 null 이면 추후에 신규 해시태그라는 증거가 된다.


---

양방향 매핑에서 TravelLog는 중간 테이블의 정보를 가지고 있음(travelLogTags)
travelLogTags에 add를 하면 cascade = CascadeType.ALL에 의해
중간 테이블에 insert가 실행된다.

- 중간 엔티티를 추가하면, JPA가 중간 테이블 insert SQL 을 자동으로 실행

```java
// 여행 일지 저장 -> 여행 일지의 ID가 생성됨
TravelLog savedTravelLog = travelLogRepository.save(travelLog);

// 해시태그가 있다면 해시태그도 중간테이블에 연계저장
List<Long> tagIds = request.getTagIds();
if (tagIds != null && !tagIds.isEmpty()) {
    tagIds.forEach(tagId -> {
        savedTravelLog.addTag(tagRepository.findById(tagId).orElseThrow());
    });
}
```