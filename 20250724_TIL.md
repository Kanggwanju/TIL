# 🗓️ 2025년 7월 24일 TIL

JdbcTemplate
- JDBC를 직접 사용하면서 많은 반복적인 코드를 작성

해결해주는 것들
1. 리소스 관리 자동화

2. 예외 처리 단순화
- SQL 관련 모든 예외를 스프링의 DataAccessException으로 변환해줌
- checked 예외를 unchecked 예외로 변환하여 코드를 더 깔끔하게 만들어줌

3. 반복 작업 제거
- 데이터베이스 연결 얻기
- PreparedStatement 생성
- 결과 처리
- 리소스 정리

JdbcTemplate의 주요 메서드
1. 조회 관련
```java
// 단일 행 조회
jdbcTemplate.queryForObject(sql, rowMapper, params);

// 여러 행 조회
jdbcTemplate.query(sql, rowMapper, params);

// 단일 값 조회
jdbcTemplate.queryForObject(sql, Integer.class, params);

```

2. 수정 관련

```java
// INSERT, UPDATE, DELETE
jdbcTemplate.update(sql, params);

```

---

JdbcTemplate 설정
build.gradle 파일에 의존성 추가
```groovy
dependencies {
    // 스프링 JDBC 의존성
    implementation 'org.springframework.boot:spring-boot-starter-jdbc'

    // MariaDB 드라이버 의존성
    implementation 'org.mariadb.jdbc:mariadb-java-client:3.1.4'
}
```
나는 Spring Boot에서 `Spring Data JPA`, `MariaDB Driver` 의존성을 추가했기 때문에 따로 의존성을 추가하지 않았음.
Spring Data JPA 의존성만 추가해도 JdbcTemplate은 사용할 수 있음
이유는 Spring Boot가 내부적으로 **spring-boot-starter-data-jpa → spring-boot-starter-jdbc**를 함께 포함하고 있기 때문

---


JdbcTemplate 기본 사용법
```java
@Repository
public class ProductRepository {
    private final JdbcTemplate template;

    public ProductRepository(JdbcTemplate jdbcTemplate) {
        this.template = jdbcTemplate;
    }
}
```

데이터 변경하기 (INSERT, UPDATE, DELETE)
- update() 메서드를 사용

1. 데이터 추가 (INSERT)
```java
public boolean save(Product product) {
        String sql = """
                    INSERT INTO PRODUCTS
                        (name, price, stock_quantity, status)
                    VALUES
                        (?, ?, ?, ?)
                """;

        return template.update(
                sql,
                product.getName(),
                product.getPrice(),
                product.getStockQuantity(),
                product.getStatus(),
        ) == 1;
    }
```
2. 데이터 수정 (UPDATE)
```java
public boolean update(Product product) {
        String sql = """
                    UPDATE PRODUCTS
                    SET
                        name = ?,
                        price = ?,
                        stock_quantity = ?,
                    WHERE id = ?
                """;

        return template.update(
                sql,
                product.getName(),
                product.getPrice(),
                product.getStockQuantity(),
                product.getId()
        ) == 1;
```

3. 데이터 삭제 (DELETE)
- 보통 DB에서 진짜 삭제하지 않고, status 값을 통해 논리적 삭제를 한다.
- status가 DELETED가 됐다는 건 논리적으로 삭제되어, 목록 조회에서 안 보이게 해야함.
```java
public boolean deleteById(Long id) {
    String sql = """
                UPDATE PRODUCTS
                SET status = ?
                WHERE id = ?
            """;

    return template.update(
            sql,
            "DELETED",
            id
    ) == 1;
}
```


RowMapper 활용
- JdbcTemplate의 가장 중요한 도구 중 하나
- 데이터베이스의 결과를 자바 객체로 변환해주는 변환기와 같은 역할

RowMapper가 필요한 이유
- 데이터베이스는 표(테이블) 형태로 데이터를 저장
- 자바에서는 객체 형태로 데이터를 다룸
- 기존에는 전체 데이터 조회 쿼리를 통해 ResultSet을 얻어서 
- ResultSet의 정보를 토대로 객체를 만들고, 객체 리스트에 넣어서 return 해줬음.
- 이 귀찮은 작업을 대신 해준다.

데이터 조회하기 (SELECT)
1. 단일 상품 조회
```java
public Book findById(Long id) {
    String sql = """
                    SELECT * FROM BOOKS
                    WHERE id = ?
                """;
    return template.queryForObject(
            sql,
            new RowMapper<Book>() {
                @Override
                public Book mapRow(ResultSet rs, int n) throws SQLException {
                    return new Book(rs);
                }
            },
            // (rs, n) -> new Book(rs),
            id
    );
}
```
- RowMapper은 인터페이스임. 람다로 바꾸면 `(rs, n) -> new Book(rs)`

2. 상품 목록 조회
```java
public List<Product> findAll() {
    String sql = """
                SELECT * FROM PRODUCTS
                WHERE status <> 'DELETED'
            """;
    return template.query(
            sql,
            new BeanPropertyRowMapper<>(Product.class)
    );
}
```
- BeanPropertyRowMapper: 테이블의 컬럼명과 엔터티클래스의 필드명이
- 똑같을 경우 (camel, snake 차이만 빼고) 자동 매핑해줌
- 사용하려면 Product 클래스에 기본 생성자 + setter 메서드가 있어야 함.

3. SQL의 집계 함수를 이용한 전체 상품의 총액과 평균 조회
3-1. Map 형태로 return
```java
public Map<String, Number> getPriceInfo() {
    String sql = """
            SELECT 
                SUM(price * stock_quantity) AS "total_price"
                , AVG(price * stock_quantity) AS "average_price"
            FROM PRODUCTS
            WHERE status = 'ACTIVE'
            """;

    return template.queryForObject(sql, (rs, rowNum) -> {
        int totalPrice = rs.getInt("total_price");
        double averagePrice = rs.getDouble("average_price");
        // Map으로 리턴하기
        return Map.of(
                "total", totalPrice,
                "average", averagePrice
        );
    });
}
```
3-2. PriceInfo 클래스, dto로 리턴
- PriceInfo dto 클래스
```java
@Getter
@Setter
@ToString
@EqualsAndHashCode
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PriceInfo {
    private int totalPrice;
    private double averagePrice;
}
```

- return문
```java
return template.queryForObject(sql, (rs, rowNum) -> {
    int totalPrice = rs.getInt("total_price");
    double averagePrice = rs.getDouble("average_price");
    // dto로 리턴
    return new PriceInfo(totalPrice, averagePrice);
});
```

3-3. BeanPropertyRowMapper, dto 사용 return
```java
return template.queryForObject(sql, new BeanPropertyRowMapper<>(PriceInfo.class));
```

파라미터 처리 방법
JdbcTemplate은 SQL 파라미터를 처리하는 여러 방법을 제공함
1. 순서 기반 파라미터
가장 기본적인 방법:
```java
jdbcTemplate.update(
    "INSERT INTO products (name, price) VALUES (?, ?)",
    "새우깡",  // 첫 번째 ?
    1500      // 두 번째 ?
);
```

2. 이름 기반 파라미터
더 읽기 쉽고 실수할 가능성이 적음:
```java
MapSqlParameterSource params = new MapSqlParameterSource()
   .addValue("name", "새우깡")
   .addValue("price", 1500);

namedParameterJdbcTemplate.update(
    "INSERT INTO products (name, price) VALUES (:name, :price)",
    params
);
```







