# 🗓️ 2025년 10월 28일 TIL - 메인 페이지 사용자 랭킹 시스템 구현

## 📌 오늘의 키워드
`RESTful API` `3-tier 아키텍처` `Spring Data JPA` `쿼리 메서드` `DTO 패턴` `정적 팩토리 메서드` `ApiResponse` `공통 응답 래퍼` `React 상태 관리` `useEffect` `조건부 렌더링`

---

## 문제 상황

사용자들이 게임을 통해 점수를 획득하고 있지만, 이를 시각적으로 비교할 수 있는 랭킹 시스템이 없었다. DB에는 `totalScore`가 저장되고 있었으나 이를 활용한 랭킹 표시 기능이 필요했다.

---

## RESTful API

### 핵심 원칙

**1. 자원(Resource) 중심**
- URI는 자원을 표현: `/api/users/rank` (동사가 아닌 명사 사용)
- 자원의 행위는 HTTP 메서드로 표현

**2. HTTP 메서드의 의미**
```
GET    - 조회 (읽기)
POST   - 생성
PUT    - 전체 수정
PATCH  - 부분 수정
DELETE - 삭제
```

**3. 무상태성(Stateless)**
- 서버는 클라이언트 상태를 저장하지 않음
- 매 요청마다 필요한 정보(인증 토큰 등)를 포함

**4. 일관된 응답 형식**
- 성공/실패를 명확히 구분
- 표준 HTTP 상태 코드 사용 (200, 404, 500 등)

---

## Spring Data JPA 쿼리 메서드

### 메서드 이름으로 쿼리 생성

Spring Data JPA는 메서드 이름만으로 쿼리를 자동 생성한다.

```java
// 메서드 이름
findTop8ByOrderByTotalScoreDesc()

// 자동 생성되는 SQL
SELECT * FROM user 
ORDER BY total_score DESC 
LIMIT 8
```

### 네이밍 규칙

```
find + (조건) + By + (필드명) + (정렬) + (개수 제한)
```

**주요 패턴**:
- `findByNickname(String nickname)` → WHERE nickname = ?
- `findByTotalScoreGreaterThan(Long score)` → WHERE total_score > ?
- `findByOrderByTotalScoreDesc()` → ORDER BY total_score DESC
- `findTop10By...()` → LIMIT 10
- `findByNicknameContaining(String keyword)` → WHERE nickname LIKE %?%

**장점**:
- SQL을 직접 작성할 필요 없음
- 컴파일 시점에 메서드 시그니처 검증
- 메서드 이름만으로 의미 파악 가능

---

## 3-Tier 아키텍처

### 계층 분리

```
Controller (Presentation)     → HTTP 요청/응답 처리
    ↓
Service (Business)            → 비즈니스 로직
    ↓
Repository (Data Access)      → 데이터베이스 접근
    ↓
Database
```

### 각 계층의 책임

**Controller**:
- HTTP 요청 파싱 및 검증
- 서비스 계층 호출
- 응답 데이터 직렬화 (JSON)

**Service**:
- 비즈니스 로직 처리 (순위 계산 등)
- 트랜잭션 관리
- Entity ↔ DTO 변환

**Repository**:
- 데이터베이스 CRUD 작업
- 쿼리 실행

### 계층 분리의 장점

- **관심사 분리**: 각 계층이 자신의 역할만 집중
- **테스트 용이**: 각 계층을 독립적으로 테스트 가능
- **재사용성**: 같은 Service를 여러 Controller에서 사용
- **유지보수성**: 한 계층의 변경이 다른 계층에 영향 최소화

---

## DTO 패턴

### Entity vs DTO

**Entity**: DB 테이블과 1:1 매핑
- 모든 필드 포함 (30개 이상)
- 민감한 정보 포함 (password, email 등)

**DTO**: API 응답용 데이터 전송 객체
- 필요한 필드만 선택
- 민감한 정보 제외
- 프론트엔드 요구사항에 맞게 커스터마이징

### 정적 팩토리 메서드

Entity를 DTO로 변환하는 로직을 캡슐화한다.

```java
public static UserRankResponse from(User user, int rank) {
    return UserRankResponse.builder()
            .rank(rank)
            .nickname(user.getNickname())
            .score(user.getTotalScore())
            .profileImage(user.getProfileImageUrl())
            .build();
}
```

**장점**:
- 변환 로직을 DTO 내부에 캡슐화
- 생성자보다 명확한 의미 전달
- 메서드 체이닝으로 가독성 향상

---

## 공통 응답 래퍼 (ApiResponse)

### 일관된 응답 구조

모든 API 응답을 동일한 형식으로 래핑한다.

```java
@Getter
@Builder
public class ApiResponse<T> {
    private Boolean success;
    private String message;
    private LocalDateTime timestamp;
    private T data;  // 제네릭
}
```

**응답 예시**:
```json
{
  "success": true,
  "message": "랭킹 조회에 성공했습니다.",
  "timestamp": "2025-10-28T15:26:24",
  "data": [...]
}
```

**장점**:
- 프론트엔드가 항상 동일한 구조로 응답 처리
- success 필드로 성공/실패 명확히 구분
- 타임스탬프로 응답 시점 추적 가능

---

## 에러 처리

### GlobalExceptionHandler

모든 에러를 한 곳에서 처리하는 AOP 패턴이다.

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(...) {
        // 에러 응답 생성 및 반환
    }
}
```

**에러 응답 형식**:
```json
{
  "timestamp": "2025-10-28T15:30:00",
  "status": 500,
  "error": "DATABASE_ERROR",
  "detail": "데이터베이스 오류가 발생했습니다.",
  "path": "/api/users/rank"
}
```

**장점**:
- 모든 에러가 일관된 형식으로 반환
- 컨트롤러마다 중복된 에러 처리 코드 제거
- 프론트엔드의 에러 처리 로직 단순화

---

## React 상태 관리

### 세 가지 상태

랭킹 조회 기능에는 세 가지 상태가 필요하다.

```javascript
const [rankings, setRankings] = useState([]);      // 데이터
const [isLoading, setIsLoading] = useState(true);  // 로딩
const [error, setError] = useState(null);          // 에러
```

### useEffect로 자동 로드

컴포넌트가 마운트될 때 자동으로 데이터를 로드한다.

```javascript
useEffect(() => {
  fetchRankings();
}, []); // 빈 배열: 마운트 시 한 번만 실행
```

**의존성 배열의 의미**:
- `[]`: 마운트 시 한 번만 실행
- `[userId]`: userId 변경 시마다 실행
- 생략: 매 렌더링마다 실행

### 조건부 렌더링

세 가지 상태에 따라 다른 UI를 표시한다.

```javascript
if (isLoading) return <LoadingSpinner />;
if (error) return <ErrorMessage />;
return <RankingList />;
```

**패턴 선택**:
- Early Return: 가장 명확하고 가독성 좋음 (우리가 선택)
- 삼항 연산자: 짧은 조건일 때 유용
- 논리 연산자: 여러 조건을 동시에 표시할 때

---

## 구현 흐름

### 백엔드

1. **Repository**: 쿼리 메서드 `findTop8ByOrderByTotalScoreDesc()`로 상위 8명 조회
2. **Service**: Entity → DTO 변환, 순위 번호 추가 (1~8)
3. **Controller**: ApiResponse로 래핑하여 JSON 응답

### 프론트엔드

1. **API Service**: axios로 `/users/rank` 호출, `response.data.data` 추출
2. **Component**: useEffect로 마운트 시 자동 데이터 로드
3. **UI**: 조건부 렌더링으로 로딩/에러/데이터 상태별 UI 표시

---

## 학습 포인트

### 1. RESTful API 설계

좋은 API는 자원 중심이고, HTTP 메서드를 의미있게 사용하며, 일관된 응답 구조를 가진다.

### 2. 계층 분리의 가치

각 계층이 자신의 책임만 집중하면 테스트와 유지보수가 쉬워진다.

### 3. DTO의 필수성

Entity를 직접 노출하지 않고 DTO로 변환하여 보안과 효율성을 확보한다.

### 4. Spring Data JPA의 편리함

메서드 이름만으로 쿼리를 생성할 수 있어 생산성이 높다.

### 5. 공통 응답 형식의 중요성

ApiResponse와 ErrorResponse로 일관된 응답 구조를 유지하면 프론트엔드 개발이 수월해진다.

### 6. React 상태 관리 패턴

데이터, 로딩, 에러 세 가지 상태를 명확히 분리하여 관리하면 사용자 경험이 향상된다.

---

## ✅ 최종 정리

* **RESTful API 설계**: 자원 중심의 URI (`/api/users/rank`) + HTTP 메서드 활용 → 일관된 응답 구조 (ApiResponse, ErrorResponse)
* **3-tier 아키텍처**: Controller (HTTP) → Service (비즈니스 로직) → Repository (데이터 접근) → 각 계층의 책임 명확히 분리
* **Spring Data JPA 쿼리 메서드**: `findTop8ByOrderByTotalScoreDesc()` → SQL 작성 없이 메서드 이름만으로 쿼리 자동 생성
* **DTO 패턴**: Entity 직접 노출 X → 필요한 필드만 담은 DTO 변환 → 보안 + 효율성 + 유연성 확보
* **정적 팩토리 메서드**: `UserRankResponse.from(user, rank)` → Entity → DTO 변환 로직 캡슐화
* **일관된 에러 처리**: GlobalExceptionHandler → 모든 에러를 한 곳에서 처리 → ErrorResponse 형식 통일
* **React 상태 관리**: useState (데이터/로딩/에러) + useEffect (마운트 시 자동 로드) + 조건부 렌더링 (Early Return 패턴)
* **계층 분리의 가치**: Controller 수정 → Service 영향 없음 / Repository 변경 → Controller 영향 없음 → 테스트와 유지보수 용이

**"좋은 아키텍처는 변경을 쉽게 만든다. 그리고 변경을 쉽게 만드는 방법은 책임을 명확히 분리하는 것이다."**

