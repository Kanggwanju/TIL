# 🗓️ 2025년 10월 14일 TIL


## 도커허브(Docker Hub) 활용
- 도커 이미지를 저장하고 공유할 수 있는 클라우드 기반의 서비스

### 1. 도커 로그인
- 로컬 도커 클라이언트를 도커허브 계정에 로그인

```shell
docker login
```

### 2. 도커 이미지 태그 지정
- 도커 허브에서 저장소 생성(hub-test-image)
```
docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]

# 예시
docker tag hub-test-image kgj0318/hub-test-image
```
- SOURCE_IMAGE: 태그를 추가할 기존의 로컬의 도커 이미지 이름입니다.
- SOURCE_TAG: 선택적으로, 이미지의 특정 태그를 지정할 수 있습니다. 지정하지 않으면 기본적으로 latest 태그가 사용됩니다.
- TARGET_IMAGE: 도커 허브와 같은 원격저장소에 저장할 이미지 이름
- TARGET_TAG: 새 이미지의 태그를 지정합니다. 이 부분도 선택적으로, 지정하지 않을 경우 latest가 기본값으로 사용됩니다.

### 3. 이미지 푸시
- 태그가 지정된 이미지를 도커허브에 푸시

```shell
docker push myusername/myapp-image:latest

# 예시
docker push kgj0318/hub-test-image
```

### 4. 이미지 가져오기
- 도커허브에서 해당 이미지를 로컬 도커 환경으로 다운로드
```shell
docker pull myusername/myapp-image:latest
```

### pull받을 때 Already Exist 이슈
- 도커는 이미지 레이어를 효율적으로 관리하기 위해 내부 캐시 시스템을 사용
- 이미 다운로드한 레이어는 다시 다운로드하지 않고, Already exists 메시지와 함께 즉시 사용 가능 상태로 표시
- 해결방법:
  - 도커 시스템 정리: 도커의 시스템 정리 기능을 사용하여 사용하지 않는 이미지 레이어를 정리
  - `docker system prune`

---

## AWS EC2에 Docker환경 구축

### ec2 리눅스에 도커 설치
```shell
$ sudo su                              -- 관리자 전환
$ yum install docker -y                -- docker 설치
$ systemctl start docker               -- docker 실행
$ systemctl enable docker              -- docker 자동실행 설정
$ sudo usermod -aG docker ec2-user     -- docker 유저권한 부여
$ docker --version                      -- docker 버전 확인
```

### ec2 리눅스에 docker-compose 설치

- docker compose 실행파일 다운로드
```shell
sudo curl -L "https://github.com/docker/compose/releases/download/v2.11.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
```

- 실행 권한 부여
```shell
sudo chmod +x /usr/local/bin/docker-compose
```

- 버전 확인
```shell
docker-compose --version
```

### docker hub 로그인
```shell
docker login
```
- 이후 도커 계정명, 패스워드 입력

### git 설치, 프로젝트 클론
```shell
yum install git -y

git clone https://github.com/soongu/memo-api.git
```

### 도커 파일 생성, 이미지 빌드
```shell
vi Dockerfile

docker build -t memo-api-image .
```
- Dockerfile
```text
# 1. 단일 스테이지 빌드: Amazon Corretto JDK 이미지 하나로 빌드와 실행을 모두 처리합니다.
FROM amazoncorretto:17-al2-jdk

# 작업 디렉토리를 설정합니다.
WORKDIR /app

# 현재 디렉토리의 모든 파일을 컨테이너의 /app 디렉토리로 복사합니다.
COPY . .

# Gradle을 사용하여 프로젝트를 빌드합니다.
RUN ./gradlew clean build

# 빌드된 jar 파일의 이름을 app.jar로 변경하고 /app 디렉토리로 이동시킵니다.
RUN mv /app/build/libs/*.jar /app/app.jar

# 컨테이너 실행 시 Spring Boot의 'prod' 프로필을 활성화하고,
# 빌드된 JAR 파일을 직접 실행합니다.
ENTRYPOINT ["java", "-jar", "-Dspring.profiles.active=dev", "app.jar"]
```

- 도커 컨테이너 실행
```shell
$ docker run -d -p 80:8080 --name memo-api-container memo-api-image  -- 컨테이너 실행
$ docker ps                                                       -- 실행 확인
$ docker logs memo-api-container                                 -- 실행 로그 확인
$ docker stop <컨테이너 ID>                                       -- 컨테이너 중지
```

### 도커 이미지 태그 지정, 허브 푸시
```shell
$ docker tag memo-api-image kgj0318/memo-api-image    — docker tag 생성
$ docker push kgj0318/memo-api-image:latest         — 푸시하기
$ docker pull kgj0318/memo-api-image:latest         — 내려받기 
```

### 도커 컴포즈
- 설정 파일 생성
```shell
vi docker-compose.yml
```

```yaml
services:
  app:
    image: soongu/memo-api-image
    ports:
      - "80:8080"
```

- 백그라운드 실행
```shell
docker-compose up -d       # 백그라운드 실행
docker-compose down        # 서비스 중지 및 리소스 제거
```

---

## CI/CD 파이프라인 구축

## Jenkins와 Github Action

### Jenkins
- 오픈 소스 자동화 서버로, 플러그인을 통해 CI/CD 파이프라인을 구축 가능
- 매우 유연하며 거의 모든 종류의 프로젝트에 맞게 구성 가능
- Jenkins를 사용하면 서버에 직접 설치해야 하며, 유지 관리가 필요, 설정과 관리에 시간과 노력이 소요됨

### GitHub Actions
- GitHub 저장소 내에서 직접 CI/CD 작업을 자동화할 수 있게 해 주는 도구
- 추가적인 서버 설치가 필요 없으며, GitHub 인프라 내에서 실행
- GitHub을 이미 사용 중인 프로젝트에 쉽게 통합 가능
- 설정이 간단하며, 소규모에서 중규모 프로젝트에 적합

---

## Github Actions로 AWS S3에 리액트 앱 CI/CD 파이프라인 구축

### 1. AWS CLI 사용자 설정 

1-1. AWS 콘솔 로그인

1-2. IAM - 사용자 - 사용자 생성

1-3. 사용자 이름 설정, 직접 정책연결, 권한 정책 체크 (AmazonS3FullAccess)

1-4. 액세스 키 ID와 비밀 액세스 키 백업


### 2. 로컬 PC 사용자 등록

2-1. 등록 명령어
```shell
$ aws configure --profile deploy-admin
# 액세스 키, 비밀 액세스 키 입력
Default region name [None]: ap-northeast-2
Default output format [None]: json
```

### 3. AWS S3 버킷 생성

3-1. S3 - 버킷만들기 - 버킷 이름(unique) - 모든 퍼블릭 액세스 차단 체크 해제 - 하단 노란색 박스 체크 - 버킷만들기 

3-2. 버킷 속성 - 정적 웹 사이트 호스팅 활성화 - 인덱스 문서(index.html) - 오류 문서(index.html) - 변경 사항 저장

3-3. 버킷 권한 - 버킷 정책 편집 - 정책 생성기 - Type of Policy(S3 Bucket Policy) - Principal(*) - Actions(GetObject) - ARN(버킷 ARN 복사 + /*) - Add Statement - Generate Policy - 정책 복사 후 버킷 정책에 붙여넣기, 변경 사항 저장 

### 4. 리액트 프로젝트 배포 설정

4-1. package.json, deploy 추가
```json
"scripts": {
  "dev": "vite",
  "build": "vite build",
  "deploy": "aws s3 sync ./dist s3://버킷명 --profile=IAM 계정명",
  "lint": "eslint .",
  "preview": "vite preview"
},
```

4-2. .github/workflows/deploy.yml 생성
```yaml
name: Deploy React App to S3

on:
  push:
    branches:
      - main  # main 브랜치에 푸시될 때 실행

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4  # 리포지토리 코드 체크아웃

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22'  # Node.js 버전 지정

    - name: Install Dependencies
      run: npm install  # 의존성 설치

    - name: Build React App
      run: CI=false npm run build  # 프로덕션 빌드 생성

    - name: Deploy to AWS S3
      uses: jakejarvis/s3-sync-action@master
      with:
        args: --delete  #  불필요한 파일 삭제
      env:
        AWS_S3_BUCKET: ${{ secrets.S3_BUCKET }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION: ${{ secrets.AWS_REGION }}
        SOURCE_DIR: 'dist'  # 빌드된 파일이 있는 디렉토리
```

4-3. 깃허브 env 값 설정
- 프로젝트 진입 - Settings - Secrets and variables - Actions - New repository secret
- S3_BUCKET(버킷 이름), AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_REGION(ap-northeast-2)

4-4. main 브랜치에 푸시될 때 자동으로 배포


