# 🗓️ 2025년 10월 14일 TIL

## 📌 오늘의 키워드
`Docker Hub` `AWS EC2` `Docker Compose` `CI/CD` `Jenkins` `GitHub Actions` `S3 정적 호스팅` `자동 배포`

---

## 1️⃣ 도커허브(Docker Hub) 활용

도커 이미지를 저장하고 공유할 수 있는 클라우드 기반의 서비스

### 기본 워크플로우

#### 1단계: 도커 로그인
```shell
docker login
```

#### 2단계: 이미지 태그 지정
- 도커 허브에서 저장소 생성(hub-test-image)
```shell
docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]

# 예시
docker tag hub-test-image kgj0318/hub-test-image
```

**파라미터 설명**
- `SOURCE_IMAGE`: 태그를 추가할 기존 로컬 도커 이미지 이름
- `SOURCE_TAG`: 이미지의 특정 태그 (미지정 시 `latest`)
- `TARGET_IMAGE`: 원격 저장소에 저장할 이미지 이름
- `TARGET_TAG`: 새 이미지의 태그 (미지정 시 `latest`)

#### 3단계: 이미지 푸시
- 태그가 지정된 이미지를 도커허브에 푸시

```shell
docker push myusername/myapp-image:latest

# 예시
docker push kgj0318/hub-test-image
```

#### 4단계: 이미지 가져오기
- 도커허브에서 해당 이미지를 로컬 도커 환경으로 다운로드
```shell
docker pull kgj0318/hub-test-image:latest
```

### 💡 트러블슈팅: Already Exists 이슈

**원인**
- 도커는 이미지 레이어를 효율적으로 관리하기 위해 내부 캐시 시스템을 사용
- 이미 다운로드한 레이어는 다시 다운로드하지 않음

**해결방법**
```shell
docker system prune
```

---

## 2️⃣ AWS EC2에 Docker 환경 구축

### EC2 리눅스에 Docker 설치

```shell
sudo su                              # 관리자 전환
yum install docker -y                # docker 설치
systemctl start docker               # docker 실행
systemctl enable docker              # docker 자동실행 설정
sudo usermod -aG docker ec2-user     # docker 유저권한 부여
docker --version                      # docker 버전 확인
```

### EC2 리눅스에 Docker Compose 설치

```shell
# 1. 실행파일 다운로드
sudo curl -L "https://github.com/docker/compose/releases/download/v2.11.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose

# 2. 실행 권한 부여
sudo chmod +x /usr/local/bin/docker-compose

# 3. 버전 확인
docker-compose --version
```

### 프로젝트 배포 실습

#### Git 설치 및 프로젝트 클론
```shell
yum install git -y
git clone https://github.com/soongu/memo-api.git
```

#### Dockerfile 생성
```dockerfile
# 1. 단일 스테이지 빌드: Amazon Corretto JDK 이미지 하나로 빌드와 실행을 모두 처리합니다.
FROM amazoncorretto:17-al2-jdk

# 작업 디렉토리를 설정합니다.
WORKDIR /app

# 현재 디렉토리의 모든 파일을 컨테이너의 /app 디렉토리로 복사합니다.
COPY . .

# Gradle을 사용하여 프로젝트를 빌드합니다.
RUN ./gradlew clean build

# 빌드된 jar 파일의 이름을 app.jar로 변경하고 /app 디렉토리로 이동시킵니다.
RUN mv /app/build/libs/*.jar /app/app.jar

# 컨테이너 실행 시 Spring Boot의 'prod' 프로필을 활성화하고,
# 빌드된 JAR 파일을 직접 실행합니다.
ENTRYPOINT ["java", "-jar", "-Dspring.profiles.active=dev", "app.jar"]
```

#### 이미지 빌드 및 컨테이너 실행
```shell
# 이미지 빌드
docker build -t memo-api-image .

# 컨테이너 실행
docker run -d -p 80:8080 --name memo-api-container memo-api-image

# 상태 확인
docker ps
docker logs memo-api-container

# 컨테이너 중지
docker stop <컨테이너 ID>
```

#### Docker Hub에 푸시
```shell
docker login
docker tag memo-api-image kgj0318/memo-api-image
docker push kgj0318/memo-api-image:latest
docker pull kgj0318/memo-api-image:latest
```

### Docker Compose 활용

#### docker-compose.yml 생성
```yaml
services:
  app:
    image: soongu/memo-api-image
    ports:
      - "80:8080"
```

#### 실행 명령어
```shell
docker-compose up -d       # 백그라운드 실행
docker-compose down        # 서비스 중지 및 리소스 제거
```

---

## 3️⃣ CI/CD 파이프라인 구축

### Jenkins vs GitHub Actions

#### Jenkins
**장점**
- 오픈 소스 자동화 서버
- 플러그인을 통한 유연한 커스터마이징
- 거의 모든 프로젝트에 맞게 구성 가능

**단점**
- 서버에 직접 설치 필요
- 유지 관리에 시간과 노력 소요

#### GitHub Actions
**장점**
- GitHub 저장소 내에서 직접 CI/CD 자동화
- 추가 서버 설치 불필요
- GitHub 인프라에서 실행
- 설정이 간단하며 통합이 쉬움

**적합한 경우**
- 소규모~중규모 프로젝트
- GitHub을 이미 사용 중인 프로젝트

---

## 4️⃣ GitHub Actions로 AWS S3에 리액트 앱 CI/CD 파이프라인 구축

### Step 1: AWS IAM 사용자 설정

1. AWS 콘솔 로그인
2. IAM → 사용자 → 사용자 생성
3. 사용자 이름 설정, 직접 정책 연결
4. 권한 정책: `AmazonS3FullAccess` 체크
5. 액세스 키 ID와 비밀 액세스 키 백업

### Step 2: 로컬 PC 사용자 등록

```shell
aws configure --profile deploy-admin
# 액세스 키, 비밀 액세스 키 입력
# Default region name: ap-northeast-2
# Default output format: json
```

### Step 3: AWS S3 버킷 생성

1. S3 → 버킷 만들기
2. 버킷 이름 설정 (unique)
3. 모든 퍼블릭 액세스 차단 해제 → 하단 노란색 박스 체크 → 버킷만들기
4. 버킷 속성 → 정적 웹 사이트 호스팅 활성화
  - 인덱스 문서: `index.html`
  - 오류 문서: `index.html`
5. 버킷 권한 → 버킷 정책 편집 → 정책 생성기
  - Type of Policy: `S3 Bucket Policy`
  - Principal: `*`
  - Actions: `GetObject`
  - ARN: `버킷 ARN/*`

### Step 4: React 프로젝트 배포 설정

#### package.json에 deploy 스크립트 추가
```json
"scripts": {
  "dev": "vite",
  "build": "vite build",
 "deploy": "aws s3 sync ./dist s3://버킷명 --profile=IAM 계정명",
  "lint": "eslint .",
  "preview": "vite preview"
}
```

#### .github/workflows/deploy.yml 생성
```yaml
name: Deploy React App to S3

on:
  push:
    branches:
      - main  # main 브랜치에 푸시될 때 실행

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4  # 리포지토리 코드 체크아웃

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'  # Node.js 버전 지정

      - name: Install Dependencies
        run: npm install  # 의존성 설치

      - name: Build React App
        run: CI=false npm run build  # 프로덕션 빌드 생성

      - name: Deploy to AWS S3
        uses: jakejarvis/s3-sync-action@master
        with:
          args: --delete  #  불필요한 파일 삭제
        env:
          AWS_S3_BUCKET: ${{ secrets.S3_BUCKET }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          SOURCE_DIR: 'dist'  # 빌드된 파일이 있는 디렉토리
```

#### GitHub Secrets 설정

1. 프로젝트 → Settings → Secrets and variables → Actions
2. New repository secret 클릭
3. 다음 항목 추가:
  - `S3_BUCKET`: 버킷 이름
  - `AWS_ACCESS_KEY_ID`: IAM 액세스 키
  - `AWS_SECRET_ACCESS_KEY`: IAM 비밀 키
  - `AWS_REGION`: `ap-northeast-2`

#### 자동 배포
main 브랜치에 푸시하면 자동으로 빌드 및 배포가 실행됩니다.

---

## 📝 최종 정리

### 오늘 배운 핵심 개념

1. **컨테이너 이미지 관리**
  - Docker Hub를 통한 이미지 공유 및 배포
  - 태그 관리와 버전 관리의 중요성

2. **클라우드 환경 구축**
  - AWS EC2에 Docker 환경 설정
  - Docker Compose를 활용한 멀티 컨테이너 관리

3. **CI/CD 자동화**
  - GitHub Actions를 통한 자동 빌드/배포
  - 환경 변수 관리와 보안 설정

4. **정적 웹 호스팅**
  - S3를 활용한 React 앱 배포
  - 버킷 정책 설정과 퍼블릭 액세스 관리

### 실무 적용 포인트

- **Docker Hub**: 팀 간 이미지 공유로 개발 환경 통일
- **EC2 + Docker**: 서버리스보다 제어가 필요한 경우 활용
- **GitHub Actions**: 코드 푸시만으로 자동 배포되는 파이프라인 구축
- **S3 정적 호스팅**: 프론트엔드 앱의 빠르고 저렴한 배포
