# 🗓️ 2025년 8월 13일 TIL

## 오늘의 키워드

* 여행 생성 로직
* JPA에서 FK 처리 방식
* 스프링 시큐리티 인가 설정
* 토큰 기반 인증/인가 흐름

---

## ✨ 여행 생성 과정

1. **유저 확인 (로그인 필수)**

    * 여행을 생성하려면 반드시 로그인된 유저여야 한다.
    * 토큰에서 유저 이름을 파싱하여 DB에서 유저 엔티티를 조회한다.

   ```java
   // 토큰에서 파싱한 유저이름을 통해 유저정보 조회
   User foundUser = userRepository.findByUsername(username)
           .orElseThrow(
                   () -> new BusinessException(ErrorCode.USER_NOT_FOUND)
           );
   ```

2. **여행 엔티티 생성**

    * JPA에서는 FK를 단순히 `id`로 넣지 않고 **엔티티 객체 자체**를 넣어야 한다.

   ```java
   Trip savedTrip = Trip.builder()
           .title(request.getTitle())
           .budget(request.getBudget())
           .description(request.getDescription())
           .startDate(request.getStartDate())
           .endDate(request.getEndDate())
           .status(request.getStatus())
           .destination(request.getDestination())
           .user(foundUser) // 로그인한 유저 엔티티
           .build();
   ```

---

## 🔒 토큰 기반 인가 설정

* 토큰이 필요한 작업에서는 반드시 헤더에 토큰을 포함해야 요청 가능하다.
* `SecurityConfig.java`에서 경로별 접근 권한을 설정한다.

```java
// 인가 설정
.authorizeHttpRequests(
        auth -> auth
                // 공개 접근 경로 (로그인 불필요)
                .requestMatchers("/", "/login", "/signup").permitAll()
                .requestMatchers("/css/**", "/js/**", "/images/**").permitAll()
                .requestMatchers("/api/auth/**").permitAll()

                // 인증/권한 필요한 경로
                .requestMatchers("/api/**").authenticated()

                // 그 외 모든 요청도 인증 필요
                .anyRequest().authenticated()
)
```

---

## 🛠️ 토큰 인증 흐름

1. 클라이언트가 로그인 성공 시 **토큰을 발급받음**
2. 토큰이 필요한 작업 요청 시 → **HTTP 헤더에 토큰 포함**
3. 서버는 토큰을 파싱 → 유효성 검사 → 사용자 정보 추출
4. 추출된 사용자 정보(예: username)를 비즈니스 로직에서 활용

---

## 📌 추가 개념

* `@AuthenticationPrincipal`
  → 스프링 시큐리티 컨텍스트에서 **인증된 사용자 정보**를 바로 가져올 수 있는 어노테이션

---

## 📝 오늘의 정리

* JPA에서 FK는 **엔티티 객체 자체**를 넣어야 한다는 점을 다시 확인했다.
* 스프링 시큐리티에서 **경로별 인가 설정**을 통해 인증/비인증 구간을 나눌 수 있다.
* 토큰 기반 인증은 **로그인 → 토큰 발급 → 요청 시 토큰 포함 → 서버 검증**의 흐름으로 진행된다.

