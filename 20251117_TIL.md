# 🗓️ 2025년 11월 17일 TIL - c언어

## 📌 오늘의 키워드

`퀵 정렬 (Quick Sort)` `피벗 (Pivot)` `분할 (Partition)` `재귀 호출`
`O(N log N)` `분할 정복 (Divide and Conquer)` `스왑 (Swap)`

---

## 1️⃣ 퀵 정렬(Quick Sort)의 개념

### 💡 정의

* **분할 정복(Divide and Conquer)** 전략을 사용하는 대표적인 정렬 알고리즘
* 배열에서 하나의 원소를 **피벗(pivot)** 으로 선택하고,
  이를 기준으로 **작은 값은 왼쪽, 큰 값은 오른쪽**으로 분할한 뒤
  각 부분 배열을 재귀적으로 정렬한다.

### 주요 개념 정리

| 용어             | 의미                          |
| -------------- | --------------------------- |
| 피벗 (Pivot)     | 배열을 나누는 기준 값                |
| 탐험가 (j)        | 배열을 순회하면서 피벗과 비교            |
| 감독관 (i)        | 피벗보다 작은 값들이 모일 구역의 끝 인덱스    |
| 분할 (Partition) | 피벗을 기준으로 작은 값과 큰 값을 구분하는 과정 |

---

## 2️⃣ 코드 구조 및 동작 원리

### 💻 예시 코드 요약

```c
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int partition(int arr[], int low, int high) {
    int pivot = arr[high];  // 피벗은 배열의 마지막 요소
    int i = (low - 1);

    for (int j = low; j <= high - 1; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }

    i++;
    swap(&arr[i], &arr[high]); // 피벗을 자신의 위치로 이동
    return i; // 피벗의 최종 인덱스 반환
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);   // 왼쪽 부분 정렬
        quickSort(arr, pi + 1, high);  // 오른쪽 부분 정렬
    }
}
```



---

## 3️⃣ 정렬 과정 시각화

> 정렬 대상 배열:
> `7, 2, 1, 6, 8, 5, 3, 4`

1️⃣ 피벗 = 4 (마지막 요소)
→ 4보다 작은 값들을 왼쪽으로 이동
결과: `[2, 1, 3, 4, 8, 5, 7, 6]`
피벗 4의 위치 확정 (인덱스 3)

2️⃣ 왼쪽 부분 `[2, 1, 3]` 정렬
→ 피벗 = 3 → `[2, 1, 3] → [1, 2, 3]`

3️⃣ 오른쪽 부분 `[8, 5, 7, 6]` 정렬
→ 피벗 = 6 → `[5, 6, 7, 8]`

📊 최종 결과:
`[1, 2, 3, 4, 5, 6, 7, 8]`

---

## 4️⃣ 퀵 정렬의 시간 복잡도

| 구분         | 시간 복잡도     | 설명                               |
| ---------- | ---------- | -------------------------------- |
| **최선의 경우** | O(N log N) | 피벗이 매번 중간값 근처일 때                 |
| **평균의 경우** | O(N log N) | 대부분의 무작위 배열에서                    |
| **최악의 경우** | O(N²)      | 피벗이 항상 최소값 또는 최대값일 때 (예: 정렬된 배열) |

---

## 5️⃣ 장점과 단점

### ✅ 장점

* 평균적으로 **가장 빠른 정렬 알고리즘 중 하나**
* **추가 메모리 사용이 적음** (in-place 정렬)
* 분할 정복 기반이라 **병렬화(parallelization)** 가능

### ⚠️ 단점

* **불안정 정렬(Unstable sort)** — 동일한 값의 순서가 보장되지 않음
* 이미 정렬된 배열에서 **최악의 성능(O(N²))** 발생 가능
* 재귀 호출이 깊어질 경우 **스택 오버플로우** 가능

---

## 6️⃣ 퀵 정렬 vs 다른 정렬

| 정렬 알고리즘   | 평균 시간 복잡도    | 공간 복잡도   | 안정성 | 특징             |
| --------- | ------------ | -------- | --- | -------------- |
| **버블 정렬** | O(N²)        | O(1)     | 안정적 | 구현 쉬움, 느림      |
| **선택 정렬** | O(N²)        | O(1)     | 불안정 | 교환 적지만 비교 많음   |
| **삽입 정렬** | O(N²) / O(N) | O(1)     | 안정적 | 거의 정렬된 데이터에 유리 |
| **퀵 정렬**  | O(N log N)   | O(log N) | 불안정 | 평균적으로 가장 빠름    |

---

## 🎯 최종 정리

* 퀵 정렬은 **피벗을 기준으로 분할 후 재귀 정렬**하는 알고리즘
* 평균적으로 매우 빠르지만, **피벗 선택 전략이 핵심**
* 정렬된 배열에서는 **O(N²)** 로 성능 저하
* **무작위 데이터** 또는 **랜덤 피벗 선택 기법**을 사용하면
  안정적으로 O(N log N)에 가까운 성능을 유지할 수 있다.

---

## 💬 오늘의 소감

오늘은 정렬 알고리즘 중 가장 효율적인 **퀵 정렬**을 학습했다.
버블·선택·삽입 정렬은 비교 횟수가 많아 느렸지만,
퀵 정렬은 **분할 정복**으로 문제를 효율적으로 해결한다는 점이 인상 깊었다.
특히 `partition()` 함수에서 **감독관(i)** 과 **탐험가(j)** 의 개념으로
값을 교환하며 피벗을 중심으로 정렬하는 흐름이 직관적으로 이해되었다.
