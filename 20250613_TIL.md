# 🗓️ 2025년 6월 13일 TIL

1-click-dropdown
```js
console.log('before global click');
console.log('after global click');
```
이 두가지 사이에 문제가 있어보이는 코드를 집어넣고 로그를 보면서 디버깅을 하면 용이하다는걸 배움.

contains는 자기 자신과 후손까지 포함
$dropDownMenu.contains(e.target)는 선택된 이벤트 객체가 자기 자신 혹은 후손과 같다면 true, 다르다면 false를 반환한다.

문서 전체에 이벤트를 걸어서 드롭다운 외부 영역을 눌러도 닫히게 만들음.
버튼이나 메뉴를 눌렀을 때는 return; 하여 문서 전체에 이벤트를 걸었기 때문에 버블링으로 버튼을 눌러도 메뉴가 안 열리는 문제를 막음.

```js
document.addEventListener('click', e => {
  if (
    $dropDownBtn.contains(e.target)
    || $dropDownMenu.contains(e.target)
  ) return;

  $dropDownMenu.classList.remove('show');
});
```






2-hover-dropdown
css의 hover를 이용하여 드롭 다운 메뉴를 여는 방법

> 마우스를 `.dropdown` 요소에 올렸을 때,
> 그 안에 있는 **자식 요소 `.dropdown-toggle`의 바로 다음 형제 요소**인
> `.dropdown-menu`에 스타일을 적용한다.

```
/* 드롭다운 버튼에 호버할 때만 드롭다운 메뉴 표시 */
<style>
.dropdown:hover > .dropdown-toggle + .dropdown-menu {
    display: block;
}
</style>
```

| 선택자 구성                                                | 의미                                                                 |
| ----------------------------------------------------- | ------------------------------------------------------------------ |
| `A:hover`                                             | A 요소에 마우스를 올렸을 때                                                   |
| `A > B`                                               | A의 자식 요소 중 B                                                       |
| `B + C`                                               | B 바로 다음 형제 C                                                       |
| `.dropdown:hover > .dropdown-toggle + .dropdown-menu` | `.dropdown`에 hover → `.dropdown-toggle` 바로 뒤의 `.dropdown-menu`를 선택 |


```js
<div class="dropdown">
  <button class="dropdown-toggle">메뉴</button>
  <div class="dropdown-menu">
    <a href="#">옵션 1</a>
    <a href="#">옵션 2</a>
    <a href="#">옵션 3</a>
  </div>
</div>
```



자바스크립트 마우스 진입을 이용하여 드롭 다운 메뉴 열기
## 🖱️ 마우스 이벤트 - `mouseenter` vs `mouseover`

### ✅ 공통점
- 둘 다 **마우스가 요소에 들어올 때 발생하는 이벤트**이다.
- JavaScript에서 `addEventListener`를 통해 사용할 수 있다.

---

### 🔹 `mouseover`
- 마우스가 요소 **위로 올라갈 때마다** 이벤트가 발생한다.
- **자식 요소에 진입해도 이벤트가 다시 발생**한다.
- 이벤트가 여러 번 실행될 수 있다.

```js
element.addEventListener('mouseover', () => {
  console.log('마우스가 올려짐!');
});
```

#### 📌 예시

```html
<div id="parent">
  부모 요소
  <div id="child">자식 요소</div>
</div>
```

* 마우스가 `parent` 위로 진입할 때 발생
* 이후 `child`로 이동해도 다시 발생함

---

### 🔹 `mouseenter`

* 마우스가 해당 요소에 **처음 들어왔을 때만** 이벤트 발생
* **자식 요소에 들어가도 이벤트가 다시 발생하지 않음**
* 더 정제된 진입 이벤트를 감지할 수 있다

```js
element.addEventListener('mouseenter', () => {
  console.log('처음 들어왔어요!');
});
```

#### 📌 예시

위와 같은 구조에서도 `child`에 진입해도 이벤트가 중복 발생하지 않음

---

### 🔍 요약 비교표

| 이벤트          | 자식 요소 진입 시 | 반복 실행 여부 | 대표 사용 예      |
| ------------ | ---------- | -------- | ------------ |
| `mouseover`  | ✅ 발생       | ✅ 반복됨    | 툴팁, 서브메뉴     |
| `mouseenter` | ❌ 발생 안 함   | ❌ 한 번만   | 섹션 강조, 안내 문구 |

---

### ✨ 느낀 점

* 처음에는 두 이벤트가 비슷하다고 생각했지만, 자식 요소에 대한 반응 유무가 큰 차이를 만든다는 것을 실습을 통해 느꼈다.
* 복잡한 UI 요소에서는 `mouseenter`가 더 안정적인 반응을 줄 수 있다는 점을 깨달았다.



탭 기본
```js
// 모든 탭버튼과 탭콘텐츠를 가져옴
const $tabButtons = [...document.querySelectorAll('.tab-button')];
const $tabContents = [...document.querySelectorAll('.tab-content')];

// 모든 탭버튼에 클릭 이벤트 추가
$tabButtons.forEach($button => {
  $button.addEventListener('click', e => {
    // 기존에 붙어있는 active들은 전부제거
    $tabButtons.forEach($btn => $btn.classList.remove('active'));
    $tabContents.forEach($content => $content.classList.remove('active'));

    // 클릭된 탭 버튼과 그에 해당하는 탭 콘텐츠에 클래스 active를 부여
    $button.classList.add('active');

    // 클릭된 탭버튼에 붙은 커스텀 속성 data-tab과
    // 연동된 컨텐츠박스의 id가 일치하도록 설계했음
    const $contentBox = document.getElementById($button.dataset.tab);
    $contentBox.classList.add('active');

  });
});
```
1. 모든 탭버튼과 탭콘텐츠를 가져와서, 모든 탭 버튼에 클릭 이벤트를 추가했고, 기존에 붙어 있는 active 클래스를 제거하기 위해 forEach 문을 사용하는걸 배움.
2. html을 설계할 때 탭 버튼을 이용하기 위해 dataset을 활용한 것이 인상 깊었음.
- 처음 html을 잘 설계해두면 요소들을 가져오고, 속성을 변경시킬 때 훨씬 편해진다는걸 알았다.
- 그리고, 탭버튼의 dataset과 컨텐츠박스의 id가 일치하도록 설계하여서 $button.dataset.tab이 컨텐츠박스의 id 값이 될 수 있었다.
- 그리하여 컨텐츠박스 요소를 가져오고, active 클래스를 추가하는게 훨씬 편해질 수 있다는걸 배웠다.
- $button.dataset.tab은 클릭 이벤트의 이벤트 객체 e가 버튼과 같으므로 e.target.dataset.tab과 같은걸 알 수 있었음.

탭 실습은 따로 ([20250613_TIL_tab.md](./20250613_TIL_tab.md))에 정리함.


모달 기본
```js
const $openModalBtn = document.getElementById('openModal');
const $modalOverlay = document.getElementById('modalOverlay');
const $closeModalBtn = document.querySelector('.close-btn');

function openModal() {
  $modalOverlay.style.display = 'flex';
  // 모달이 열렸을 때 스크롤이 되면 UX에 좋지 못함.
  document.body.style.overflow = 'hidden';
}

function closeModal() {
  $modalOverlay.style.display = 'none';
  // 모달을 닫으면 스크롤이 되야함.
  document.body.style.overflow = '';
}

$openModalBtn.addEventListener('click', e => {
  openModal();
});

$closeModalBtn.addEventListener('click', e => {
  closeModal();
});

// esc 누르면 모달이 닫히도록
document.addEventListener('keydown', e => {
  if (e.key === 'Escape') {
    closeModal();
  }
});

// 모달 배경을 눌러도 닫히도록
$modalOverlay.addEventListener('click', e => {
  // if (e.target.matches('.modal-overlay'))
  if (e.target === $modalOverlay) {
    closeModal();
  }
});

```
배운 점
1. openModal, closeModal 함수처럼 동일한 코드가 반복되면 함수로 만들어서 논리의 흐름을 간단하게 만들 수 있음을 배움.
- 예를 들어서, esc를 누르면 모달이 닫히게 하고싶다면 esc 감지, closeModal().
2. 모달이 열렸을 때는 스크롤이 되면 UX에 좋지 않기 때문에 document.body.style.overflow = 'hidden';으로 스크롤이 안되게끔 해줘야 하며, 이후에 모달을 닫았을 때는 document.body.style.overflow = '';로 스크롤이 정상 작동하게 만들어줘야한다.
3. 모달의 닫힘 버튼이 아닌 오버레이를 눌러도 닫히도록 하고싶다면, 아래처럼 이벤트 객체의 프로퍼티를 통해 조건을 걸어줘서 정확히 오버레이를 클릭할 때만 닫히도록 해야한다.
```js
if (e.target === $modalOverlay) {
  closeModal();
}
```

모달 실습은 따로 ([20250613_TIL_modal.md](./20250613_TIL_modal.md))에 정리함.



좌표와 위치

```js
$moveBtn.addEventListener('click', e => {
  const rect = $box.getBoundingClientRect();
  console.log(rect);

  $box.style.top = `${rect.top + 50}px`;
  $box.style.left = `${rect.left + 50}px`;
});
```

getBoundingClientRect(): 해당 요소의 위치와 크기 정보를 가져온다.

const rect = $box.getBoundingClientRect();
rect의 위치 정보는 박스 좌측 상단 꼭짓점의 좌표를 기준으로 나타난다.
좌표의 0, 0은 브라우저 기준 좌측 상단 구석이며, 아래로 내려 갈 수록 y좌표가 늘어나고, 우측으로 갈 수록 x좌표가 늘어난다.

$box.style.top = `${rect.top + 50}px`;
$box.style.left = `${rect.left + 50}px`;
위의 코드를 통해 버튼을 눌렀을 때 50px씩 박스를 옮길 수 있다. 위치를 바꾼다는 생각을 했을 때, 아직 백틱을 활용한 문법이 잘 떠오르지 않는걸 보면 연습이 더 필요해보인다.


마우스 좌표정보 가져오기
```js
document.addEventListener('mousemove', e => {
  console.log(`x: ${e.clientX}, y: ${e.clientY}`);
});
```


스크롤 위치정보 가져오기
```js
document.addEventListener('scroll', e => {
  // console.log(`스크롤위치: ${window.scrollY}`);
  if (window.scrollY >= 500) {
    document.body.style.background = 'violet';
  } else {
    document.body.style.background = 'transparent';
  }
});
```
- 스크롤을 움직이지 않았을 때는 스크롤의 위치가 0이며, 아래로 내릴수록 크기가 증가한다.
- 가로 스크롤을 사용할 경우 UX가 심하게 안 좋아지므로 지양해야 한다는 것을 배움.
- 해당 코드에서는 일정 부분 스크롤을 내렸을 때 색이 변하는 것을 나타냈는데, 활용하면 웹사이트에서는 일정 부분 내리면 상단에 검색 바가 나오는 경우가 있다.





드래그 & 드랍

드롭 존과 빈 박스 정의
```js
const $dropZone = document.getElementById('dropZone');

// 드래그가 끝날때 해당 박스가 들어갈 자리를 보여주는 빈 박스 생성
const $placeholder = document.createElement('div');
$placeholder.classList.add('placeholder');
```


드래그 시작(dragstart) 이벤트 바인딩
- 드롭존안에 있는 요소를 드래그하기 시작하면 발동
- 드래그한 요소를 기존 화면에서 제거
- 너무 빨리 사라져서 잡을 수 없게 되므로.
- 잡은 후 hidden이 될 수 있게끔 딜레이를 준다.
```js
$dropZone.addEventListener('dragstart', e => {


  setTimeout(() => {
    e.target.classList.add('hidden');
  }, 10);
});
```

드래그 끝(dragend) 이벤트 바인딩
- 원래 안에 있는 녀석을 드롭했을 때
- draggable-item에서 드롭시 벌어지는 일
- 생성 됐던 빈 박스의 태그를 replaceWith를 통해 드래그 중인 이벤트 객체(e.target = 박스)와 바꾸는 점이 인상 깊음.
```js
$dropZone.addEventListener('dragend', e => {
  e.target.classList.remove('hidden');

  // 드래그중인 박스와 빈 박스랑 교체
  $placeholder.replaceWith(e.target);
});
```

드래그 오버(dragover) 이벤트 바인딩
- 외부에서 가져온 파일이나 요소를 드래그하는 이벤트
- 드래그를 시작하여 그 상태를 유지하고 있을 때 발생함
- 드래그 오버 중에는 e.target이 드래그 요소로 덮고 있는 요소 (밟고 있는 요소)임을 명심해야함.
- if 문을 통해 마우스 포인터가 밟고있는 객체의 절반보다 위쪽이면 before를 통해 위쪽에 빈 박스 생성, 아래쪽이면 after를 통해 아래쪽에 빈 박스를 생성하는게 배울점임.
```js
$dropZone.addEventListener('dragover', e => {
  e.preventDefault();

  // 현재 드래그 중인 요소의 마우스 좌표에 따라 빈 박스가 들어갈 위치를 정함
  // e.target : 드래그 요소로 덮고 있는 요소 (밟고 있는 요소)
  const $target = e.target;
  // 밝고있는게 드래그 가능한 요소일 때만 빈박스 배치
  if ($target.classList.contains('draggable-item')) {

    // 밟고있는 target의 위치정보를 확인
    const rect = $target.getBoundingClientRect();
    // 현재 마우스포인터와 target 간의 top 거리를 계산
    const distance = e.clientY - rect.top;

    if (distance < rect.height / 2) {
      $target.before($placeholder);
    } else {
      $target.after($placeholder);
    }
  }
});
```



드롭(drop) 이벤트 바인딩
- 드롭이벤트: 외부 파일이나 다른곳에서 떨어뜨린 아이템
- 파일이나 이미지를 드롭하면 새 탭에서 이미지가 열리거나 파일이 다운로드되는데 이런 일이 발생하면 드롭이벤트가 정상처리 안됨
- 드래그 오버에서도 기본 기능 방지(e.preventDefault();)를 해줘야 함.
```js
$dropZone.addEventListener('drop', e => {
  e.preventDefault();
});
```