# 🗓️ 2025년 9월 17일 TIL


웹소켓

상태 업데이트 로직 추가 및 
하트비트 기능 추가로 참여자 상태를 
주기적으로 전송하도록 수정

백엔드 소켓 요청 API
1. 소켓 연결 /ws
2. 구독 /topic
3. 메시지전송 /app


사용자가 'ONLINE', 'STUDYING', 'BREAK' 셋중에 하나 클릭
-> 내 상태(ONLINE/STUDYING/BREAK) 변경 `wsSend`로 전송

```java
/**
 * 사용자가 자신의 상태(ONLINE/STUDYING/BREAK)를 변경할 때 호출되는 STOMP 핸들러.
 *
 * 핵심 개념
 * - @MessageMapping("/rooms/{roomId}/presence/update") 는
 *   프론트에서 client.send("/app/rooms/{roomId}/presence/update", body) 로 보낸 메시지를 처리합니다.
 *   여기서 "/app" 은 서버로 보내는 주소의 접두사(전송 prefix)입니다.
 * - @DestinationVariable Long roomId: 경로의 {roomId} 값을 숫자로 받습니다.
 * - @Payload PresenceUpdateRequest req: STOMP 메시지 본문(JSON)을 자바 객체로 변환해줍니다.
 * - Principal principal: 현재 웹소켓 세션의 인증 사용자(쿠키 기반 인증에서 꺼냄)입니다.
 *
 * 프론트엔드 예시 (React, websocketService.js 가정)
 *
 * // 상태를 "STUDYING" 으로 변경
 * wsSend(`/app/rooms/${roomId}/presence/update`, { status: 'STUDYING' });
 *
 * // 상태를 "BREAK" 로 변경
 * wsSend(`/app/rooms/${roomId}/presence/update`, { status: 'BREAK' });
 */
@MessageMapping("/rooms/{roomId}/presence/update")
public void update(@DestinationVariable Long roomId, @Payload PresenceUpdateRequest req, Principal principal) {
    // 안전장치: 인증/바디 누락 시 무시
    if (principal == null || req == null || req.status() == null) return;
    String providerId = principal.getName();
    ParticipantStatus status;
    try {
        status = ParticipantStatus.valueOf(req.status());
    } catch (IllegalArgumentException ex) {
        // 허용되지 않은 값이면 무시 (예: 오타)
        return;
    }
    // 서비스에 위임: 상태 저장 + 해당 방으로 브로드캐스트
    presenceService.updateStatus(roomId, providerId, status);
}
```

```java
/** 사용자가 자신의 상태를 바꿀 때(예: ONLINE → STUDYING) */
public void updateStatus(Long roomId, String providerId, ParticipantStatus status) {
    store
        .computeIfAbsent(roomId, k -> new ConcurrentHashMap<>())
        .put(providerId, status);
    broadcast(roomId, providerId, status);
}
```


하트비트: 방 상세 페이지가 열려 있고 참여자인 동안만 주기 전송

```jsx
useEffect(() => {
  if (!roomId || !isParticipant) return;
  let intervalId = null;
  const start = () => {
    if (document.visibilityState !== 'visible') return;
    if (intervalId) return;
    intervalId = setInterval(() => {
      wsSend(`/app/rooms/${roomId}/presence/heartbeat`, {});
    }, 15000);
  };
  const stop = () => {
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = null;
    }
  };
  const onVisibility = () => {
    if (document.visibilityState === 'visible') start();
    else stop();
  };
  start();
  window.addEventListener('visibilitychange', onVisibility);
  window.addEventListener('focus', start);
  window.addEventListener('blur', stop);
  return () => {
    stop();
    window.removeEventListener('visibilitychange', onVisibility);
    window.removeEventListener('focus', start);
    window.removeEventListener('blur', stop);
  };
}, [roomId, isParticipant]);
```


SSE(Server-Sent Events) 알림 서비스
- 서버에서 클라이언트로 실시간으로 데이터를 보내는 기술입니다.
- WebSocket과 달리 "단방향" 통신입니다 (서버 → 클라이언트만 가능).
- 브라우저가 탭을 백그라운드로 보내도 알림을 받을 수 있습니다.

WebSocket과 SSE의 차이점은?
- WebSocket: 양방향 통신 (서버 ↔ 클라이언트) - 채팅에 적합
- SSE: 단방향 통신 (서버 → 클라이언트) - 알림에 적합

SSE는 언제 사용하나요?
- 새 메시지가 왔을 때 브라우저 알림을 보내고 싶을 때
- 사용자가 다른 탭을 보고 있어도 알림을 받아야 할 때
- 실시간 상태 업데이트 (온라인/오프라인 등)를 알려주고 싶을 때


새로운 SSE 연결을 등록 (createConnection, 사용자가 알림을 받기 시작할 때 호출)
동작 과정:
1. 사용자가 웹페이지에 접속하면 프론트엔드에서 `/api/notifications/subscribe`를 호출
2. 이 메서드가 실행되어 해당 사용자를 위한 SSE 연결을 만듦
3. 이제 서버에서 이 사용자에게 실시간 알림을 보낼 수 있음


REST는 기본적으로 JSON을 반환하지만,아래와 같이 특정 값을
produces로 지정해주면 여러 형태의 값을 반환 가능
`@GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)`

---

프론트 SSE 알림 시스템 초기화
AppLayout (앱의 최초 엔드포인트)에 진입하면 useEffect로
브라우저 알림 권한 요청 (사용자 동의 필요)을 진행,
SSE 연결 시작(connectSSE)

connectSSE
1️⃣ EventSource 객체 생성 (브라우저의 SSE 클라이언트)

2️⃣ 연결 성공 이벤트 처리
```js
eventSource.addEventListener('connected', (event) => {
  console.log('✅ SSE 연결 성공:', event.data);
  isConnected = true;
  reconnectAttempts = 0; // 재연결 카운터 초기화

  // 연결 성공을 알림
  notifyListeners('connected', { message: event.data });
});
```

백엔드에서의 createConnection
```java
// 3) 연결 성공 메시지를 클라이언트에게 즉시 전송 (연결이 잘 되었는지 확인용)
try {
    emitter.send(SseEmitter.event()
        .name("connected")  // 이벤트 이름 (프론트엔드에서 addEventListener로 받음)
        .data("SSE 연결이 성공했습니다.")); // 실제 데이터
} catch (IOException e) {
    log.warn("SSE 연결 완료 이벤트 전송 실패: providerId={}", providerId, e);
    removeEmitter(providerId, emitter); // 실패하면 연결 제거
}
```

3️⃣ 알림 메시지 수신 처리
4️⃣ 하트비트 수신 처리 (연결 유지 확인용)
5️⃣ 연결 테스트 메시지 수신 처리
6️⃣ 연결 오류 처리

브라우저 알림에 문제가 있다면 크롬 사이트 설정 - 알림 허용 확인

---

## Spring ai
- OpenAI, GEMINI, 클로드 등 여러가지 AI가 있는데, API 콜 스펙이 다름.
- 이를 yml설정만 해두면 알아서 스프링이 스펙에 맞게 요청해주도록 함

build.gradle
```groovy
ext {
	set('springAiVersion', '1.0.0-M5')
}

repositories {
    mavenCentral()
    maven { url 'https://repo.spring.io/milestone' }
}

// 의존성 추가
// Spring AI (Google AI via OpenAI compatible API)
implementation "org.springframework.ai:spring-ai-openai-spring-boot-starter:${springAiVersion}"
```

GEMINI API 키 발급
https://aistudio.google.com/apikey

.env에 설정
```env
# Spring AI / Gemini (Google AI API Key)
GEMINI_API_KEY=
GEMINI_MODEL=gemini-2.0-flash
```

yml 설정
```yml
spring:
  ai:
    openai:
      base-url: https://generativelanguage.googleapis.com/v1beta/openai/
      api-key: ${GEMINI_API_KEY}
      chat:
        completions-path: /chat/completions
        options:
          model: ${GEMINI_MODEL}
```

```java
@Configuration
public class AIConfig {
    @Bean
    public ChatClient chatClient(ChatClient.Builder builder) {
        // ChatClient.Builder 는 Spring AI가 자동 구성합니다.
        // application.yml 의 spring.ai.openai.* 옵션을 사용해 빌드됩니다.
        return builder.build();
    }
}
```

문맥 유지를 위해 프론트엔드에서는 "AI 대화"의 전역 상태를 관리(Zustand)
백엔드에서는 DB에 저장
새로고침을 하는 유저들은 백엔드의 DB에서 가져와서 다시 쌓아야 함.

왜 전역 상태로 관리?
- 대화 내역(문맥, 컨텍스트)을 여러 컴포넌트(패널, 버튼 등)에서 공통으로 보여주기 위해서입니다.
- 페이지 이동/리렌더링이 발생해도 대화 흐름을 유지하기 위함입니다.

왜 메시지들을 배열로 관리?
- LLM은 "대화 문맥(context)"을 기반으로 응답
- 과거의 사용자/AI 메시지가 함께 전달되어야 더 자연스러운 답변이 나옵니다.
- 그래서 messages 배열은 [user, assistant, user, assistant, ...] 순서를 보존합니다.