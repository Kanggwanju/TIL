# 🗓️ 2025년 7월 7일 TIL

컬렉션 프레임워크
List, Set, Map



컬렉션 프레임워크
List, Set, Map



List
1. 순서가 있는 데이터구조
2. 중복 데이터 저장을 허용

종류: 배열리스트, 연결리스트

배열리스트
전체 탐색을 할 때 효율이 좋음
삭제, 삽입을 할 때 문제가 있음

연결리스트
전체 탐색을 할 때 효율이 안 좋음
삭제, 삽입을 할 때 간단함


## ✅ `ArrayList`는 전체 탐색에 효율적인 이유

`ArrayList`는 내부적으로 **배열(Array)** 구조로 데이터를 저장

```java
List<String> list = new ArrayList<>();
```

### ✅ 장점: 인덱스를 이용한 순차 접근이 빠름

* `list.get(i)`처럼 인덱스로 접근할 때 **시간복잡도는 O(1)** → 매우 빠름
* 배열처럼 메모리상에 연속적으로 저장되어 있어 \*\*캐시 효율(Cache locality)\*\*도 좋음


ArrayList는 중간 삽입, 삭제 속도가 느림

LinkedList는 i번째 노드를 처음부터 포인터를 따라가야 하므로
순차 접근 속도가 느리다.
대신 중간 삽입, 삭제 속도가 빠르다

따라서 전체 탐색을 빈번하게 진행해야 할 때는
ArrayList 자료구조를 사용하고, 중간 삽입 삭제를
빈번하게 진행해야 할 때는 LinkedList를 사용


ArrayList 생성
`List<String> hobbies = new ArrayList<>();`

리스트에 데이터 추가
`hobbies.add("수영");`
여러가지 데이터 한번에 추가
`hobbies.addAll(List.of("밥먹기", "멍때리기"));`
중간 삽입
`hobbies.add(1, "코딩");`
데이터 개수 확인
`int size = hobbies.size();`
인덱스 찾기, 없으면 -1
`int index1 = hobbies.indexOf("영화감상");`
요소 포함 여부
`boolean flag = hobbies.contains("코딩");`

요소 삭제
`hobbies.remove("수영");` // "수영" 데이터 삭제
`hobbies.remove(2);` // 2번 인덱스 삭제

요소 수정
`hobbies.set(0, "디자인");`

요소 참조
해당 인덱스 데이터 반환
`String hobby = hobbies.get(1);`

리스트 순회 (반복문처리)
`for (int i = 0; i < hobbies.size(); i++) {
    System.out.println(hobbies.get(i));
}`

iter 반복문
`for (String h : hobbies) {
    System.out.println(h);
}`

forEach
`hobbies.forEach((String hob) -> System.out.println(hob));`

전체 삭제
`hobbies.clear();`

리스트에 초기값 넣고 시작하기


그냥 List.of를 통해 배열 리스트를 만들 때는 불변성
속성이 추가되어 수정, 삭제가 불가능해짐
`List<Integer> numbers = List.of(1, 3, 5, 7, 9);`
-> 불가능 `numbers.add(1);` 


이를 해결하기 위해서 new ArrayList<>(List.of(초기값));으로
배열 리스트를 생성하면 초기값을 추가하여 만들 수 있다.
`List<Integer> numbers = new ArrayList<>(List.of(1, 3, 5, 7, 9));`
-> 가능 `numbers.add(1);`



Set (집합)
1. 중복을 허용하지 않는다.
2. 순서를 보장하지 않는다. (해시)


Set 생성
`Set<String> set = new HashSet<>();`

데이터 추가
set.add 메서드는 중복을 허용하지 않음.
데이터를 추가했을 때 이미 있다면 false, 없다면 true 반환
`set.add("떡볶이");`
`set.add("김말이");`
`boolean flag1 = set.add("김밥");`
`set.add("단무지");`
`boolean flag2 = set.add("김밥");`

데이터 개수 확인
`int size = set.size();`

요소 삭제
`set.remove("단무지");`

set은 순서가 없기 때문에 인덱스도 없음
그렇기 때문에 단일 탐색이 어려움 (인덱스가 없어서 전체 for문 사용)
`for (String s : set) {
    System.out.println("s = " + s);
}`


실무에서 set의 용도는 리스트 같은 자료구조의 
중복 제거 용도로 사용된다.
`List<Integer> numbers = List.of(3, 3, 1, 1, 1, 1, 1, 3, 3, 5, 5, 5, 7, 3, 2, 1, 3, 7);`
set 변환
`Set<Integer> numSet = new HashSet<>(numbers);` // [1, 2, 3, 5, 7]
list로 다시 변환
`numbers = new ArrayList<>(numSet);` // [1, 2, 3, 5, 7]


equals와 hashcode를 오버라이딩하는 이유

## ✅ 왜 `equals()`와 `hashCode()`를 오버라이딩해야 할까?

### 💡 핵심 개념 요약

* `HashSet`, `HashMap` 등은 내부적으로 객체를 비교할 때
  **`hashCode()` → `equals()` 순서로 비교**
* 두 객체가 같은지 판단하려면:

    * `hashCode()`가 같아야 함
    * `equals()`로도 true여야 함

---

### ✅ 만약 오버라이딩하지 않으면?

```java
Person p1 = new Person("김철수", "880501");
Person p2 = new Person("김철수", "880501");
```

이렇게 **내용은 같아도 서로 다른 인스턴스**이기 때문에
기본 `Object`의 `equals()`는 **주소값 비교**를 하게 된다.
→ **false**로 간주되어 HashSet에는 중복으로 들어가게 된다.

---

### 🔍 실제 결과 비교

#### 오버라이딩 전 (equals & hashCode X)

```java
Set<Person> personSet = new HashSet<>();
personSet.add(p1);
personSet.add(p2);
System.out.println("p1 == p2 ? " + (p1.equals(p2))); // false
System.out.println(personSet.size()); // 결과: 2 ← 서로 다른 객체로 판단
```

#### 오버라이딩 후

```java
@Override
public boolean equals(Object o) { ... }

@Override
public int hashCode() { ... }
```

```java
System.out.println("p1 == p2 ? " + (p1.equals(p2))); // true
System.out.println(personSet.size()); // 결과: 1 ← 동일 객체로 인식!
```

---

### ✅ 요약정리

| 항목           | 역할                                                 |
| ------------ | -------------------------------------------------- |
| `equals()`   | "논리적 동등성" 비교: 내용이 같은지 판단                           |
| `hashCode()` | 객체를 빠르게 찾기 위한 해시값 계산 (HashSet, HashMap 내부 동작에 사용됨) |

> 따라서 **HashSet이나 HashMap의 key로 사용할 클래스는 반드시 `equals()`와 `hashCode()`를 함께 오버라이딩해야** 올바르게 동작한다.

---


Map
Map (JSON 객체, 파이썬 딕셔너리 대응)
1. key와 value를 가진 엔트리 객체를 보관하는 자료구조
2. key는 중복을 허용하지 않으며 value는 중복을 허용
3. 순서를 보장하지 않음

Map 생성
value 부분을 Object라고 한 이유는 업캐스팅을 통해
String, LocalDate, Int 등의 여러가지 타입을 가질 수 
있도록 한 것
각각의 key는 통상적으로 String 타입
`Map<String, Object> map = new HashMap<>();`


데이터 추가
`map.put("empName", "김철수");`
`map.put("hireDate", LocalDate.of(2012, 5, 13));`
`map.put("salary", 5000000);`

데이터 개수 확인
`int size = map.size();`

데이터 참조
처음 들어갈 때 업캐스팅으로 map의 value로 들어왔지만
다운캐스팅을 거쳐야 고유의 기능을 사용가능하다.
`String empName = (String) map.get("empName");`
`LocalDate hireDate = (LocalDate) map.get("hireDate");`
`int salary = (int) map.get("salary");`

중복된 키를 사용해서 데이터를 삽입하면 수정된다.
`map.put("empName", "박영희");`

수정 전에는 정확하게 데이터가 있는지 체크해야함.
키를 넣어서 있다면 true, 없다면 false
`map.containsKey("salary")`

반복문 처리
map은 iter를 돌릴 수 없음 그래서 keySet()을 이용해서 반복문 수행
map.keySet()은 Map에 저장된 모든 key들을 Set에 담아 반환

keys는 Set<String> 타입이지만,
각각의 key는 String 타입이므로 `for (String key : keys)`
여기에서 String 타입이 된다.

```java
Set<String> keys = map.keySet();

for (String key : keys) {
    System.out.printf("[%s] : %s\n", key, map.get(key));
}
```

map.get(key)는 map의 value이고, value 타입은 Object
실제 값이 `String`, `LocalDate`, `int`이더라도 \*\*타입 자체는 `Object`\*\*이다.
그런데 다운캐스팅을 하지 않았는데도, 
왜 `printf("%s", map.get(key));`가 동작하는가?


✅ `System.out.printf("%s", ...)`에서 `%s`는

> 👉 **Object의 `toString()` 메서드를 자동으로 호출**

즉, 내부적으로 아래처럼 작동:

```java
System.out.println(map.get(key).toString());
```

---

## 💡 결론: 다운캐스팅이 아니라 **자동 `toString()` 호출**

* `map.get(key)`는 **Object 타입**
* `%s` 포맷은 `Object`가 오더라도 자동으로 `toString()`을 호출
* 그러므로 **명시적 캐스팅(downcasting)은 필요 없음**

---

## 🚫 다운캐스팅이 필요한 경우는?

아래처럼 **특정 타입으로 조작할 때**는 다운캐스팅이 필요

```java
Object value = map.get("age");
Integer age = (Integer) value;  // 명시적 다운캐스팅 필요
```

> `Object`는 모든 타입의 부모이지만, 자식 타입으로 직접 사용할 수는 없기 때문이다.

---

## ✅ 요약

| 상황             | 설명                            |
| -------------- | ----------------------------- |
| `map.get(key)` | 반환 타입은 `Object`               |
| `%s` 포맷 사용     | `toString()`이 자동 호출되어 문자열로 출력 |
| 다운캐스팅 필요 여부    | 값 사용하려면 필요함, 단순 출력엔 불필요       |


