# 🗓️ 2025년 7월 1일 ThrowIt 트러블슈팅 & 회고록

## 진행 기간: 2025년 6월 23일 ~ 7월 2일
## 팀 이름: ThrowIt
## 게임 이름: 깊은 바다의 전설
## 깃허브 주소: https://github.com/Throw-it-or-not/throwIt

# 🎣 1. 낚시 게임 게이지 감소 트러블슈팅

## 🐞 문제 요약

게임이 종료된 뒤에도 **게이지가 한 번 더 감소하는 현상**이 발생했음.  
게임이 끝났다고 안내가 떴지만, **게이지가 눈에 띄게 1회 추가 감소**되는 시각적 버그가 나타남.

---

## 🔍 문제 발생 코드 (버그 발생 시)

```js
changeTimerUI();
decGauageInterval();   // 게이지 감소 인터벌 시작
handleEndGame();       // 5초 후 게임 종료 예약
```

* `handleEndGame()`은 `setTimeout`으로 5초 후 실행
* 그 전에 `decGauageInterval()`이 먼저 실행되어 **게이지 감소 인터벌이 활성화**
* 게임이 종료되는 시점 직전에 **마지막 인터벌이 한 번 더 실행됨**

---

## 💡 원인 분석

* `decGauageInterval()`은 내부적으로 `setInterval()`을 사용해 일정 주기마다 게이지를 줄임
* `handleEndGame()`은 **게임 종료를 5초 뒤에 예약**하며, 그 안에서 `clearInterval(decTimerId)`를 통해 인터벌을 멈춤
* 하지만 `handleEndGame()`이 실행되기 전에 인터벌이 먼저 한 번 더 실행되면,
  → **게임이 종료된 것처럼 보이는데도 게이지가 줄어드는 현상** 발생

---

## ✅ 해결 방법

### 🔑 핵심 전략

> `handleEndGame()`을 먼저 실행해서, 게임이 끝났을 때 인터벌을 **즉시 멈출 수 있도록 예약**함

### 수정된 코드

```js
changeTimerUI();
handleEndGame();       // 먼저 실행 → 종료 시 인터벌 중지 예약
decGauageInterval();   // 그 다음 실행 → 인터벌 시작
```

### 👇 handleEndGame 내부

```js
function handleEndGame() {
  setTimeout(() => {
    // 게임 종료 시 인터벌 멈춤
    timeOver(decTimerId, watchIntervalId);

    // 점수 계산 등 후처리...
  }, setFishingTime);
}
```

→ 이렇게 하면 `decTimerId`가 확실히 정의된 상태에서 `clearInterval()`이 호출되어
**인터벌이 정상적으로 멈추고, 이후에 추가로 실행되지 않음**

---

## ✨ 결과

* 게임이 종료된 후 게이지가 더 이상 줄어들지 않음
* 사용자가 보기에도 시각적으로 안정된 종료 흐름 제공
* 비동기 작업의 순서를 정리하는 데에 있어 중요한 경험이 되었음

---

# 🎣 2. 낚시 게임 게이지 색상 불일치 트러블슈팅

## 🐞 문제 요약

게이지가 분명 **초록색으로 표시**되고 있음에도,  
게임 종료 후 결과 메시지에서는 **실패로 처리되는 현상**이 발생함.  
사용자 입장에서는 **게이지 색상과 판정이 불일치**해 혼란을 느끼는 문제였음.

---

## 🔍 문제 발생 코드 (버그 발생 시)

```js
// 색상 업데이트 함수 호출 시 성공 범위를 생략함
updateGaugeColor($gaugeBar, curPercent);

// 게임 종료 직전에 색상 업데이트 없이 바로 판정
setTimeout(() => {
  resultScore = handleFishingResult(...); // 이 시점의 색상은 마지막 값 아님
}, setFishingTime);
```

---

## 💡 원인 분석

1. 기존에는 성공 범위가 고정되어 있었기 때문에 `updateGaugeColor()`는 두 개의 인자만으로도 문제없이 동작했음

```js
// 초창기 버전 - 성공 범위 하드코딩 가정
updateGaugeColor($gaugeBar, curPercent);
```

2. 이후 **물고기 번호에 따른 난이도별 성공 범위 설정**이 도입되면서,
   `successMin`, `successMax`를 동적으로 받아야 하는 구조로 변경됨

3. 하지만 기존 호출부에서는 파라미터 전달이 누락되어
   `successMin`, `successMax`가 `undefined`로 처리됨 → 조건이 의도와 다르게 작동

4. 또한 **게임 종료 직전에 게이지 색상 업데이트가 한 번 더 이루어지지 않아**,
   마지막 상태가 화면에 정확히 반영되지 않음 → 사용자 시각과 실제 판정이 어긋남

---

## ✅ 해결 방법

### 🔑 핵심 전략

> 색상 업데이트 함수에 **항상 성공 범위를 넘겨주고**,
> 게임 종료 직전에도 색상 업데이트를 **한 번 더 실행**해서 시각적 상태와 판정 조건을 일치시킴

---

### 수정된 코드

```js
// 모든 색상 업데이트 호출부에서 성공 범위를 명시적으로 전달
updateGaugeColor($gaugeBar, curPercent, successMin, successMax);

// 게임 종료 전에 상태를 반영
setTimeout(() => {
  updateGaugeColor($gaugeBar, curPercent, successMin, successMax); // 시각 정보 반영
  resultScore = handleFishingResult(...);
}, setFishingTime);
```

---

## ✨ 결과

* 게이지 색상과 판정 결과가 항상 일치함
* 사용자 시각 피드백과 내부 로직의 신뢰성이 향상됨
* 복잡한 상태 처리에서도 **UI 일관성 유지의 중요성**을 경험함

---

## 📌 배운 점

* `setTimeout`, `setInterval`을 함께 사용할 때는 **실행 타이밍과 순서 보장이 중요**
* 종료 타이머 안에서 인터벌을 명확히 정리함으로써 **불필요한 후처리를 방지**할 수 있음
* UI와 상태 변화가 혼합된 게임 로직에서는 **명확한 종료 흐름 설계**가 중요함
* 함수의 내부 로직이 변경되면 **기존 호출부도 반드시 점검**해야 함
* UI 색상과 결과 판정은 \*\*동일한 기준(성공 범위)\*\*을 공유해야 일관된 사용자 경험을 줄 수 있음
* 게임 로직에서는 **시각적 상태와 논리 판정이 어긋나지 않도록 최종 상태 업데이트가 필수**

---


## 😕 아쉬운 점
 
* 직접 만들기 전에는 알기 어려운 부분이지만, 세부 게임 규칙(성공 판정 범위, 게이지 인터벌 시간 등)을 
미리 명확히 정하면 테스트하며 결정하는 시간이 줄어들 것으로 예상됨
* HTML과 CSS는 빠르게 정리되었지만, JavaScript 구조 설계는 다소 즉흥적으로 진행되어  
  이벤트 흐름과 상태 관리가 뒤늦게 정리되는 아쉬움이 있었음

---

## 🔧 다음 프로젝트에서 개선할 점

* 기능별 책임을 미리 나누고, 자바스크립트 코드의 **모듈 구조를 초반부터 설계**한 뒤 시작할 것  
* 게임 규칙 및 UI 요소의 세부 수치를 먼저 팀원들과 공유하고  
  **테스트 가능한 값(성공 범위, 난이도 설정 등)을 변수로 명확히 분리**할 것  
* 화면 설계와 기능 로직의 **흐름 다이어그램이나 시퀀스 플로우**를 만들어  
  팀원 간의 코드 통합 시 혼선이 생기지 않도록 정리할 것  
* 추후 유지보수를 고려하여 이벤트 리스너 해제, 리소스 정리, 상태 초기화 등  
  **게임 라이프사이클을 명확하게 관리하는 습관**을 가질 것

---

## 😊 소감

이번에는 GitHub를 활용한 협업에 익숙해졌다는 점이 큰 성과라고 생각한다.  
이슈를 생성하고, 브랜치를 생성해서 작업한 뒤 PR을 올리고 리뷰하는 일련의 과정이  
이전보다 훨씬 자연스럽게 이루어졌고, 팀원 간의 커뮤니케이션 효율도 크게 향상되었다.  
이전 프로젝트보다 협업에 소요되는 시간과 시행착오가 확실히 줄어들었다는 점이 기뻤다.

이번 낚시 게임 프로젝트를 통해 상태 관리, 비동기 처리, 인터벌 흐름 제어, UI 제어 등  
프론트엔드 개발에서 자주 마주치는 여러 문제들을 실전처럼 경험할 수 있었다.

마지막에 자바스크립트 코드를 모듈화하고 기능별로 나누는 작업은  
아직 명확하게 “수월해졌다”라고 느낄 정도로 체감하긴 어려웠지만,  
유지보수나 향후 기능 확장을 위한 좋은 준비 단계였다고 생각한다.

이번 경험을 바탕으로 다음 프로젝트에서는  
더 잘 계획해서 깔끔한 구조로 시작할 수 있을 거라는 자신감이 생겼다.
