# 🗓️ 2025년 10월 21일 TIL

## 📌 오늘의 키워드
`React` `무한 스크롤` `Intersection Observer` `WebSocket 세션 관리` `Axios Interceptor` `토큰 갱신` `UX 최적화`

---

## 1️⃣ Room 생성 서비스 개발

### RoomService API 구현
퀴즈 방 관련 API를 관리하는 서비스 레이어를 작성했습니다. Axios 기반의 apiClient를 사용하여 RESTful API와 통신합니다.

```javascript
export const RoomService = {
  // 퀴즈 방 생성
  createRoom: async (gameTitle) => {
    const response = await apiClient.post('/quiz/rooms', {
      gameTitle: gameTitle.trim(),
    });
    return response.data.data;
  },

  // 퀴즈 방 목록 조회 (페이지네이션)
  getRoomList: async (page = 0, size = 10) => {
    const response = await apiClient.get('/quiz/rooms', {
      params: { page, size },
    });
    return response.data.data;
  },

  // 방 상세 조회
  getRoomDetail: async (roomId) => {
    const response = await apiClient.get(`/quiz/rooms/${roomId}`);
    return response.data.data;
  },

  // WebSocket 세션 상태 확인
  checkWsSession: async () => {
    const response = await apiClient.get('/ws/session/active');
    return response.data.data;
  },
};
```

**핵심 포인트**
- 방 제목은 1~50자, 공백 제거 후 전송
- 페이지네이션으로 효율적인 데이터 로딩 (한 번에 13개)
- 방 상세 조회로 입장 전 유효성 검증
- WebSocket 세션 체크로 중복 입장 방지

---

## 2️⃣ Axios Interceptor를 활용한 인증 처리

### API Client 설정
HTTP-Only 쿠키 기반 인증을 사용하고, 401 에러 시 자동으로 토큰을 갱신하는 Interceptor를 구현했습니다.

```javascript
const apiClient = axios.create({
  baseURL: '/api',
  withCredentials: true, // HTTP-Only 쿠키 자동 포함
});

let isRefreshing = false;     // 토큰 갱신 중인지 여부
let refreshPromise = null;    // 갱신 Promise (여러 요청이 공유)
```

### Response Interceptor 로직

```javascript
apiClient.interceptors.response.use(
  (res) => res,
  async (error) => {
    const originalRequest = error?.config || {};
    const status = error?.response?.status;

    // 401이 아니거나 이미 갱신을 시도한 요청은 그대로 실패 처리
    if (status !== 401 || originalRequest?.skipAuthRefresh) {
      return Promise.reject(error);
    }

    // refresh 요청 자체가 실패한 경우 → 로그아웃 처리
    if (originalRequest?.url?.includes('/auth/refresh')) {
      clear();
      return Promise.reject(error);
    }

    // 무한 재시도 방지
    if (originalRequest._retry) {
      clear();
      return Promise.reject(error);
    }

    try {
      if (!isRefreshing) {
        isRefreshing = true;
        originalRequest._retry = true;

        // 동적 import로 순환 의존성 방지
        const { AuthService } = await import('./authService.js');
        
        // 갱신 Promise 저장 (다른 요청들도 이걸 기다림)
        refreshPromise = AuthService.refresh();
        await refreshPromise;
      } else {
        // 이미 갱신 중이면 그 Promise를 기다림
        await refreshPromise;
        originalRequest._retry = true;
      }

      // 갱신 완료 후 원래 요청 재시도
      return apiClient(originalRequest);
    } catch (refreshErr) {
      clear();
      return Promise.reject(refreshErr);
    } finally {
      isRefreshing = false;
    }
  }
);
```

**왜 이렇게 설계했나?**

1. **동시 요청 처리**: 여러 API가 동시에 401을 받아도 refresh는 한 번만 실행
2. **무한 루프 방지**: `_retry` 플래그로 재시도는 1회만 허용
3. **순환 의존성 해결**: 동적 import로 authService와의 순환 참조 방지
4. **skipAuthRefresh**: refresh 요청 자체는 Interceptor를 타지 않도록 제외

---

## 3️⃣ 무한 스크롤 구현

### Intersection Observer 활용
React에서 Intersection Observer API를 사용하여 무한 스크롤을 구현했습니다. 한 번에 13개씩 데이터를 불러옵니다.

```javascript
const observerTarget = useRef(null);

useEffect(() => {
  if (!isOpen || !hasMore || isLoading || isLoadingMore) return;

  const observer = new IntersectionObserver(
    (entries) => {
      if (entries[0].isIntersecting && hasMore && !isLoadingMore) {
        fetchRoomList(currentPage + 1, false);
      }
    },
    { threshold: 0.1 } // 10%만 보여도 감지
  );

  const currentTarget = observerTarget.current;

  if (currentTarget) {
    observer.observe(currentTarget);
  }

  return () => {
    if (currentTarget) {
      observer.unobserve(currentTarget);
    }
  };
}, [isOpen, hasMore, isLoading, isLoadingMore, currentPage, fetchRoomList]);
```

### 데이터 로딩 로직

```javascript
const fetchRoomList = useCallback(async (page = 0, isInitial = false) => {
  // 초기 로딩과 추가 로딩 구분
  if (isInitial) {
    setIsLoading(true);
  } else {
    setIsLoadingMore(true);
  }
  setError(null);

  try {
    const data = await RoomService.getRoomList(page, 13);
    
    // 최소 1초 동안 스켈레톤 유지 (UX 개선)
    await new Promise((resolve) => setTimeout(resolve, 1000));
    
    // 초기 로딩: 교체, 추가 로딩: 기존 목록 뒤에 추가
    if (isInitial) {
      setWaitingRooms(data.roomList);
    } else {
      setWaitingRooms(prev => [...prev, ...data.roomList]);
    }
    
    setHasMore(data.hasNext);
    setCurrentPage(page);
  } catch (err) {
    console.error('방 목록 조회 실패:', err);
    setError('방 목록을 불러오는데 실패했습니다.');
    
    // 401 에러 시 로그인 페이지로 이동
    if (err.response?.status === 401) {
      showAlert('로그인 필요', '로그인이 필요합니다.', 'warning');
      setTimeout(() => navigate('/'), 2000);
    }
  } finally {
    setIsLoading(false);
    setIsLoadingMore(false);
  }
}, [navigate]);
```

**무한 스크롤 동작 원리**

1. 방 목록 끝에 보이지 않는 div 배치 (`observerTarget`)
2. 사용자가 스크롤하면 이 div가 화면에 나타남
3. Intersection Observer가 감지 → 다음 페이지 자동 로드
4. 새로운 방들이 기존 목록 뒤에 추가
5. 반복...

**threshold: 0.1의 의미**
- 요소의 10%만 보여도 감지
- 사용자가 끝까지 스크롤하기 전에 미리 로딩 시작
- 체감 로딩 시간 단축

---

## 4️⃣ WebSocket 세션 체크 및 입장 로직

### 방 클릭 시 3단계 검증

```javascript
const handleRoomClick = async (roomId) => {
  const room = waitingRooms.find(r => r.gameRoomId === roomId);

  // ========== 1단계: 방 인원 체크 ==========
  if (room && room.currentParticipants >= room.maxParticipants) {
    showAlert('입장 불가', '방이 가득 찼습니다.', 'warning');
    return;
  }

  // ========== 2단계: 방 상태 체크 ==========
  if (room && room.status === 'IN_PROGRESS') {
    showAlert('입장 불가', '이미 게임이 진행 중인 방입니다.', 'warning');
    return;
  }

  // ========== 3단계: WebSocket 세션 체크 ==========
  try {
    const sessionStatus = await RoomService.checkWsSession();
    
    if (sessionStatus.active) {
      showAlert(
        '입장 불가',
        '이미 다른 탭에서 게임에 참여 중입니다. 기존 탭을 종료해주세요.',
        'warning'
      );
      return;
    }

    // 모든 검증 통과 → 입장 허용
    navigate(`/quiz/waiting/${roomId}`);
    onClose();
  } catch (err) {
    console.error('세션 체크 실패:', err);
    showAlert('오류', '입장 확인 중 오류가 발생했습니다.', 'error');
  }
};
```

### 방 번호 입력 시 검증 로직

```javascript
const handleRoomSearchSubmit = async (roomNumber) => {
  // 입력 검증
  if (!roomNumber || isNaN(roomNumber)) {
    showAlert('입력 오류', '방 번호는 숫자만 입력할 수 있습니다.', 'warning');
    return;
  }

  try {
    // 1. WebSocket 세션 체크
    const sessionStatus = await RoomService.checkWsSession();
    if (sessionStatus.active) {
      showAlert('입장 불가', '이미 다른 탭에서 게임에 참여 중입니다.', 'warning');
      return;
    }

    // 2. 방 존재 여부 및 상태 확인
    const roomDetail = await RoomService.getRoomDetail(roomNumber);
    
    if (!roomDetail || !roomDetail.gameRoomId) {
      showAlert('방을 찾을 수 없습니다.', '존재하지 않는 방 번호입니다.', 'error');
      return;
    }

    if (roomDetail.status === 'IN_PROGRESS') {
      showAlert('입장 불가', '이미 게임이 진행 중인 방입니다.', 'warning');
      return;
    }
    
    if (roomDetail.status === 'FINISHED') {
      showAlert('입장 불가', '종료된 방은 입장할 수 없습니다.', 'warning');
      return;
    }

    // 모든 조건 통과 → 입장
    navigate(`/quiz/waiting/${roomNumber}`);
    onClose();
  } catch (err) {
    const errorCode = err.response?.data?.error;
    
    if (errorCode === 'ROOM_NOT_FOUND') {
      showAlert('입장 불가', '해당 방을 찾을 수 없습니다.', 'error');
    } else if (errorCode === 'UNAUTHORIZED') {
      showAlert('로그인 필요', '로그인이 필요합니다.', 'warning');
      setTimeout(() => navigate('/'), 2000);
    } else {
      showAlert('오류', '방 검증 중 오류가 발생했습니다.', 'error');
    }
  }
};
```

**왜 이렇게 복잡하게 검증하나?**

1. **클라이언트 사이드 검증 (1단계)**: 불필요한 API 호출 방지
2. **WebSocket 세션 체크 (2단계)**: 동시 다중 연결 방지
3. **서버 사이드 검증 (3단계)**: 최종 권한 확인

---

## 5️⃣ 방 생성 UX 최적화

### 2초 로딩 후 이동

```javascript
const handleCreateRoomSubmit = async (roomTitle) => {
  setCreateRoomLoading(true);
  setCreateRoomError(null);

  try {
    const result = await RoomService.createRoom(roomTitle);
    console.log('방 생성 성공:', result);

    // ✅ 2초 후 이동 (사용자에게 "생성 중" 피드백 제공)
    setTimeout(() => {
      setCreateRoomLoading(false);
      setIsCreateRoomModalOpen(false);
      navigate(`/quiz/waiting/${result.gameRoomId}`);
      onClose();
    }, 2000);

    return true; // 성공 (모달 유지)
  } catch (err) {
    // ❌ 에러 시 즉시 로딩 종료
    setCreateRoomLoading(false);

    const errorCode = err.response?.data?.error;
    const errorMessage = err.response?.data?.detail;

    switch (errorCode) {
      case 'VALIDATION_ERROR':
        setCreateRoomError(errorMessage || '방 제목을 확인해주세요.');
        break;
      case 'PARTICIPANT_ALREADY_IN_ROOM':
        setCreateRoomError('이미 다른 방에 참여 중입니다.');
        break;
      case 'UNAUTHORIZED':
        setCreateRoomError('로그인이 필요합니다.');
        setTimeout(() => navigate('/'), 2000);
        break;
      default:
        setCreateRoomError('방 생성에 실패했습니다. 다시 시도해주세요.');
    }
    return false; // 실패 (모달 유지, 에러 표시)
  }
};
```

**성공/실패 시 다른 UX**

| 상황 | 로딩 시간 | 모달 상태 | 사용자 피드백 |
|------|-----------|-----------|---------------|
| **성공** | 2초 유지 | "생성 중..." 표시 후 닫기 | 충분한 시각적 피드백 |
| **실패** | 즉시 종료 | 열린 채로 유지 | 에러 메시지 표시 |

### CreateRoomModal 컴포넌트

```javascript
const CreateRoomModal = ({ isOpen, onClose, onSubmit, loading, error }) => {
  const [roomTitle, setRoomTitle] = useState('');

  const handleSubmit = async () => {
    if (roomTitle.trim() && !loading) {
      const success = await onSubmit(roomTitle);
      
      // 성공한 경우에만 입력값 초기화
      if (success) {
        setRoomTitle('');
      }
      // 실패 시 모달 유지 + 에러 표시
    }
  };

  const handleInputChange = (e) => {
    const value = e.target.value;
    // 20자 제한
    if (value.length <= 20) {
      setRoomTitle(value);
    }
  };

  return (
    <div className={styles.createRoomModal}>
      <input
        value={roomTitle}
        onChange={handleInputChange}
        onKeyPress={(e) => {
          if (e.key === 'Enter' && roomTitle.trim() && !loading) {
            handleSubmit();
          }
        }}
        disabled={loading}
        autoFocus
      />
      
      {/* 글자 수 표시 */}
      <span className={styles.charCount}>{roomTitle.length}/20</span>
      
      {/* 에러 메시지 */}
      {error && <div>{error}</div>}
      
      <button onClick={handleSubmit} disabled={!roomTitle.trim() || loading}>
        {loading ? '생성 중...' : '생성하기'}
      </button>
    </div>
  );
};
```

---

## 6️⃣ 스켈레톤 UI로 로딩 표시

### 초기 로딩 vs 추가 로딩

```javascript
{/* 초기 로딩: 5개의 스켈레톤 */}
{isLoading && (
  <div className={styles.skeletonWrapper}>
    {[...Array(5)].map((_, index) => (
      <div key={index} className={styles.skeletonCard}>
        <SkeletonLoader variant="rectangle" width={350} height={60} />
      </div>
    ))}
  </div>
)}

{/* 방 목록 */}
{!isLoading && !error && waitingRooms.length > 0 && (
  <>
    {waitingRooms.map((room) => (
      <RoomCard key={room.gameRoomId} room={room} onClick={handleRoomClick} />
    ))}

    {/* 추가 로딩: 2개의 스켈레톤 */}
    {isLoadingMore && (
      <div className={styles.skeletonWrapper}>
        {[...Array(2)].map((_, index) => (
          <div key={index} className={styles.skeletonCard}>
            <SkeletonLoader variant="rectangle" width={350} height={60} />
          </div>
        ))}
      </div>
    )}

    {/* Intersection Observer 타겟 */}
    {hasMore && !isLoadingMore && (
      <div ref={observerTarget} style={{ height: '20px' }} />
    )}
  </>
)}
```

**로딩 상태 구분의 중요성**
- `isLoading`: 전체 목록을 처음 불러올 때
- `isLoadingMore`: 스크롤로 추가 데이터를 불러올 때
- 둘을 분리해야 사용자가 혼란스럽지 않음

---

## 7️⃣ RoomCard 컴포넌트

### 방 상태 표시

```javascript
const RoomCard = ({ room, onClick }) => {
  const getStatusInfo = (status) => {
    switch(status) {
      case 'WAITING':
        return '대기 중';
      case 'IN_PROGRESS':
        return '진행 중';
      case 'FINISHED':
        return '종료';
      default:
        return '대기 중';
    }
  };

  return (
    <div className={styles.roomCard} onClick={() => onClick(room.gameRoomId)}>
      <span className={styles.roomNumber}>{room.gameRoomId}</span>
      <span className={`${styles.roomStatus} ${
        room.status === 'IN_PROGRESS' ? styles.inProgress : styles.waiting
      }`}>
        {getStatusInfo(room.status)}
      </span>
      <span className={styles.roomTitle}>{room.gameTitle}</span>
      <span className={styles.roomPlayers}>
        {room.currentParticipants}/{room.maxParticipants}
      </span>
    </div>
  );
};
```

---

## 🎯 최종 정리

### 오늘 배운 핵심 내용

**1. Axios Interceptor의 위력**
- 401 에러를 자동으로 감지하여 토큰 갱신
- 여러 API가 동시에 401을 받아도 refresh는 한 번만 실행
- `_retry` 플래그로 무한 루프 방지
- 동적 import로 순환 의존성 해결

**2. 무한 스크롤의 핵심**
- Intersection Observer로 특정 요소 감지
- `threshold: 0.1`로 미리 로딩 시작 (체감 속도 개선)
- `useCallback`으로 함수 메모이제이션 (불필요한 재생성 방지)
- cleanup 함수로 메모리 누수 방지

**3. 3단계 입장 검증의 중요성**
1. 클라이언트 검증: 불필요한 API 호출 차단
2. WebSocket 세션 체크: 동시 접속 방지
3. 서버 검증: 최종 권한 확인

**4. 사용자 경험을 고려한 로딩 처리**
- 성공 시: 2초 로딩으로 충분한 시각적 피드백
- 실패 시: 즉시 종료하고 에러 표시
- 스켈레톤 UI로 로딩 상태 명확히 전달
- 최소 1초 로딩 보장으로 깜빡임 방지

**5. 에러 핸들링은 UX의 일부**
- 에러 코드별 적절한 메시지 제공
- 사용자가 다음 액션을 명확히 알 수 있도록 안내
- 로그인 만료 시 자동 리다이렉트

### 개선 포인트

| 이전 | 개선 후 |
|------|---------|
| 수동 토큰 갱신 | Interceptor로 자동 처리 |
| 단순 페이지네이션 | 무한 스크롤로 UX 개선 |
| API 호출 전 검증 없음 | 3단계 검증으로 불필요한 호출 방지 |
| 즉시 이동 | 2초 로딩으로 피드백 제공 |

### 배운 점

1. **토큰 갱신의 복잡성**: 여러 요청이 동시에 401을 받을 수 있으므로, 하나의 Promise를 공유하는 방식이 필수
2. **순환 의존성 해결**: 동적 import(`await import()`)로 런타임에 모듈을 불러오면 해결 가능
3. **무한 스크롤 최적화**: threshold를 낮추면 미리 로딩 시작, 사용자는 "끊김 없는" 경험
4. **에러는 상태**: 실패 시 모달을 유지하고 에러를 표시하는 것이 더 나은 UX


