# 🗓️ 2025년 7월 17일 TIL


학생 점수 관리 프로그램 
Spring 실습


@JsonProperty를 사용하면 프론트에서 필드 이름을
다르게 달라고 했을 때 바꿔서 줄 수 있음
ex)
`@JsonProperty("sum")
private int total;`



마스킹 할 때 글자 수에 따라 다르게 적용
```java
private static String maskNickName(String originName) {
    
    // 이름이 1글자인 사람 처리
    if (originName.length() <= 1) {
        return originName;
    }
    
    // 이름이 2글자인 사람 처리
    if (originName.length() <= 2) {
        return originName.charAt(0) + "*";
    }

    // 나머지 경우
    // 첫글자
    char firstLetter = originName.charAt(0);
    // 마지막 글자
    char lastLetter = originName.charAt(originName.length() - 1);

    // 완성된 마스킹 네임
    String maskingName = String.valueOf(firstLetter);

    for (int i = 1; i < originName.length() - 1; i++) {
        maskingName += "*";
    }
    maskingName += lastLetter;

    return maskingName;
}

```
- 이름 1글자, 2글자, 3글자 이상 다르게 처리해줘야함을 알게됐음.


---


```javascript
// 성적 정보 등록 이벤트
document.getElementById('createBtn').addEventListener('click', e => {

  e.preventDefault(); // form의 submit시 발생하는 새로고침 방지

  const $form = document.getElementById('score-form');
  // formData객체 생성
  const formData = new FormData($form);
  const scoreObj = Object.fromEntries(formData.entries());
  console.log(scoreObj);

  // 서버로 POST요청 전송
  fetchPostScore(scoreObj);

});
```
formData 객체를 생성하여,
form 데이터를 한번에 가져오는 방법을 새롭게 배움

---


입력값 검증
```java
public class ScoreCreateRequest {
    // 공백문자, null 둘다 허용하지 않음
    @NotEmpty(message = "이름은 필수값입니다.")
    @Pattern(regexp = "^[가-힣]+$", message = "이름은 한글로만 작성하세요!")
    private String studentName;

    @Min(value = 0, message = "국어 점수는 0점 이상이어야합니다.")
    @Max(value = 100, message = "국어 점수는 100점 이하여야합니다.")
    @NotNull(message = "국어점수는 필수값입니다.")
    private Integer korean;
}
```
- @NotEmpty: 공백문자, null 둘다 허용하지 않음
- 점수를 Integer로 한 이유는 기본값이 null이기 때문이다.
- int로 했을 경우에는 기본값이 0이기 때문에 null 체크를 못함

---

JSP 문법 주의
JSP에서 ${id}를 쓸 때는 조심해야함.
${id}는 서버가 내려주는 id이고,
\${stuId}는 stuId라는 자바스크립트의 변수임.


---

페이지 라우팅 데이터 전달
서버가 페이지 라우팅을 할 때 데이터를 내려주는 방법
JSP에게 특정 데이터(id)를 클라이언트에게 전송
페이지 라우팅을 할 때 파라미터로 Model 타입을 사용할 수 있음
이를 이용해서 클라이언트에게 데이터를 전송해줄 수 있다.

```java
@GetMapping("/{id}")
public String detailPage(@PathVariable("id") Long id, Model model) {
    // JSP에게 특정 데이터(id)를 전송
    model.addAttribute("stuId", id);
    return "score/score-detail";
}
```
@PathVariable 경로 변수를 통해 얻은 id를
model에 stuId라는 특성에 넣어줌.
`model.addAttribute("stuId", id);`

---
여기서부터 2가지로 나눌 예정



스프링 프레임워크
- 자바 플랫폼에서 애플리케이션 개발을 간소화
- 개발자가 더 나은 품질의 코드를 작성할 수 있도록 돕는 강력한 프레임워크

스프링의 주요 원칙
POJO (Plain Old Java Object)
- "옛날식 자바 객체", 즉 아무런 특별한 규칙이나 프레임워크에 의존하지 않는 순수한 자바 객체

IoC (Inversion of Control, 제어의 역전)
- 객체의 생성 및 생명 주기 관리를 개발자가 아닌 프레임워크가 대신 처리
- IoC 컨테이너가 객체 간의 의존성을 관리하고, 이를 통해 코드의 결합도 낮춤

DI (Dependency Injection, 의존성 주입)
- 객체 간의 의존성을 외부에서 주입하는 방식

AOP (Aspect-Oriented Programming, 관점 지향 프로그래밍)
- 로깅, 보안, 트랜잭션 관리와 같은 공통 관심사를 핵심 비즈니스 로직과 분리하여 모듈화하는 프로그래밍 기법

스프링의 모듈 구조
- 스프링 프레임워크는 다양한 기능을 제공하기 위해 여러 모듈로 구성
- 모듈들은 독립적으로 사용될 수 있으며, 필요한 기능만 선택적 사용 가능




객체지향 설계원칙 SOLID

### 1. S: 단일 책임 원칙 (Single Responsibility Principle)
> "클래스는 단 하나의 책임만 가져야 한다."

🎯 핵심 개념

- 하나의 클래스는 하나의 기능, 하나의 역할만 전문적으로 수행해야 한다는 원칙

장점
1. 이해하기 쉬움: 클래스가 하는 일이 명확해서 코드를 파악하기 편함
2. 수정이 안전: 하나의 기능을 수정해도 다른 기능에 영향을 줄 확률이 크게 줄어들음
3. 재사용이 용이: 필요한 기능만 쏙쏙 가져다 쓰기 편함

---

### 2. O: 개방-폐쇄 원칙 (Open/Closed Principle)
> 소프트웨어 요소는 확장에 대해서는 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

🎯 핵심 개념
- 새로운 기능을 추가할 때, 기존 코드를 뜯어고치는 게 아니라,
- 새로운 코드를 추가하는 방식으로 만들어야 한다는 원칙

장점
1. 안정적: 잘 작동하는 기존 코드를 수정하지 않으니, 코드를 추가하며 기존 기능이 고장날 위험이 없음
2. 유연성: 새로운 요구사항에도 유연하게 대처 가능

예시: 호텔 클래스 생성자
```java
public class Hotel {
    // 레스토랑 입점
    private final Restaurant restaurant;
    // 헤드쉐프 고용
    private Chef headChef;
    // 생성자
    public Hotel() {
        this.restaurant = new WesternRestaurant();
        this.headChef = new StephaneChef();
    }
}
```
셰프는 전문 분야가 따로 정해져있으므로 셰프만 변경되어도 입점 레스토랑을 변경해야되고,
레스토랑 내부의 메인셰프를 전부 변경해야함
이는 OCP 위반이다. 

---

### 3. 3. L: 리스코프 치환 원칙 (Liskov Substitution Principle)
> 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.

### 🎯 핵심 개념
'자식 클래스는 부모 클래스의 역할을 완벽하게 해낼 수 있어야 한다'는 원칙이에요.
즉, 부모 클래스가 들어갈 자리에 자식 클래스를 대신 넣어도, 프로그램이 아무 문제 없이 똑같이 동작해야 합니다.

장점
1. 신뢰성이 높아짐: 클래스들 간의 관계가 예측 가능해져서 프로그램 전체의 안정성이 올라감.
2. 다형성 활용 가능: OCP에서 본 것처럼, 부모 타입(Shape) 하나로 다양한 자식 타입(Rectangle, Circle)을 믿고 다룰 수 있게 되죠.

---

### 4. I: 인터페이스 분리 원칙 (Interface Segregation Principle)
> 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.

#### 🎯 핵심 개념
하나의 거대하고 '뚱뚱한' 인터페이스보다는, 기능별로 잘게 쪼갠 '날씬한' 인터페이스 여러 개를 만드는 것이 더 좋다는 원칙

장점
1. 결합도가 낮아짐: 클래스가 자기에게 필요 없는 기능에 의존하지 않게 되어 시스템이 깔끔해짐
2. 수정이 쉬워짐: 인터페이스가 작고 명확하면, 수정이 필요할 때 영향을 받는 범위를 최소화할 수 있다.

---

### 5. D: 의존성 역전 원칙 (Dependency Inversion Principle)
> 고수준 모듈은 저수준 모듈에 의존해서는 안 된다. 둘 다 추상화에 의존해야 한다

#### 🎯 핵심 개념
세부적인 구현(저수준 모듈, 예: `삼성 키보드`, `LG 마우스`)에 직접 의존하지 말고,
공통적인 약속(추상화, 예: `USB 포트`)에 의존하라는 원칙

장점
1. 유연성과 확정성 극대화: 부품(클래스)을 갈아 끼우기가 매우 쉬워짐
2. 테스트 용이: 실제 객체 대신 테스트용 가짜 객체(Mock Object)를 쉽게 연결해서 테스트할 수 있어요.

예시: 호텔 클래스의 헤드쉐프 필드
만약 쉐프 필드를 다음과 같이 정의한다면 `private JannChef headChef;`
다른 쉐프를 고용할 수 없음.
Chef 인터페이스를 따로 만들어서 적용하면 다른 쉐프를 고용하여 유연성을 극대화 시킬 수 있다.


---

SOLID 원칙 한눈에 보기
원칙	이름	핵심 아이디어
S	단일 책임 원칙	하나의 클래스는 하나의 책임만!
O	개방-폐쇄 원칙	확장은 환영, 기존 코드 수정은 금물!
L	리스코프 치환 원칙	자식은 부모의 역할을 완벽히 대체해야 해!
I	인터페이스 분리 원칙	뚱뚱한 인터페이스 말고, 날씬한 인터페이스 여러 개로!
D	의존성 역전 원칙	구체적인 구현 말고, 추상적인 약속에 의존하자!

---

IoC(제어의 역전, Inversion of Control) 컨테이너와 의존성 주입(DI)

IoC 개념
객체의 생성 및 관리를 개발자가 아닌 프레임워크(스프링)나 컨테이너가 담당하게 하는 프로그래밍 원칙

IoC 역할
- 객체 간의 결합도 낮추고, 객체의 생명주기를 프레임워크가 관리
- 코드를 더 유연하게 만들고, 유지보수를 쉽게 할 수 있음.
- **의존성 주입(DI, Dependency Injection)**이라는 기법을 통해 IoC를 구현

IoC 컨테이너의 종류: `BeanFactory`와 `ApplicationContext`
- 스프링 프레임워크는 IoC를 구현하기 위해 IoC 컨테이너를 제공
- 컨테이너는 스프링 애플리케이션에서 객체의 생성, 구성, 관리 및 제거를 담당

IoC 예시)
제어의 역전, 생성자에서 객체 생성의 제어권을 넘김.
```java
public Hotel(Restaurant restaurant, Chef chef) {
    this.restaurant = restaurant;
    this.headChef = chef;
}
```
---

의존성 주입(DI, Dependency Injection) 개념
- 의존성이란, 객체가 다른 객체를 필요로 하는 것을 의미
- 예) `Car` 객체가 `Engine` 객체를 필요로 한다면, `Car`는 `Engine`에 의존한다고 말할 수 있음.
- 의존성을 객체 내부에서 직접 생성하는 대신, 외부에서 주입해주는 방법

DI의 중요성
- 결합도 감소
- 테스트 용이성
- 유연성 증가
- 코드 재사용성 증가

DI의 종류
- 생성자 주입
- 세터 주입

DI 생성자 주입
- 객체의 생성자에서 필요한 의존성을 주입받는 방식
- 객체가 생성될 때 모든 의존성이 주입되므로, 객체가 완전히 초기화된 상태로 사용가능

장점
1. 객체가 불완전한 상태로 생성되는 것을 방지
2. 의존성을 주입받지 않으면 객체를 생성할 수 없으므로, 객체의 일관성을 보장


---

단위 테스트
테스트를 원하는 클래스에서 `Ctrl + Shift + T`를 이용하여 테스트 클래스 생성
@Test를 통해 테스트 메서드로 지정할 수 있다.
이를 통해 main 메서드를 만들어서 테스트하지 않아도 된다.
```java
class HotelTest {
    // 테스트 메서드
    @Test
    void hotel() {
        // 호텔에 예약
        HotelManager manager = new HotelManager();
        Hotel hotel = manager.hotel();
        hotel.reserve();
    }
}
```











