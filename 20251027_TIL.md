# 🗓️ 2025년 10월 27일 TIL

## 📌 오늘의 키워드
`DTO 필드 확장` `WebSocket 데이터 전달` `null 안전성` `DB 조회 최적화` `N+1 문제` `Nullish Coalescing` `데이터 동기화` `프론트-백 통신` `JOIN FETCH`

---

## 문제 상황

퀴즈 대기방에서 모든 참가자의 점수가 하드코딩된 `0`으로 표시되는 문제가 있었다.

```javascript
// useWaitingRoom.js - 기존 코드
const formattedParticipants = participantsList.map(p => ({
  // ... 다른 필드들
  score: 0,  // ❌ 모든 참가자가 0점으로 고정
  isMe: p.userId === myUserId,
}));
```

게임을 완료해서 점수를 획득한 사용자가 다시 대기방에 입장해도 여전히 0점으로 표시되어,
사용자 경험과 데이터 정합성 측면에서 개선이 필요했다.

---

## DTO (Data Transfer Object)란?

### 개념

**DTO**는 계층 간 데이터 전달을 위한 객체다. 주로 백엔드와 프론트엔드 사이에서 데이터를 주고받을 때 사용된다.

```
Database Layer → Entity (User, GameParticipant)
       ↓
Service Layer → Business Logic
       ↓
Presentation Layer → DTO (ParticipantResponse) → JSON → Frontend
```

### Entity vs DTO

```java
// Entity: DB 테이블과 1:1 매핑
@Entity
public class User {
    @Id
    private Long id;
    private String nickname;
    private String password;  // 민감 정보
    private Long totalScore;
    // ... 30개 이상의 필드
}

// DTO: 필요한 데이터만 선택적으로 전달
@Getter
@Builder
public class ParticipantResponse {
    private Long userId;
    private String nickname;
    private String profileImageUrl;
    private boolean isHost;
    private boolean isReady;
    private Long totalScore;  // 👈 필요한 필드만!
}
```

### DTO를 사용하는 이유

**1. 보안**: 민감한 정보 노출 방지
```java
// Entity를 직접 반환하면 password도 함께 전달됨 (위험!)
return user;  // ❌

// DTO는 필요한 필드만 선택
return ParticipantResponse.from(user);  // ✅
```

**2. 효율성**: 불필요한 데이터 전송 최소화
```java
// Entity: 30개 필드 모두 전송 (100KB)
// DTO: 6개 필드만 전송 (10KB)
```

**3. 유연성**: 프론트엔드 요구사항에 맞춤
```java
// 프론트: isHost (boolean)
// Entity: host (Boolean)
// DTO에서 변환 가능!
```

**4. 변경 격리**: Entity 변경이 API 스펙에 영향 없음
```java
// User 엔티티에 새 필드 추가해도
// DTO는 기존 필드만 반환하므로 API 스펙 유지
```

---

## null 안전성 처리

### Java의 null 체크

```java
// 방법 1: 삼항 연산자
.totalScore(participant.getParticipant().getTotalScore() != null 
    ? participant.getParticipant().getTotalScore() 
    : 0L)

// 방법 2: Optional (더 함수형)
.totalScore(Optional.ofNullable(participant.getParticipant().getTotalScore())
    .orElse(0L))

// 방법 3: Objects.requireNonNullElse (Java 9+)
.totalScore(Objects.requireNonNullElse(
    participant.getParticipant().getTotalScore(), 0L))
```

### JavaScript의 null 체크

```javascript
// 방법 1: OR 연산자 (과거)
score: p.totalScore || 0  // ⚠️ 0이 falsy이므로 문제 발생 가능

// 방법 2: 삼항 연산자
score: p.totalScore !== null && p.totalScore !== undefined 
    ? p.totalScore 
    : 0  // 너무 장황함

// 방법 3: Nullish Coalescing (권장)
score: p.totalScore ?? 0  // ✅ null 또는 undefined만 체크
```

### Nullish Coalescing의 장점

```javascript
// 예시 데이터
const data = { score: 0, name: null, age: undefined };

// OR 연산자: falsy 값 모두 체크
console.log(data.score || 100);     // 100 (❌ 0이 무시됨)
console.log(data.name || "Guest");  // "Guest" (✅)

// Nullish Coalescing: null/undefined만 체크
console.log(data.score ?? 100);     // 0 (✅ 0이 유효한 값)
console.log(data.name ?? "Guest");  // "Guest" (✅)
console.log(data.age ?? 20);        // 20 (✅)
```

**사용 시나리오**:
- 점수가 0점일 수도 있는 경우 → `??` 사용
- Boolean 값의 기본값 설정 → `??` 사용
- 문자열 빈 값도 체크 필요 → `||` 사용

---

## N+1 쿼리 문제와 JOIN FETCH

### N+1 문제란?

```java
// 잘못된 코드
List<GameParticipant> participants = 
    participantRepository.findByGameRoom_Id(roomId);

// SQL 실행 결과:
// 1번: SELECT * FROM game_participant WHERE game_room_id = ?
// 
// 4명의 참가자가 있다면:
// 2번: SELECT * FROM user WHERE id = 1  (1번 참가자 User 조회)
// 3번: SELECT * FROM user WHERE id = 2  (2번 참가자 User 조회)
// 4번: SELECT * FROM user WHERE id = 3  (3번 참가자 User 조회)
// 5번: SELECT * FROM user WHERE id = 4  (4번 참가자 User 조회)
// 
// 총 5번의 쿼리 실행! (1 + N)
```

**왜 문제인가?**
- 참가자가 100명이면 101번의 쿼리 실행
- DB 왕복 시간이 누적되어 성능 저하
- 서버 리소스 낭비

### JOIN FETCH 해결책

```java
// 개선된 코드
@Query("SELECT gp FROM GameParticipant gp " +
       "JOIN FETCH gp.participant " +  // ✅ User를 함께 조회
       "WHERE gp.gameRoom.id = :roomId")
List<GameParticipant> findByGameRoom_Id(@Param("roomId") Long roomId);

// SQL 실행 결과:
// SELECT gp.*, u.* 
// FROM game_participant gp 
// INNER JOIN user u ON gp.participant_id = u.id 
// WHERE gp.game_room_id = ?
// 
// 단 1번의 쿼리로 모든 데이터 조회!
```

### JPA의 기본 동작 (Lazy Loading)

```java
@Entity
public class GameParticipant {
    @ManyToOne(fetch = FetchType.LAZY)  // 기본값
    private User participant;
}

// Lazy Loading: 실제 사용 시점에 조회
GameParticipant gp = repository.findById(1L);
// SQL 실행: SELECT * FROM game_participant WHERE id = 1

String name = gp.getParticipant().getNickname();
// 이 시점에 SQL 실행: SELECT * FROM user WHERE id = ?
```

**장점**: 불필요한 데이터 조회 방지  
**단점**: 여러 엔티티를 반복 조회하면 N+1 문제 발생

### JOIN FETCH의 작동 원리

```java
// JOIN FETCH는 한 번의 JOIN 쿼리로 모든 데이터를 가져옴
List<GameParticipant> participants = 
    repository.findByGameRoom_Id(roomId);

// 이미 User 정보가 메모리에 로드되어 있음
for (GameParticipant gp : participants) {
    gp.getParticipant().getNickname();  // 추가 쿼리 없음!
}
```

---

## WebSocket 데이터 전달 구조

### WebSocket 통신 흐름

```
Client                          Server
  |                               |
  |------ JOIN_ROOM 메시지 ------>|
  |                               |
  |                         DB에서 참가자 조회
  |                         ParticipantResponse 생성
  |                               |
  |<----- ROOM_JOIN 응답 ---------|
  |  (participants: [...])        |
  |                               |
```

### 메시지 구조

```json
// 클라이언트 → 서버
{
  "type": "JOIN_ROOM",
  "data": {
    "roomId": 123,
    "userId": 1
  }
}

// 서버 → 클라이언트
{
  "success": true,
  "data": {
    "gameRoomId": 123,
    "participants": [
      {
        "userId": 1,
        "nickname": "사용자1",
        "profileImageUrl": "https://...",
        "host": true,
        "ready": false,
        "totalScore": 1500  // 👈 추가된 필드
      },
      {
        "userId": 2,
        "nickname": "사용자2",
        "totalScore": 2300
      }
    ]
  }
}
```

### 데이터 변환 과정

```
Database                           Backend                         Frontend
   ↓                                  ↓                              ↓
User Entity                    ParticipantResponse              participant 객체
{                              {                                {
  id: 1,                         userId: 1,                       id: 1,
  nickname: "김코즈",             nickname: "김코즈",               nickname: "김코즈",
  totalScore: 1500,              totalScore: 1500,                score: 1500,
  password: "...",  ← 제외        isHost: true,                   isMe: true,
  email: "...",     ← 제외        isReady: false                  isHost: true
  ...30개 필드                   }                                }
}                              
                               Jackson이 JSON으로 변환
                                        ↓
                               WebSocket으로 전송
                                        ↓
                               프론트엔드가 JSON 파싱
                                        ↓
                               participant.score에 매핑
```

---

## 해결 과정

### 1단계: 백엔드 DTO 수정

```java
// ParticipantResponse.java
@Getter
@Builder
public class ParticipantResponse {
    private Long userId;
    private String nickname;
    private String profileImageUrl;
    private boolean isHost;
    private boolean isReady;
    private Long totalScore;  // 👈 새로 추가

    public static ParticipantResponse from(GameParticipant participant) {
        return ParticipantResponse.builder()
                .userId(participant.getParticipant().getId())
                .nickname(participant.getParticipant().getNickname())
                .profileImageUrl(participant.getParticipant().getProfileImageUrl())
                .isHost(participant.isHost())
                .isReady(participant.isReady())
                .totalScore(participant.getParticipant().getTotalScore() != null 
                    ? participant.getParticipant().getTotalScore() 
                    : 0L)  // 👈 null 체크
                .build();
    }
}
```

**핵심 포인트**:
- Entity에서 DTO로 변환하는 `from()` 정적 팩토리 메서드 사용
- null 체크를 통해 안전성 보장
- 기존 서비스 로직 변경 불필요 (DTO만 수정하면 자동 반영)

### 2단계: 프론트엔드 데이터 매핑

```javascript
// useWaitingRoom.js
const setInitialParticipants = useCallback((participantsList, myUserId, isWebcamOn) => {
  const formattedParticipants = participantsList.map(p => ({
    id: p.userId,
    userId: p.userId,
    nickname: p.nickname,
    profileImageUrl: p.profileImageUrl,
    score: p.totalScore ?? 0,  // 👈 백엔드에서 받은 totalScore 사용
    isMe: p.userId === myUserId,
    isHost: p.host,
    isReady: p.ready,
    webcamStatus: p.userId === myUserId ? (isWebcamOn ? 'on' : 'off') : 'off'
  }));
  setParticipants(formattedParticipants);
}, []);
```

**핵심 포인트**:
- `totalScore ?? 0`: Nullish Coalescing으로 안전하게 기본값 설정
- 불필요한 파라미터 제거 (기존에 전달하던 `myTotalScore` 제거)
- 백엔드에서 이미 모든 참가자의 점수를 전달하므로 클라이언트 로직 단순화

### 3단계: 컴포넌트 코드 정리

```javascript
// QuizWaitingRoom.jsx - 변경 전
setInitialParticipants(roomData.participants, myUserId, isWebcamOn, user?.totalScore);
addParticipant(newUser, myUserId, isWebcamOn, user?.totalScore);

// QuizWaitingRoom.jsx - 변경 후
setInitialParticipants(roomData.participants, myUserId, isWebcamOn);
addParticipant(newUser, myUserId, isWebcamOn);
```

**핵심 포인트**:
- 불필요한 파라미터 전달 제거
- 함수 시그니처 단순화
- 더 이상 로컬 상태에서 점수 관리 불필요

---

## 데이터 동기화 시나리오

### 시나리오 1: 게임 완료 후 대기방 복귀

```
[T1] 사용자가 퀴즈 게임 완료
  ↓
[T2] QuizService.endGame() 호출
  └─ user.updateTotalScore(roundScore)
  └─ DB에 점수 저장 (Dirty Checking)
  ↓
[T3] 사용자가 "방으로 돌아가기" 버튼 클릭
  ↓
[T4] QuizService.returnToWaitingRoom() 호출
  └─ 방 상태를 WAITING으로 변경
  ↓
[T5] 프론트엔드에서 대기방 재입장
  └─ WebSocket JOIN_ROOM 메시지 전송
  ↓
[T6] GameRoomJoinService.joinRoom() 호출
  └─ DB에서 참가자 목록 조회 (최신 totalScore 포함)
  └─ ParticipantResponse.from()에서 totalScore 매핑
  ↓
[T7] 프론트엔드에서 업데이트된 점수 표시
```

**핵심**: 게임 종료 시 이미 DB에 점수가 업데이트되어 있으므로, 대기방 재입장 시 자동으로 최신 점수가 조회됨

### 시나리오 2: 새 참가자 입장

```
[T1] 새 사용자가 대기방 입장
  ↓
[T2] JOIN_ROOM 메시지 전송
  ↓
[T3] 백엔드에서 User.totalScore 조회
  ↓
[T4] ParticipantResponse 생성 (totalScore 포함)
  ↓
[T5] PARTICIPANT_JOINED 이벤트 발행
  ↓
[T6] 기존 참가자들에게 브로드캐스트
  ↓
[T7] 모든 참가자 화면에 새 참가자의 점수 표시
```

**핵심**: WebSocket 이벤트에도 동일한 DTO를 사용하므로, 새 참가자의 점수도 자동으로 전달됨

---

## 성능 최적화 검증

### 이미 적용된 최적화

```java
// GameParticipantRepository.java
@Query("SELECT gp FROM GameParticipant gp " +
       "JOIN FETCH gp.participant " +  // ✅ N+1 문제 해결
       "WHERE gp.gameRoom.id = :roomId")
List<GameParticipant> findByGameRoom_Id(@Param("roomId") Long roomId);
```

### 쿼리 실행 검증

```sql
-- 단 1번의 쿼리로 모든 정보 조회
SELECT 
    gp.id, gp.is_host, gp.is_ready,
    u.id, u.nickname, u.profile_image_url, u.total_score
FROM game_participant gp
INNER JOIN user u ON gp.participant_id = u.id
WHERE gp.game_room_id = ?
```

### 추가 비용 분석

**데이터 크기 증가**:
- totalScore 필드 추가: 8 bytes (Long)
- 최대 4명 참가자: 32 bytes 증가
- 전체 메시지 크기: ~500 bytes → ~532 bytes
- 영향: 무시할 수 있는 수준

**쿼리 성능**:
- SELECT에 필드 1개 추가 (u.total_score)
- User 엔티티는 이미 JOIN FETCH로 조회 중
- 추가 쿼리 없음
- 영향: 없음

---

## 학습 포인트

### 1. DTO의 중요성

DTO는 단순히 데이터를 옮기는 객체가 아니라:
- **보안**: 민감한 정보 노출 방지
- **효율**: 필요한 데이터만 전송
- **유연성**: 프론트엔드 요구사항에 맞춤
- **격리**: Entity 변경이 API에 영향 없음

### 2. null 안전성의 중요성

프로그래밍에서 null은 "10억 달러의 실수"라고 불린다:
- Java: 삼항 연산자, Optional, Objects 유틸 사용
- JavaScript: Nullish Coalescing (`??`) 활용
- 항상 null 가능성을 염두에 두고 방어 코드 작성

### 3. N+1 문제의 이해

ORM을 사용할 때 발생하는 대표적인 성능 문제:
- Lazy Loading의 부작용
- JOIN FETCH로 해결
- 쿼리 로그를 통해 실제 실행 쿼리 확인 필수

### 4. 데이터 동기화 전략

실시간 통신에서 데이터 동기화는:
- DB를 Single Source of Truth로 사용
- 필요할 때마다 최신 데이터 조회
- 캐싱은 신중하게 적용

### 5. 최소 변경의 원칙

좋은 코드 변경은:
- 영향 범위를 최소화
- 기존 로직을 최대한 재활용
- 테스트하기 쉬운 구조 유지

---

## 디버깅 팁

### 1. WebSocket 메시지 확인

```javascript
// 브라우저 개발자 도구 → Network 탭 → WS (WebSocket)
// 메시지 내용 확인:
{
  "participants": [
    {
      "totalScore": 1500  // 👈 필드가 있는지 확인
    }
  ]
}
```

### 2. 백엔드 로그 확인

```java
log.info("ParticipantResponse: {}", response);
// 출력: ParticipantResponse(userId=1, nickname=김코즈, totalScore=1500)
```

### 3. SQL 쿼리 로그 확인

```yaml
# application.yml
spring:
  jpa:
    show-sql: true
    properties:
      hibernate:
        format_sql: true
```

### 4. 프론트엔드 상태 확인

```javascript
console.log('참가자 목록:', participants);
// [{id: 1, nickname: "김코즈", score: 1500, ...}]
```

---

## 최종 정리

오늘은 퀴즈 대기방에서 참가자 점수를 DB와 동기화하여 표시하는 기능을 구현했다.

핵심은 **백엔드 DTO에 totalScore 필드를 추가**하고, **프론트엔드에서 이를 받아 UI에 표시**하는 것이었다. 단순해 보이지만, 이 과정에서 여러 중요한 개념을 배울 수 있었다.

**DTO의 역할**을 제대로 이해하게 되었다. DTO는 단순한 데이터 전달 객체가 아니라, 보안, 효율성, 유연성을 모두 고려한 설계 요소다. Entity를 직접 노출하지 않고 DTO로 변환하는 이유를 이제 명확히 알게 되었다.

**null 안전성 처리**의 중요성도 깨달았다. Java의 삼항 연산자와 JavaScript의 Nullish Coalescing을 적절히 사용하여 안전한 코드를 작성할 수 있었다. 특히 `??` 연산자가 `||` 연산자와 다르게 동작하는 이유를 이해하면서, 언어마다 미묘한 차이가 있음을 배웠다.

**N+1 쿼리 문제**는 이론으로만 알고 있었는데, 실제 코드에서 이미 JOIN FETCH로 해결되어 있는 것을 확인하며 그 중요성을 체감했다. 4명의 참가자가 있을 때 5번의 쿼리가 아닌 1번의 쿼리로 모든 데이터를 조회할 수 있다는 것은 엄청난 성능 차이다.

**최소 변경의 원칙**도 중요한 교훈이었다. DTO 하나만 수정했을 뿐인데, 서비스 로직 변경 없이 모든 기능이 자동으로 작동했다. 이는 기존 코드가 잘 설계되어 있었기 때문이며, 앞으로도 확장 가능한 구조를 만드는 것이 얼마나 중요한지 알게 되었다.

앞으로는 API를 설계할 때 "이 필드가 나중에 추가될 수 있을까?"를 항상 고민하고, DTO를 통한 데이터 전달의 장점을 최대한 활용해야겠다.

**"좋은 코드는 변경하기 쉬운 코드다. 그리고 변경하기 쉬운 코드는 영향 범위가 명확한 코드다."**

