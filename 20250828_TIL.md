# 🗓️ 2025년 8월 28일 TIL


실습문제 2. TodoList 수정, 추가사항 
기존
```jsx
isClicked === false ? '' :
<form className={insertForm}>
</form>
```

수정
```jsx
isClicked &&
<div className={wrapper}>
</div>
```

기존
className={`${insertBtn} ${isClicked === false ? '' : openStyle}`}

수정
className={`${insertBtn} ${isClicked ? openStyle : ''}`}


할 일 체크 함수 find로 하는 방법 새로 배움
```jsx
const onCheck = (targetId) => {
  const copyTodos = [...todos];
  const targetTodo = copyTodos.find(todo => todo.id === id);

  targetTodo.done = !targetTodo.done;

  setTodos(copyTodos);
}
```

---

리액트 프래그먼트
<>
</>

---


에러가 떴을때 모달 띄우기
-> 에러 메시지 자체를 상태 변수로 관리하면
트루디 펄시를 이용해서 모달을 관리할 수 있음
```jsx
// 에러가 났을 때 에러데이터를 관리할 상태변수
// error -> { title: 에러제목, message: 에러원인 }
const [error, setError] = useState(null);
```

```jsx
{ error && <ErrorModal title={error.title} message={error.message}/>}
```

입력값 검증에서 setError -> error이 트루디가 됨 -> 모달 띄워짐

에러 모달 닫기
- ErrorModal 컴포넌트에 에러메세지를 null로 만드는 함수를 내려줌
- 닫기 버튼이나 backdrop을 클릭하면 내려받은 함수가 실행되게 함.

```jsx
<ErrorModal title={error.title} message={error.message} onClose={() => setError(null)}/>
```

---


리액트 포탈 portal


---

React useRef
- useRef로 태그 기억시키기
```jsx
const usernameRef = useRef(null);
```

usernameRef안에 input 태그가 저장됨
```jsx
<input
  id='username'
  type='text'
  ref={usernameRef}
/>
```

입력하면 실시간으로 상태관리 하던 것은 안 해도 됨

input 태그 꺼내기, 값 사용법
```jsx
const $usernameInput = usernameRef.current;
const $ageInput = ageRef.current;

// 객체로 매핑
const userValue = {
  username: $usernameInput.value,
  age: $ageInput.value,
};

// ... 입력값 검증, 부모가 준 함수 실행

// 입력값 초기화
$usernameInput.value = '';
$ageInput.value = '';

// 이름 입력란에 커서 포커스
$usernameInput.focus();
```

---

Side Effect
- 함수 외부의 상태를 변경
- 함수 실행 동작이 함수 외부의 상태에 의존하는 경우

React 컴포넌트에서의 Side Effect
- 데이터를 가져오거나, 구독하거나, 수동으로 변경하는 등의 I/O 작업
- DOM을 직접적으로 조작하는 작업
- setTimeout, setInterval 같은 타이머를 설정하는 작업

로그인 Side Effect 흐름
- 리액트는 새로고침하면 모든 상태 변수들이 기본값으로 돌아감
- 로그인을 성공하면 로컬 스토리지에 토큰을 저장하도록 구현
- 새로고침을 했을 때 토큰을 읽어서 로그인 상태변수를 변경시킴
- 상태변수를 변경했으므로 리렌더링이 일어남.
- 다시 상태변수 변경 -> 리렌더링 ... 무한 루프 발생

토큰 검사, 상태변수 변경 코드
```jsx
// 토큰 검사
console.log('토큰 검사!');
const token = localStorage.getItem('token');
if (token === '1') {
  setIsLoggedIn(true); // 리 렌더링 발생
}
```

---

## useEffect Hook
- 함수 컴포넌트에서는 `useEffect`를 사용
- side effect (서버에서 데이터를 가져오거나 외부 비동기작업) 처리를 위한 훅 (리액트 함수)
- 초기 렌더링 이후에 useEffect가 수행됨

### useEffect 함수의 기본 형태
```jsx
useEffect(() => {
  // side effect를 수행하는 코드를 여기에 작성합니다.

  return () => {
    // cleanup 코드를 여기에 작성합니다.
    // 이 코드는 컴포넌트가 unmount되거나, 다음 effect가 실행되기 전에 수행됩니다.
  };
}, [dependency1, dependency2]); // 의존성 배열
```

## 로그인 Side Effect 해결
```jsx
useEffect(() => {
  console.log('useEffect가 실행됨!');
  const token = localStorage.getItem('token');
  if (token === '1') {
    setIsLoggedIn(true); // 리 렌더링 발생
  }
}, []);
```

---

## useEffect 의존성 배열

useEffect의 두번째 파라미터 배열은 의존성 배열이라고 부르며
1. 생략할 경우 useEffect는 렌더링시마다 반복 실행됨 (쓰레기)
2. 빈 배열일 경우 최초 한번만 실행됨 (토큰검사 최초1번, 서버데이터 페칭 최초1번)
3. 배열안에 변수를 넣을 경우, 해당 변수값이 변경될 떄마다 재실행

### 로그인 버튼 활성화 여부 검증을 위한 useEffect
```jsx
useEffect(() => {
  setFormIsValid(
    enteredEmail.includes('@') && enteredPassword.trim().length > 6
  );
}, [enteredEmail, enteredPassword]);
```
- enteredEmail, enteredPassword가 변경될 때마다 useEffect 재실행
- 내부에서 로그인 버튼 활성화 여부를 검증

---

## useEffect cleanup 함수
- useEffect가 실행 되고 다음 번 useEffect 실행 직전에 실행되는 정리함수

### 로그인 버튼 검증 cleanup 함수 적용
```jsx
useEffect(() => {
  const timerId = setTimeout(() => {
    setFormIsValid(
      enteredEmail.includes('@') && enteredPassword.trim().length > 6
    );
  }, 1000);

  // cleanup 함수
  return () => {
    clearTimeout(timerId);
  };
}, [enteredEmail, enteredPassword]);
```
- cleanup 함수를 통해 디바운스 구현
- enteredEmail 혹은 enteredPassword가 변경
  -> 1초 뒤 로그인 버튼 활성화 검증
- 1초가 되기 전에 다시 입력하면 cleanup 함수 실행됨
  -> 기존 타이머 취소, 타이머 재가동



