# 🗓️ 2025년 8월 28일 TIL

## 🔑 오늘의 키워드

* `&&` 연산자
* `Array.prototype.find()`
* 리액트 프래그먼트
* 에러 모달
* `useRef`
* Side Effect & `useEffect`

---

## TodoList 리팩토링 및 새로운 함수 학습
---

### 1\. 조건부 렌더링(Conditional Rendering) 리팩토링

* 기존에는 삼항 연산자를 사용하여 `isClicked`가 `false`일 때 빈 문자열('')을 반환 
* **`&&` 연산자**를 사용하는 것이 더 간결하고 효율적

- **기존 코드**

```jsx
isClicked === false ? '' :
<form className={insertForm}>
</form>
```

- **수정 코드**

```jsx
isClicked &&
<div className={wrapper}>
</div>
```

---

### 2\. 클래스네임(className) 리팩토링

* CSS 클래스를 조건부로 적용할 때 삼항 연산자를 활용

- **기존 코드**

```jsx
className={`${insertBtn} ${isClicked === false ? '' : openStyle}`}
```

- **수정 코드**

```jsx
className={`${insertBtn} ${isClicked ? openStyle : ''}`}
```

---

### 3\. 배열 요소 찾기: `Array.prototype.find()`

* 상태를 토글(toggle)** 하는 함수
* `map`을 사용하는 대신 `find` 메서드를 사용
* 원하는 항목을 직접 찾아 수정
* 불필요한 전체 배열 순회를 줄임

**`find()`** 는 주어진 조건을 만족하는 배열의 **첫 번째 요소**를 반환

```jsx
const onCheck = (targetId) => {
  // 얕은 복사를 통해 불변성 유지
  const copyTodos = [...todos];

  // targetId와 일치하는 todo 객체를 찾음
  const targetTodo = copyTodos.find(todo => todo.id === targetId);

  // 찾은 객체의 done 상태를 반전
  if (targetTodo) {
    targetTodo.done = !targetTodo.done;
  }

  // 수정된 배열로 상태 업데이트
  setTodos(copyTodos);
}
```

**✅ Tip:** `find()`는 찾은 객체에 대한 참조(reference)를 반환하므로
**해당 객체를 직접 수정** 가능

---


## 리액트 프래그먼트(React Fragment)
---

### 1\. 프래그먼트란?

- **DOM에 별도의 노드를 추가하지 않고** JSX 요소를 묶어주는 기능
- 컴포넌트는 항상 하나의 루트(Root) 요소를 반환
- 이때 불필요한 `<div>` 같은 래퍼(Wrapper)를 생성하는 것을 막아줌

---

### 2\. 사용 방법

#### 1\) 명시적 구문 (React.Fragment)

* `React.Fragment`를 명시적으로 사용

```jsx
import React from 'react';

function MyComponent() {
  return (
    <React.Fragment>
      <h1>제목</h1>
      <p>내용</p>
    </React.Fragment>
  );
}
```

#### 2\) 단축 구문 (\<\>)

* `<>`와 `</>`를 사용해 간결하게 표현

```jsx
function MyComponent() {
  return (
    <>
      <h1>제목</h1>
      <p>내용</p>
    </>
  );
}
```

---


## 에러 모달(Error Modal) 관리하기
---
### 1\. 에러 상태로 모달 렌더링

에러 메시지 자체를 상태 변수로 관리

**`null`은 falsy 값**
에러가 없으면 모달이 안 보임
에러 객체가 담기면 모달이 렌더링됨

```jsx
// 에러가 났을 때 에러데이터를 관리할 상태변수
// error -> { title: 에러제목, message: 에러원인 }
const [error, setError] = useState(null);

// 에러 발생 시 상태 업데이트
setError({
  title: '유효성 검사 실패',
  message: '모든 입력란을 채워주세요.',
});
```

`error` 상태가 `null`이 아니면 모달 렌더링.

```jsx
{ error && <ErrorModal title={error.title} message={error.message}/> }
```

### 2\. 모달 닫기 기능 구현

모달을 닫으려면 `error` 상태를 다시 `null`로 변경.

부모 컴포넌트에서 상태를 `null`로 만드는 함수를 `ErrorModal`에 props로 전달.

- **부모 컴포넌트**

```jsx
<ErrorModal
  title={error.title}
  message={error.message}
  onClose={() => setError(null)}
/>
```

- **자식 컴포넌트 (ErrorModal)**

`onClose` prop을 받아서, 닫기 버튼이나 배경 클릭 시 실행.

```jsx
// ErrorModal.jsx
const ErrorModal = (props) => {
  return (
    <div>
      <div>{props.title}</div>
      <div>{props.message}</div>
      <button onClick={props.onClose}>닫기</button>
    </div>
  );
};
```

---


## React `useRef` 훅
---
### 1\. `useRef`란?

`useRef`는 특정 DOM 노드에 직접 접근하거나, 컴포넌트 생애주기 동안 변하지 않는 **값을 저장**할 때 사용하는 React 훅

- **DOM 요소에 직접 접근**
  * 특정 `<input>`, `<video>` 등과 같은 HTML 태그를 '기억'
  * 그 속성에 직접 접근
- **렌더링과 독립적인 값 저장**
  * `useState`와 달리 `useRef`로 저장한 값은 변경되어도 **컴포넌트를 재렌더링하지 않습니다.**

### 2\. `useRef` 사용법

- `useRef`는 `current` 속성을 가진 객체를 반환
- `current` 속성을 통해 저장된 값에 접근하거나 수정함

#### DOM 요소 접근하기

1.  **`useRef` 호출**: 초기값으로 `null`을 전달하여 ref 객체를 생성
    ```jsx
    const usernameRef = useRef(null);
    ```
2.  **`ref` 속성 연결**: 접근하려는 JSX 요소에 `ref` 속성을 연결
    ```jsx
    <input
      id='username'
      type='text'
      ref={usernameRef}
    />
    ```
    `usernameRef.current`는 `<input>` 태그를 가리킴

#### `current` 속성으로 값 사용하기

- `useRef`에 저장된 DOM 요소의 속성이나 값을
- `current`를 통해 가져오거나 설정할 수 있습니다.

```jsx
const $usernameInput = usernameRef.current;
const $ageInput = ageRef.current;

// 입력된 값 가져오기
const userValue = {
  username: $usernameInput.value,
  age: $ageInput.value,
};

// ... (입력값 검증 등 로직)

// 입력 필드 초기화
$usernameInput.value = '';
$ageInput.value = '';

// 이름 입력 필드에 포커스
$usernameInput.focus();
```

### 3\. `useState` vs `useRef`

| 구분           | `useState`                               | `useRef`                                   |
| -------------- | ---------------------------------------- | ------------------------------------------ |
| **목적** | **상태**를 관리하고 UI를 업데이트        | **값**을 저장하고 DOM에 직접 접근          |
| **렌더링** | 값이 변경되면 **재렌더링** 발생          | `current` 값이 변경되어도 **재렌더링 안 함** |
| **적합한 경우** | 사용자 입력, UI 상태 변경 등             | DOM 조작, 컴포넌트 생애주기 동안 유지할 값 |

---

## React Side Effect 관리하기
---

### 1\. Side Effect란?

* **외부의 상태를 변경**,
* **외부 환경과 상호작용**하는 모든 동작을 의미

React 컴포넌트에서의 Side Effect
* 데이터를 가져오거나, 구독하거나, 수동으로 변경하는 등의 I/O 작업
* DOM을 직접적으로 조작하는 작업
* setTimeout, setInterval 같은 타이머를 설정하는 작업

---

### 2\. Side Effect와 무한 루프 문제

- React 컴포넌트는 상태(state)가 변경되면 재렌더링
- 이때 재렌더링 과정에서 Side Effect를 포함하는 로직이 있다면,
- Side Effect가 다시 상태를 변경하고, 재렌더링이 일어나는
- \*\*무한 루프(Infinite Loop)\*\* 발생 가능

예시)
- 로그인 상태를 로컬 스토리지에 저장하고,
- 새로고침 시 이 값을 읽어 로그인 상태를 복원

**문제 코드**

```jsx
// 컴포넌트 렌더링 시마다 실행
console.log('토큰 검사!');
const token = localStorage.getItem('token');
if (token === '1') {
  setIsLoggedIn(true); // 🚨 상태 변경 -> 리렌더링
}
```

- `isLoggedIn` 상태를 변경하고, 컴포넌트가 다시 렌더링
- 그러면 `setIsLoggedIn(true)`가 또 실행되어 무한히 반복됨

---

## useEffect Hook
- 함수 컴포넌트에서는 `useEffect`를 사용
- side effect (서버에서 데이터를 가져오거나 외부 비동기작업) 처리를 위한 훅 (리액트 함수)
- 초기 렌더링 이후에 useEffect가 수행됨

### useEffect 함수의 기본 형태
```jsx
useEffect(() => {
  // side effect를 수행하는 코드를 여기에 작성합니다.

  return () => {
    // cleanup 코드를 여기에 작성합니다.
    // 이 코드는 컴포넌트가 unmount되거나, 다음 effect가 실행되기 전에 수행됩니다.
  };
}, [dependency1, dependency2]); // 의존성 배열
```

## 로그인 Side Effect 해결
```jsx
// 렌더링이 완료된 후 한 번만 실행되도록 설정
useEffect(() => {
  console.log('useEffect가 실행됨!');
  const token = localStorage.getItem('token');
  if (token === '1') {
    setIsLoggedIn(true); // 리렌더링 발생
  }
}, []);
```

---

## useEffect 의존성 배열

useEffect의 두번째 파라미터 배열은 의존성 배열이라고 부르며
1. 생략할 경우 useEffect는 렌더링시마다 반복 실행됨
2. 빈 배열일 경우 최초 한번만 실행됨 (토큰검사 최초1번, 서버데이터 페칭 최초1번)
3. 배열안에 변수를 넣을 경우, 해당 변수값이 변경될 떄마다 재실행

### 로그인 버튼 활성화 여부 검증을 위한 useEffect
```jsx
useEffect(() => {
  setFormIsValid(
    enteredEmail.includes('@') && enteredPassword.trim().length > 6
  );
}, [enteredEmail, enteredPassword]);
```
- enteredEmail, enteredPassword가 변경될 때마다 useEffect 재실행
- 내부에서 로그인 버튼 활성화 여부를 검증

---

## useEffect cleanup 함수
- useEffect가 실행 되고 다음 번 useEffect 실행 직전에 실행되는 정리함수

### 로그인 버튼 검증 cleanup 함수 적용
```jsx
useEffect(() => {
  const timerId = setTimeout(() => {
    setFormIsValid(
      enteredEmail.includes('@') && enteredPassword.trim().length > 6
    );
  }, 1000);

  // cleanup 함수
  return () => {
    clearTimeout(timerId);
  };
}, [enteredEmail, enteredPassword]);
```
- cleanup 함수를 통해 디바운스 구현
- enteredEmail 혹은 enteredPassword가 변경
  -> 1초 뒤 로그인 버튼 활성화 검증
- 1초가 되기 전에 다시 입력하면 cleanup 함수 실행됨
  -> 기존 타이머 취소, 타이머 재가동

---


## 📌 오늘의 요약

오늘 배운 내용을 통해 리액트 컴포넌트를 더 효율적이고 안전하게 개발하는 방법을 익혔습니다. 특히, **불필요한 렌더링을 줄이고(리팩토링, useRef)**, **컴포넌트의 부수 효과(Side Effect)를 안전하게 관리(useEffect)**하는 것이 중요하다는 것을 이해했습니다.

1.  **코드 간결화**: 조건부 렌더링과 클래스네임 적용 시 **`&&` 연산자**와 **삼항 연산자**를 활용하여 코드를 깔끔하게 만듭니다.
2.  **성능 최적화**: `Array.prototype.find()`는 배열 순회를 최소화하고, `useRef`는 리렌더링 없이 DOM에 직접 접근하거나 값을 유지할 때 사용해 불필요한 렌더링을 막습니다.
3.  **안정성 확보**: `useEffect` 훅을 사용해 컴포넌트 렌더링과 분리된 Side Effect를 처리함으로써 무한 루프와 같은 문제를 예방하고, `cleanup` 함수로 불필요한 타이머를 정리할 수 있습니다.

이러한 리액트 훅과 문법들을 적재적소에 사용하면 유지보수가 쉽고 안정적인 애플리케이션을 만들 수 있습니다.
