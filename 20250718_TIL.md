# 🗓️ 2025년 7월 18일 TIL




스프링 빈(Bean) 관리
1. 스프링 빈의 정의와 생명주기

#### 스프링 빈의 정의
- 스프링에서 **빈(Bean)**은 스프링 IoC 컨테이너가 관리하는 객체를 의미
- 애플리케이션의 라이프사이클 동안 IoC 컨테이너에 의해 생성되고 관리됨.
- 스프링 빈은 주로 XML 파일, 자바 클래스, 애너테이션으로 정의됨

#### 스프링 빈의 생명주기
1. 빈 정의: XML, 자바 클래스, 애너테이션으로 정의됨
2. 빈 생성: 빈 정의를 바탕으로 스프링 IoC 컨테이너가 빈 생성
3. 의존성 주입: 생성된 빈에 필요한 의존성을 주입
4. 초기화: 빈이 초기화 메서드를 통해 초기화됨
5. 사용: 애플리케이션에서 빈을 사용
6. 소멸: 애플리케이션이 종료되거나, 빈이 더 이상 필요하지 않으면 빈 소멸

---

2. 빈 생성과 관리 방법
- XML, 자바, 애너테이션 기반 설정 방법이 있음.

XML 설정
- 스프링 초기 버전에서 XML을 사용하여 빈을 설정
- 빈을 정의, 해당 빈의 의존성을 주입

---

자바 설정
- 스프링 3.0 이후부터는 자바 클래스를 사용하여 빈을 정의하고 관리
- 자바 설정을 통해 타입 안정성을 높이고, 설정을 더 직관적으로 관리
```java
@Configuration
public class MyModelConfig {
    // 빈등록 (빈 정의) : 스프링에게 관리를 위임할 객체들을 지정
    @Bean
    public MyRepository repository() {
        return new MyRepository();
    }
    @Bean
    public MyService service() {
        return new MyService(repository());
    }
    @Bean
    public MyController controller() {
        return new MyController(service());
    }
}
```
@Configuration
- 이 클래스가 스프링 설정(설정 정보 제공자) 클래스임을 의미
- 이 안에 정의된 @Bean 메서드들을 Spring IoC 컨테이너가 관리할 수 있도록 등록해주는 역할
---

애너테이션 기반 설정
- 애너테이션을 사용하여 스프링 빈을 더 간편하게 정의
- 자바 클래스에 애너테이션을 붙여 빈을 설정, 스프링 컨테이너가 이를 관리하도록 함
주요 애너테이션:
- `@Component`: 일반적인 빈을 정의
- `@Service`: 비즈니스 로직을 담고 있는 서비스 계층을 정의할 때 사용
- `@Repository`: 데이터 접근 계층(DAO)에서 사용
- `@Controller`: 웹 애플리케이션에서 컨트롤러 계층을 정의할 때 사용

저장소 접근 클래스 예시
```java
@Repository
public class MyRepository {
}
```
@Repository는 @Component를 포함하고있음.
클래스들에 @Component 붙임으로써 스프링에게 빈 등록 (빈 정의)


테스트 예시
```java
@Test
void test() {
    ApplicationContext context
            = new AnnotationConfigApplicationContext(SpringCore202507Application.class);
    MyService service = context.getBean(MyService.class);
    System.out.println("ProcessData = " + service.processData());
}
```
- 따로 Config 클래스를 작성하지 않아도 테스트 가능

---


애너테이션 기반 구성
1. `@Autowired`를 사용한 의존성 주입

생성자에 @Autowired 사용
필요한 의존객체를 자동으로 결합해주겠다.
생략 가능하나,
생성자가 딱 하나일 때만 @Autowired를 생략할 수 있음
```java
@Controller
public class MyController {
    private MyService service;
    @Autowired
    public MyController(MyService service) {
        this.service = service;
    }
}
```

2. @Qualifier를 사용한 특정 빈 주입
- 같은 타입의 여러 빈이 존재할 때, 어떤 빈을 주입할지 명시적으로 지정

학생 정보를 control 하는 클래스
```java
@Controller
public class StudentController {
    private StudentRepository repository;
    public StudentController(@Qualifier("smr") StudentRepository repository) {
        this.repository = repository;
    }
}
```

학생 정보를 메모리에 저장하는 클래스
```java
@Repository("smr")
public class StudentMemoryRepository implements StudentRepository {
    @Override
    public void save(Student student) {
        // ... 생략
    }
    @Override
    public List<Student> findAll() {
        return List.of();
    }
}
```

3. @ComponentScan을 사용한 컴포넌트 스캔
- 해당 패키지 범위안에서 @Component가 붙은 클래스들을 전부 잡아와서 빈으로 등록시킴

Config 클래스 예시
```java
@Configuration
@ComponentScan(basePackages = "com.spring.core.chap02_3")
public class MyModelConfig {
}
```





---

스프링의 스코프

싱글톤 스코프
```java
@Test
void test() {
    ApplicationContext context
                = new AnnotationConfigApplicationContext(StudentConfig.class);
    
    StudentController controller1 = context.getBean(StudentController.class);
    StudentController controller2 = context.getBean(StudentController.class);
    System.out.println("controller1 = " + controller1);
    System.out.println("controller2 = " + controller2);
}
```
- 스프링은 빈을 관리할 때 단일 인스턴스를 유지함.
- controller1과 controller2의 주소값이 동일함.


프로토타입 스코프
@Scope("prototype")
- 특징: 빈이 요청될 때마다 새로운 인스턴스를 생성

---

스프링 3계층 구조의 이해: Controller, Service, Repository
- 스프링에서는 관심사의 분리를 위해 애플리케이션을 세 개의 주요 계층으로 나눈다.

1. 각 계층의 상세 역할
의존 관계: Controller -> Service -> Repository

Controller 계층
- 사용자 입력에 관련된 요청과 응답을 처리
- 관심사: 클라이언트 요청을 받고 응답을 전해주는 것
- 실제로 데이터를 관리하는 것 -> 관심 X

Service 계층
- 데이터 변환 및 예외처리, 트랜잭션 담당(DB 연결)

Repository 계층
- 데이터를 전담 관리하는 클래스
- 관심사: 데이터를 다루는 것만 관심있음. 요청응답 -> 관심 없음

---
@RequiredArgsConstructor
final 필드나 @NonNull이 붙은 필드를 대상으로
자동으로 생성자(Constructor)를 만들어주는 Lombok 애노테이션

사용 예시
```java
@RestController
@RequiredArgsConstructor // final 필드만 파라미터로 받는 생성자
public class FeedController {
    
    private final FeedService feedService;

//    @Autowired
//    public FeedController(FeedRepository feedRepository) {
//        this.feedRepository = feedRepository;
//    }
}
```
생성자가 딱 하나일 때만 @Autowired를 생략할 수 있고,
@RequiredArgsConstructor를 통해 final이 붙은 필드만
파라미터로 받아서 의존성을 주입하는 생성자를 만들 수 있다.
그리하여 필드를 정의했지만, 초기화를 안 해주는 것처럼 보일 수 있다!

---

Oracle 데이터베이스 설치
1. Oracle Database 21c Express Edition (XE)
- 오라클에서 제공하는 무료 버전의 데이터베이스 서버
- https://www.oracle.com/database/technologies/xe-downloads.html
- Oracle Database 21c Express Edition for Windows x64

Oracle DB 설치 확인
- SQL Plus 실행 (윈도우 검색)
- 사용자명: system
- 비밀번호: oracle
- `select sysdate from dual;` 입력해서 당일 나오면 잘 설치된 것.

2. Oracle SQL Developer
- Oracle은 데이터베이스 서버(창고), SQL Developer(데이터 관리 도구)

2-1. SQL Developer 다운로드
- vscode extension에서 `Oracle SQL Developer Extension for VSCode`를 검색하고 설치
- 왼쪽에 드럼통 모양 아이콘 나오는지 확인 (SQL Developer)

2-2. 데이터베이스 접속(Connection) 만들기
- 새 폴더 `oracle-project`를 만들고 그 폴더를 열어줌
- 드럼통 아이콘(SQL Developer)을 클릭하고 접속 부분에서 추가
- Connection Name(연결 이름, 자유), Username(system), Password(oracle)
- Hostname(localhost), Port(1521, 기본 통신 번호), Service Name(XEPDB1) 


기본 설정 변경(언어, 날짜 표현)
- 파일 - 기본설정 - 설정 - 확장 
- Oracle SQL Developer Extension for VSCode
- 데이터베이스 NLS
- 언어, Territory KOREA로 변경
- Date Format(YYYY/MM/DD HH24:MI:SS)
- Timestamp Format(YYYY/MM/DD HH24:MI:SSXFF)
- Timestamp TZ Format(YYYY/MM/DD HH24:MI:SSXFF TZR)