# 🗓️ 2025년 11월 28일 TIL - C언어

## 📌 오늘의 키워드

`스택(Stack)` `후입선출(LIFO)` `배열 기반 스택` `연결 리스트 기반 스택`
`push()` `pop()` `is_empty()` `is_full()`

---

## 1️⃣ 스택(Stack)의 개념

### 💡 정의

* **스택(Stack)** 은 데이터를 **한쪽 방향으로만 넣고 빼는 자료구조**이다.
* 특징: **LIFO (Last In, First Out)**
  → 나중에 들어간 데이터가 가장 먼저 나온다.

예시

```
push(10) → push(20) → push(30)
pop() → 30
pop() → 20
```

### 주요 용도

* **재귀 함수 호출 관리 (Call Stack)**
* **괄호 검사, 되돌리기(Undo)**
* **DFS (깊이 우선 탐색)**

---

## 2️⃣ 배열 기반 스택 (Array Stack)

### 💻 구조체 정의

```c
#define MAX_STACK_SIZE 5

typedef struct {
    int data[MAX_STACK_SIZE];
    int top;
} Stack;
```

* `data[]`: 스택 데이터를 저장할 배열
* `top`: 스택의 가장 위 인덱스를 가리킴

  * `-1`이면 스택이 비어 있음

---

### ⚙️ 주요 함수

#### 초기화

```c
void init_stack(Stack* s) {
    s->top = -1;
}
```

→ 스택 비우기

#### 공백/포화 상태 확인

```c
int is_empty(Stack* s) { return (s->top == -1); }
int is_full(Stack* s) { return (s->top == MAX_STACK_SIZE - 1); }
```

#### 데이터 삽입 (push)

```c
void push(Stack* s, int item) {
    if (is_full(s)) {
        printf("스택이 가득 찼습니다!!\n");
        return;
    }
    s->data[++(s->top)] = item;
}
```

* `top`을 증가시키고 새 데이터를 삽입
* 스택이 꽉 차면 경고 출력

#### 데이터 제거 (pop)

```c
int pop(Stack* s) {
    if (is_empty(s)) {
        printf("스택이 텅 비었습니다.\n");
        exit(1);
    }
    return s->data[(s->top)--];
}
```

* `top` 위치의 데이터를 반환 후 `top`을 감소

---


### ✅ 장단점 비교

| 항목         | 장점         | 단점               |
| ---------- | ---------- | ---------------- |
| **배열 스택**  | 구현이 간단, 빠름 | 크기 고정, 메모리 낭비 가능 |
| **메모리 위치** | 연속된 메모리    | 고정 크기 제한 존재      |


---

## 3️⃣ 연결 리스트 기반 스택 (Linked Stack)

### 💻 구조체 정의

```c
typedef struct Node {
    int data;
    struct Node* next;
} Node;

typedef struct {
    Node* top;
} LinkedStack;
```

* `top`이 스택의 가장 위 노드를 가리킴
* 각 노드는 동적으로 생성되므로 **크기 제한이 없음**

---

### ⚙️ 주요 함수

#### 초기화

```c
void init_stack(LinkedStack* s) {
    s->top = NULL;
}
```

#### 데이터 삽입 (push)

```c
void push(LinkedStack* s, int item) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = item;
    newNode->next = s->top;
    s->top = newNode;
}
```

#### 데이터 제거 (pop)

```c
int pop(LinkedStack* s) {
    if (is_empty(s)) {
        printf("스택이 텅 비었습니다.\n");
        exit(1);
    }
    Node* temp = s->top;
    int item = temp->data;
    s->top = temp->next;
    free(temp);
    return item;
}
```

---


### ✅ 장단점 비교

| 항목            | 장점                    | 단점             |
| ------------- | --------------------- | -------------- |
| **연결 리스트 스택** | 크기 제한 없음, 유연함         | 노드마다 추가 메모리 필요 |
| **메모리 위치**    | 비연속적 (malloc으로 동적 생성) | 관리 복잡          |


---

## 🎯 최종 비교 정리

| 기준     | 배열 기반 스택      | 연결 리스트 기반 스택 |
| ------ | ------------- | ------------ |
| 메모리 구조 | 연속            | 비연속 (동적)     |
| 크기 제한  | 고정 (MAX_SIZE) | 제한 없음        |
| 속도     | 빠름            | 약간 느림        |
| 메모리 효율 | 좋음            | 오버헤드 있음      |
| 구현 난이도 | 쉬움            | 중간           |
| 사용 예   | 스택 크기가 명확할 때  | 크기가 가변적일 때   |

---

## 💬 오늘의 소감

오늘은 **스택(Stack)** 의 두 가지 구현 방식을 실습했다.
배열 기반 스택은 구조가 단순하고 빠르지만, 크기 제약이 명확했고,
연결 리스트 기반 스택은 메모리 효율성은 떨어지지만 **무한 확장이 가능**했다.
함수 호출 스택의 작동 원리와 `push/pop` 구조를 직접 구현하면서,
컴퓨터가 “함수를 쌓았다가 되돌리는 방식”을 실제 코드로 체험할 수 있었다.
