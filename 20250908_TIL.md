# 🗓️ 2025년 9월 8일 TIL

## 📌 오늘의 키워드
`Context API` `useContext` `Provider` `Consumer` `createContext` `전역 상태 관리` `Props Drilling` `함수형 컴포넌트`

---

## Context API란?

### Props Drilling의 한계
- Props로 데이터를 전달하는 것은 컴포넌트 트리가 깊어질수록 비효율적
- 중간 컴포넌트들이 필요하지 않은 props를 단순히 전달만 하는 문제 발생

### Context API의 개념
- **창고(Context)에 데이터를 보관**하고 필요한 컴포넌트에서 직접 꺼내 쓰는 방식
- 컴포넌트 트리의 깊이와 상관없이 전역적으로 데이터 공유 가능

---

## Context API의 3가지 핵심 요소

### 1. createContext
```javascript
const MyContext = React.createContext(초기값);
```
- Context 객체를 생성하는 함수
- 인자로 컨텍스트의 **초기값**을 받음
- 생성된 Context는 Provider와 Consumer를 포함

### 2. Provider
```javascript
<MyContext.Provider value={전달할_데이터}>
  {children}
</MyContext.Provider>
```
- Context를 제공하는 컴포넌트
- 하위 컴포넌트 트리에게 Context 값을 제공
- `value` prop을 통해 데이터를 전달

### 3. Consumer
```javascript
<MyContext.Consumer>
  {context => <p>{context.data}</p>}
</MyContext.Consumer>
```
- Context를 소비하는 컴포넌트
- 가장 가까운 Provider의 `value` prop을 읽음
- 함수형 렌더링 방식 사용

---

## Context 사용 예제 (클래스 컴포넌트)

### 전체 흐름: 생성 → 제공 → 소비

```javascript
import React from 'react';

// 1. Context 생성
const MyContext = React.createContext();

// 2. Provider 컴포넌트 생성
class MyProvider extends React.Component {
  state = {
    name: "John Doe"
  }

  render() {
    return (
      <MyContext.Provider value={{
        name: this.state.name
      }}>
        {this.props.children}
      </MyContext.Provider>
    );
  }
}

// 3. Consumer 컴포넌트 생성
class MyConsumer extends React.Component {
  render() {
    return (
      <MyContext.Consumer>
        {context => <p>{context.name}</p>}
      </MyContext.Consumer>
    );
  }
}

// 4. App 컴포넌트에서 사용
function App() {
  return (
    <MyProvider>
      <MyConsumer />
    </MyProvider>
  );
}
```

**동작 과정**:
1. `MyProvider`가 `name: "John Doe"`를 Context에 저장
2. `MyConsumer`가 Context에서 데이터를 꺼내서 화면에 표시
3. 중간 컴포넌트를 거치지 않고 직접 데이터 전달

---

## useContext Hook (함수형 컴포넌트)

### useContext란?
- Context API를 **함수형 컴포넌트**에서 더 간결하게 사용할 수 있게 해주는 훅
- Consumer를 사용하는 것보다 훨씬 직관적이고 코드가 간결함

### 기본 사용법
```javascript
import React, { useContext } from 'react';
import MyContext from './MyContext';

function MyComponent() {
  // useContext로 Context 값을 직접 가져옴
  const contextValue = useContext(MyContext);

  return <p>{contextValue}</p>;
}
```

**Consumer vs useContext 비교**:

```javascript
// Consumer 방식 (복잡함)
<MyContext.Consumer>
  {context => <p>{context.name}</p>}
</MyContext.Consumer>

// useContext 방식 (간결함)
const { name } = useContext(MyContext);
return <p>{name}</p>;
```

---

## 주의사항: Provider와 Consumer의 관계

### 문제 상황 ❌

Provider 컴포넌트 내부에서 바로 Context를 소비하려고 하면 **작동하지 않음**

```jsx
const App = () => {
  return (
    <CartProvider>
      {/* ❌ CartProvider 내부에서 cartIsShown을 사용할 수 없음 */}
      {cartIsShown && <Cart />}
      <Header />
      <div id="main">
        <Meals />
      </div>
    </CartProvider>
  );
};
```

**이유**: Provider는 데이터를 **제공하는** 역할이지 **소비하는** 역할이 아니기 때문

---

### 해결 방법 ✅

Provider의 **하위 컴포넌트**에서 Context를 소비하도록 분리

```jsx
const App = () => {
  return (
    <CartProvider>
      {/* MainCart를 별도 컴포넌트로 분리 */}
      <MainCart />
    </CartProvider>
  );
};

// Provider의 하위 컴포넌트에서 Context 소비
const MainCart = () => {
  const { cartIsShown } = useContext(CartContext);
  
  return (
    <>
      {cartIsShown && <Cart />}
      <Header />
      <div id="main">
        <Meals />
      </div>
    </>
  );
};
```

**핵심 포인트**:
- Provider는 Context를 제공만 함
- Context 소비는 반드시 Provider의 **하위 컴포넌트**에서 수행
- 컴포넌트를 분리하여 Provider와 Consumer의 역할을 명확히 구분

---

## 🎯 최종 정리

- **Context API**는 Props Drilling 없이 전역 상태를 관리하는 React 내장 기능
- **3가지 핵심 요소**: createContext(생성) → Provider(제공) → Consumer/useContext(소비)
- **useContext Hook**은 함수형 컴포넌트에서 Context를 간결하게 사용 가능
- **Provider와 Consumer 분리 필수** → Provider 내부에서 직접 소비 불가, 하위 컴포넌트로 분리
- 핵심 포인트: **컴포넌트 구조 설계, 역할 분리, useContext로 간결한 코드 작성**
