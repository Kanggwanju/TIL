# 🗓️ 2025년 8월 5일 TIL


토이 프로젝트 생성
Spring Boot: 버전 3.5.4
종속성 추가
- Spring Boot DevTools
- Lombok
- Spring Web
- Thymeleaf
- Spring Data JPA
- MariaDB Driver

---

```java
/*
    사용자 엔터티
    - 인증 시스템의 핵심 엔터티로 기본 사용자 정보관리
 */
@Entity
@Table(name = "tbl_user")
@Getter
@ToString
@EqualsAndHashCode(of = "id")
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "user_id")
    private Long id;

    @Column(name = "user_name", unique = true, nullable = false, length = 50)
    private String username;

    @Column(name = "user_email", unique = true, nullable = false, length = 100)
    private String email;

    // 패스워드는 사용자가 지정한 길이가 8~20자여도 결국 DB에는 암호화되어서 해시로 들어간다.
    @Column(name = "password", nullable = false, length = 255)
    private String password;
    
    // 모든 테이블에는 생성시간과 마지막 수정시간이 필수
    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(nullable = false)
    private LocalDateTime updatedAt;
    
    // AllArgs 대신에 따로 생성자를 하나 만듦
    @Builder
    public User(String username, String email, String password) {
        this.username = username;
        this.email = email;
        this.password = password;
    }
}
```

@AllArgsConstructor, @Builder
- 안 쓴 이유는 id와 생성시간 등은 자동으로 생성되며
- Builder 패턴을 통해 변경시키지 않게 하기 위함

@EqualsAndHashCode(of = "id")
- 보통 id만 맞다면 동일한 것으로 판단하기 때문에
- id만 비교 대상으로 삼음


@Column(name = "password", nullable = false, length = 255)
- 패스워드는 사용자가 지정한 길이가 8~20자여도 결국 DB에는 암호화되어서 해시로 들어간다.
- 그리하여 길이를 255로 맞춰놓은 것

모든 테이블에는 생성시간과 마지막 수정시간이 필수적으로 들어감.


AllArgs 대신에 따로 생성자를 하나 만들고,
Builder 애너테이션을 붙임
```java
@Builder
public User(String username, String email, String password) {
    this.username = username;
    this.email = email;
    this.password = password;
}
```

---

사용자 Repository 인터페이스 생성
```java
public interface UserRepository extends JpaRepository<User, Long> {

    /**
     * 로그인할 때 사용자는 자신의 이름이나 이메일을 입력하지 숫자id를 입력하지 않음
     * 그 이름이나 이메일을 통해 회원정보를 조회해야 한다.
     */
    Optional<User> findByUsername(String username);
    Optional<User> findByEmail(String email);

    // 중복확인
    boolean existsByUsername(String username);
    boolean existsByEmail(String email);
}

```

